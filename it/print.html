<!DOCTYPE HTML>
<html lang="it" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GB ASM Tutorial</title>
        <meta name="robots" content="noindex" />

        <!-- Custom HTML head -->
        <meta name="twitter:card" content="summary_large_image"/>
        <meta name="twitter:site:id" content="@gbdev0"/>
        <meta property="og:title" content="GB ASM Tutorial" />
        <meta property="og:image" content="https://gbdev.io/gb-asm-tutorial/assets/banner/1200x628.png" />
        <meta property="og:site_name" content="GB ASM Tutorial"/>
        
        <!-- Matomo tracking -->
        <script>
          var _paq = window._paq = window._paq || [];
          /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
          _paq.push(['trackPageView']);
          _paq.push(['enableLinkTracking']);
          (function() {
            var u="//stats.gbdev.io/";
            _paq.push(['setTrackerUrl', u+'matomo.php']);
            _paq.push(['setSiteId', '1']);
            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
            g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
          })();
        </script>
        <!-- End Matomo Code -->

        <meta name="description" content="A complete guide to programming Game Boy games in assembly.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Home</a></li><li class="chapter-item affix "><a href="roadmap.html">Tabella di marcia</a></li><li class="chapter-item affix "><a href="help-feedback.html">Aiuto</a></li><li class="chapter-item affix "><li class="part-title">Parte Ⅰ - Hello World!</li><li class="chapter-item "><a href="part1/setup.html"><strong aria-hidden="true">1.</strong> Configurazione</a></li><li class="chapter-item "><a href="part1/hello_world.html"><strong aria-hidden="true">2.</strong> Hello World!</a></li><li class="chapter-item "><a href="part1/toolchain.html"><strong aria-hidden="true">3.</strong> Strumenti di lavoro</a></li><li class="chapter-item "><a href="part1/bin_and_hex.html"><strong aria-hidden="true">4.</strong> Binario ed esadecimale</a></li><li class="chapter-item "><a href="part1/registers.html"><strong aria-hidden="true">5.</strong> Registri</a></li><li class="chapter-item "><a href="part1/assembly.html"><strong aria-hidden="true">6.</strong> Basi di Assembly</a></li><li class="chapter-item "><a href="part1/memory.html"><strong aria-hidden="true">7.</strong> Memoria</a></li><li class="chapter-item "><a href="part1/header.html"><strong aria-hidden="true">8.</strong> L'header</a></li><li class="chapter-item "><a href="part1/operations.html"><strong aria-hidden="true">9.</strong> Operazioni e flags</a></li><li class="chapter-item "><a href="part1/jumps.html"><strong aria-hidden="true">10.</strong> Salti</a></li><li class="chapter-item "><a href="part1/tracing.html"><strong aria-hidden="true">11.</strong> Tracciamento</a></li><li class="chapter-item "><div><strong aria-hidden="true">12.</strong> Grafica</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/tiles.html"><strong aria-hidden="true">12.1.</strong> Tiles</a></li><li class="chapter-item "><a href="part1/palettes.html"><strong aria-hidden="true">12.2.</strong> Palette</a></li><li class="chapter-item "><a href="part1/tilemap.html"><strong aria-hidden="true">12.3.</strong> Tilemap</a></li></ol></li><li class="chapter-item "><a href="part1/wrapup.html"><strong aria-hidden="true">13.</strong> In conclusione</a></li><li class="chapter-item affix "><li class="part-title">Parte Ⅱ - Il nostro primo gioco</li><li class="chapter-item "><a href="part2/getting-started.html"><strong aria-hidden="true">14.</strong> Per iniziare</a></li><li class="chapter-item "><a href="part2/objects.html"><strong aria-hidden="true">15.</strong> Oggetti</a></li><li class="chapter-item "><a href="part2/functions.html"><strong aria-hidden="true">16.</strong> Funzioni</a></li><li class="chapter-item "><a href="part2/input.html"><strong aria-hidden="true">17.</strong> Input</a></li><li class="chapter-item "><a href="part2/collision.html"><strong aria-hidden="true">18.</strong> Collisioni</a></li><li class="chapter-item "><a href="part2/bricks.html"><strong aria-hidden="true">19.</strong> Mattoncini</a></li><li class="chapter-item "><a href="part2/wip.html"><strong aria-hidden="true">20.</strong> Lavori in corso</a></li><li class="chapter-item affix "><li class="part-title">Parte III — Il nostro secondo gioco</li><li class="chapter-item "><a href="part3/getting-started.html"><strong aria-hidden="true">21.</strong> Come iniziare</a></li><li class="chapter-item "><a href="part3/project-structure.html"><strong aria-hidden="true">22.</strong> Struttura del progetto</a></li><li class="chapter-item "><a href="part3/entry-point.html"><strong aria-hidden="true">23.</strong> Punto di ingresso</a></li><li class="chapter-item "><a href="part3/changing-game-states.html"><strong aria-hidden="true">24.</strong> Cambiamento dello Stato di Gioco</a></li><li class="chapter-item "><a href="part3/title-screen.html"><strong aria-hidden="true">25.</strong> Schermata del titolo</a></li><li class="chapter-item "><a href="part3/story-screen.html"><strong aria-hidden="true">26.</strong> Schermata della storia</a></li><li class="chapter-item "><a href="part3/gameplay.html"><strong aria-hidden="true">27.</strong> Gameplay</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part3/scrolling-background.html"><strong aria-hidden="true">27.1.</strong> Sfondo scorrevole</a></li><li class="chapter-item "><a href="part3/heads-up-interface.html"><strong aria-hidden="true">27.2.</strong> Heads-Up Interface</a></li><li class="chapter-item "><a href="part3/sprites-metasprites.html"><strong aria-hidden="true">27.3.</strong> Sprites & Metasprites</a></li><li class="chapter-item "><a href="part3/object-pools.html"><strong aria-hidden="true">27.4.</strong> Object Pools</a></li><li class="chapter-item "><a href="part3/the-player.html"><strong aria-hidden="true">27.5.</strong> Il giocatore</a></li><li class="chapter-item "><a href="part3/bullets.html"><strong aria-hidden="true">27.6.</strong> Bullets</a></li><li class="chapter-item "><a href="part3/enemies.html"><strong aria-hidden="true">27.7.</strong> Nemici</a></li><li class="chapter-item "><a href="part3/collision.html"><strong aria-hidden="true">27.8.</strong> Rilevamento della collisione (collision detection)</a></li><li class="chapter-item "><a href="part3/enemy-player-collision.html"><strong aria-hidden="true">27.9.</strong> Collisione nemico-giocatore</a></li><li class="chapter-item "><a href="part3/enemy-bullet-collision.html"><strong aria-hidden="true">27.10.</strong> Enemy-Bullet Collision</a></li></ol></li><li class="chapter-item "><a href="part3/conclusion.html"><strong aria-hidden="true">28.</strong> Conclusione</a></li><li class="chapter-item affix "><a href="next.html">Prossimi passi</a></li><li class="chapter-item affix "><a href="cheatsheet.html">Cheatsheet</a></li><li class="chapter-item affix "><a href="resources.html">Risorse</a></li><li class="chapter-item affix "><a href="thanks.html">Ringraziamenti</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GB ASM Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="it">Italian</a>
                          </button></li>
                        </ul>

                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("it");
                          selectedLang.parentNode.classList.add("theme-selected");

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "../";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }
                        </script>

                        
                        <a href="https://github.com/gbdev/gb-asm-tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pagina-principale"><a class="header" href="#pagina-principale">Pagina Principale</a></h1>
<p>👋 Benvenuto in gb-asm-tutorial!
Questo tutorial ti insegnerà come programmare giochi per il Game Boy e per il Game Boy Color.</p>
<div class="box tip">
<p>While the Game Boy and Game Boy Color are almost the same console, <strong>the Game Boy Advance is entirely different</strong>.
However, the GBA is able to run GB and GBC games!
If you are looking to program GBC games and run them on a GBA, you’re at the right place; however, if you want to make games specifically for the GBA, please check out the <a href="https://gbadev.net/tonc/">Tonc tutorial</a> instead.</p>
</div>
<h2 id="comandi"><a class="header" href="#comandi">Comandi</a></h2>
<p>In cima alla pagina puoi vedere alcune icone, sempre presenti se ne dovessi avere bisogno!</p>
<ul>
<li>The “burger” <i class="fa fa-bars"></i> toggles the navigation side panel;</li>
<li>The brush <i class="fa fa-paint-brush"></i> allows selecting a different color theme;</li>
<li>The magnifying glass <i class="fa fa-search"></i> pops up a search bar;</li>
<li>The world icon <i class="fa fa-globe"></i> lets you change the language of the tutorial;</li>
<li>The printer <i class="fa fa-print"></i> gives a single-page version of the <em>entire</em> tutorial, which you can print if you want;</li>
<li>The GitHub icon <i class="fa fa-github"></i> links to the tutorial’s source repository;</li>
<li>The edit button <i class="fa fa-edit"></i> allows you to suggest changes to the tutorial, provided that you have a GitHub account.</li>
</ul>
<p>Ci sono anche delle frecce a lato della pagina (o in fondo, se sei su cellulare) per passare alla pagina successiva o precedente.</p>
<p>E con questo, per iniziare ti basterà premere la freccia a destra :)</p>
<h2 id="autori"><a class="header" href="#autori">Autori</a></h2>
<p>Il tutorial è stato scritto da <a href="https://eldred.fr/">Eldred “ISSOtm” Habert</a>, <a href="https://evie.gbdev.io/">Evie</a>, <a href="https://github.com/avivace">Antonio Vivace</a>, <a href="https://www.LaroldsJubilantJunkyard.com">LaroldsJubilantJunkyard</a> e <a href="https://github.com/gbdev/gb-asm-tutorial/graphs/contributors">altri collaboratori</a>.</p>
<h2 id="contribuire"><a class="header" href="#contribuire">Contribuire</a></h2>
<p>You can <strong>provide feedback</strong> or send suggestions in the form of Issues on the <a href="https://github.com/gbdev/gb-asm-tutorial">GitHub repository</a>.</p>
<p>We’re also <a href="https://github.com/gbdev/gb-asm-tutorial/issues">looking for help</a> for <strong>writing new lessons and improving the existing ones</strong>! You can go through the Issues to see what needs to be worked on and send Pull Requests!</p>
<p>You can also help <strong>translating</strong> the tutorial on <a href="https://crowdin.com/project/gb-asm-tutorial">Crowdin</a>.</p>
<h2 id="licenza"><a class="header" href="#licenza">Licenza</a></h2>
<p><strong>In breve</strong>:</p>
<ul>
<li>Code within the tutorial is essentially <strong>public domain</strong>, meaning that you are allowed to copy it freely without restrictions.</li>
<li>You are free to copy the tutorial’s contents (prose, diagrams, etc.), modify them, and share that, but you must give credit and license any copies under the same license.</li>
<li>This site’s <em>source code</em> can be freely copied, but you must give a license and copyright notice.</li>
</ul>
<p><strong>Maggiori Informazioni</strong>, per maggiori informazioni sulle rispettive licenze, seguire questi link:</p>
<ul>
<li>All the code contained within the tutorial itself is licensed under <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a>. <em>To the extent possible under law, all copyright and related or neighboring rights to code presented within GB ASM Tutorial have been waived.</em></li>
<li>The contents (prose, images, etc.) of this tutorial are licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>Code used to display and format the site is licensed under the <a href="https://github.com/gbdev/gb-asm-tutorial/blob/master/LICENSE">MIT License</a> unless otherwise specified.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tabella-di-marcia"><a class="header" href="#tabella-di-marcia">Tabella di marcia</a></h1>
<p>The tutorial is split into three parts.
<strong>We strongly advise you go through the tutorial in order!</strong></p>
<p>Nella parte Ⅰ, lanciamo il nostro primo programma “Hello World!”, per poi analizzarlo al fine di capire come funziona il Game Boy.</p>
<p>Nella parte Ⅱ programmiamo il nostro primo gioco, un clone di <em>Arkanoid</em>; impariamo a dare le prime istruzioni all’hardware per ottenere qualcosa che si possa definire “gioco”.
Lungo il percorso commetteremo molti errori, ma questo servirà anche a imparare a risolvere i problemi del nostro codice.</p>
<p>Infine, la Parte Ⅲ riguarda l’uso “avanzato” dell’hardware, dove impareremo a creare giochi ancora più rifiniti e programmeremo uno “Shoot ’Em Up”!</p>
<p>Questo tutorial è ancora in lavorazione.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aiuto"><a class="header" href="#aiuto">Aiuto</a></h1>
<p>We hope this tutorial will work for you.</p>
<p>But if it doesn’t (the format may not work well for everyone, and that’s okay), we encourage to look at <a href="resources.html">some other resources</a>, which might work better for you.</p>
<p>It’s also fine to <strong>take a break from time to time</strong>; feel free to read at your own pace.</p>
<p>If you are stuck in a certain part of the tutorial, want some advice, or just wish to chat with us, <a href="https://gbdev.io/chat">the GBDev community chat</a> is the place to go!
The authors actively participate there so don’t be afraid to ask questions!
The <code>#asm</code> channel should be the most appropriate to discuss the tutorial.</p>
<p>Se preferisci la posta elettronica, puoi raggiungerci all’indirizzo <code>tutorial@&lt;domain&gt;</code>, devi sostituire <code>&lt;domain&gt;</code> con il nome di dominio di questo sito.
Si tratta di una misura antispam, spero che tu capisca.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preparazione"><a class="header" href="#preparazione">Preparazione</a></h1>
<p>Per prima cosa, dobbiamo configurare il nostro ambiente di sviluppo.
Avremo bisogno di:</p>
<ol>
<li>A POSIX environment</li>
<li><a href="https://rgbds.gbdev.io/install">RGBDS</a> v0.5.1 (though v0.5.0 should be compatible)</li>
<li>GNU Make (preferably a recent version)</li>
<li>A code editor</li>
<li>A debugging emulator</li>
</ol>
<div class="box tip decorated"><p>❓😕</p>
<p>The following install instructions are provided on a “best-effort” basis, but may be outdated, or not work for you for some reason.
Don’t worry, we’re here to help: <a href="part1/../help-feedback.html">ask away</a>, and we’ll help you with installing everything!</p>
</div>
<h2 id="strumenti"><a class="header" href="#strumenti">Strumenti</a></h2>
<h3 id="linux-e-macos"><a class="header" href="#linux-e-macos">Linux e macOS</a></h3>
<p>Buone notizie: hai già completato il primo passo!
Dovete solo <a href="https://rgbds.gbdev.io/install">installare RGBDS</a> e forse aggiornare GNU Make.</p>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>Al momento della stesura di questo articolo, macOS (fino alla 11.0, l’ultima release attuale) ha in dotazione un GNU Make molto datato.
È possibile verificarlo aprendo un terminale ed eseguendo <code>make --version</code>, che dovrebbe indicare “GNU Make” e una data, tra le altre cose.</p>
<p>Se il vostro Make è troppo vecchio, potete aggiornarlo usando la formula di <a href="https://brew.sh">Homebrew</a> <a href="https://formulae.brew.sh/formula/make#default"><code>make</code></a>.
Al momento in cui scriviamo, dovrebbe essere stampato un avviso che il Make aggiornato è stato installato come <code>gmake</code>; si può seguire il suggerimento di usarlo come <code>make</code> “predefinito”, oppure usare <code>gmake</code> invece di <code>make</code> in questo tutorial.</p>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<p>Una volta installato RGBDS, aprite il terminale ed eseguite il comando <code>make --version</code> per controllare la vostra versione di Make (che probabilmente è GNU Make).</p>
<p>Se <code>make</code> non è presente, potrebbe essere necessario installare le <code>build-essentials</code> della propria distribuzione.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>The modern tools we’ll be using for Game Boy development have been designed for a Unix environment, so setup on Windows is not fully straightfoward.  However, it’s possible to install an environment that will provide everything we need.</p>
<p>On Windows 10 and Windows 11, your best bet is <a href="https://docs.microsoft.com/en-us/windows/wsl">WSL</a>, which is a method for running a Linux distribution within Windows.
Install WSL, then a distribution of your choice (pick Ubuntu if unsure), and then follow these steps again, but for the Linux distribution you installed.</p>
<p>In alternativa a WSL, si può usare <a href="https://www.msys2.org">MSYS2</a> o <a href="https://www.cygwin.com">Cygwin</a>; per poi consultare le istruzioni per l’installazione di Windows di [RGBDS] (https://rgbds.gbdev.io/install).
Per quanto ne so, entrambi dovrebbero fornire una versione sufficientemente aggiornata di GNU Make.</p>
<div class="box tip">
<p>Se avete programmato per altre console, come il GBA, controllate che MSYS2 non sia già installato sul vostro computer.
Questo perché devkitPro, un popolare pacchetto di sviluppo homebrew, include MSYS2.</p>
</div>
<h2 id="editor-di-codice"><a class="header" href="#editor-di-codice">Editor di codice</a></h2>
<p>Qualsiasi editor di codice va bene; personalmente uso <a href="https://www.sublimetext.com">Sublime Text</a> con il suo <a href="https://packagecontrol.io/packages/RGBDS">pacchetto sintassi RGBDS</a>; tuttavia è possibile usare qualsiasi editor di testo, compreso il Blocco Note se si è abbastanza pazzi.
Awesome GBDev ha <a href="https://gbdev.io/resources#syntax-highlighting-packages">una sezione sui pacchetti per l’evidenziazione della sintassi</a> dove potete controllare se il vostro editor preferito supporta RGBDS.</p>
<h2 id="emulatore"><a class="header" href="#emulatore">Emulatore</a></h2>
<p>Using an emulator to play games is one thing; using it to program games is another.
The two aspects an emulator must fulfill to allow an enjoyable programming experience are:</p>
<ul>
<li><strong>Debugging tools</strong>:
When your code goes haywire on an actual console, it’s very difficult to figure out why or how.
There is no console output, no way to <code>gdb</code> the program, nothing.
However, an emulator can provide debugging tools, allowing you to control execution, inspect memory, etc.
These are vital if you want GB dev to be <em>fun</em>, trust me!</li>
<li><strong>Good accuracy</strong>:
Accuracy means “how faithful to the original console something is”.
Using a bad emulator for playing games can work (to some extent, and even then…), but using it for <em>developing</em> a game makes it likely to accidentally render your game incompatible with the actual console.
For more info, read <a href="https://arstechnica.com/?post_type=post&amp;p=44524">this article on Ars Technica</a> (especially the <q>An emulator for every game</q> section at the top of page 2).
You can compare GB emulator accuracy on <a href="https://daid.github.io/GBEmulatorShootout/">Daid’s GB-emulator-shootout</a>.</li>
</ul>
<p>The emulator I will be using for this tutorial is <a href="https://emulicious.net/">Emulicious</a>.
Users on all OSes can install the Java runtime to be able to run it.
Other debugging emulators are available, such as <a href="https://www.mesen.ca/">Mesen2</a>, <a href="https://bgb.bircd.org">BGB</a> (Windows/Wine only), <a href="https://sameboy.github.io">SameBoy</a> (graphical interface on macOS only); they should have similar capabilities, but accessed through different menu options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>In questa lezione inizieremo ad assemblare il nostro primo programma.
Il resto del capitolo sarà dedicato a spiegare come e perché funziona.</p>
<p>Tenete presente che da ora dovremo lanciare molti comandi, quindi è il momento di aprire una finestra del terminale.
È buon norma creare una nuova directory (<code>mkdir gb_hello_world</code>, per esempio, poi <code>cd gb_hello_world</code> per entrare nella nuova directory).</p>
<p>Grab the following files (right-click each link, “Save Link As…”), and place them all in this new directory:</p>
<ul>
<li><a href="part1/../assets/hello-world.asm"><code>hello-world.asm</code></a></li>
<li><a href="https://raw.githubusercontent.com/gbdev/hardware.inc/v4.0/hardware.inc"><code>hardware.inc</code></a></li>
</ul>
<p>Quindi, sempre dal terminale, all’interno di quella directory, lanciate i tre comandi seguenti.</p>
<div class="box tip"><p class="box-title">CONVENTION</p>
<p>To make it clear where each command begins, they are preceded by a <code>$</code> symbol. However, do not type it when entering them in your shell!</p>
</div>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbasm -o hello-world.o hello-world.asm</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgblink -o hello-world.gb hello-world.o</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgbfix -v -p 0xFF hello-world.gb</span>
</code></pre>
<style>
	.box.danger ol {
		list-style-type: symbols(fixed "👎" "👍" "👍");
	}
</style>
<div class="box danger decorated"><p>‼️</p>
<p>Fate attenzione agli argomenti! Alcune opzioni, come <code>-o</code>, usano l’argomento dopo di esse come parametro:</p>
<ol>
<li><code>rgbasm -o hello-world.asm hello-world.o</code> won’t work (and may corrupt <code>hello-world.asm</code>!)</li>
<li><code>rgbasm hello-world.asm -o hello-world.o</code> will work</li>
</ol>
<p>In caso di spazi all’interno di un argomento, è necessario metterlo tra virgolette:</p>
<ol>
<li><code>rgbasm -o hello world.o hello world.asm</code> won’t work</li>
<li><code>rgbasm -o &quot;hello world.o&quot; &quot;hello world.asm&quot;</code> will work</li>
</ol>
</div>
<p>It should look like this:</p>
<script id="asciicast-weljUlcp1KC5GqS9jqV62dy5m" src="https://asciinema.celforyon.fr/a/weljUlcp1KC5GqS9jqV62dy5m.js" async></script>
<p>(Se riscontrate un errore che non riuscite a risolvere da soli, non abbiate paura di <a href="part1/../index.html#feedback">chiedere</a>! Lo risolveremo insieme)</p>
<p>Congrats!
You just assembled your first Game Boy ROM!
Now, we just need to run it; open Emulicious, then go “File”, then “Open File”, and load <code>hello-world.gb</code>.</p>
<video controls poster="../assets/vid/hello_world.poster.png">
	<source src="../assets/vid/hello_world.webm" type="video/webm">
	<source src="../assets/vid/hello_world.mp4" type="video/mp4">
<pre><code>&lt;img src=&quot;../assets/vid/hello_world.gif&quot; alt=&quot;Video demonstration in Emulicious&quot;&gt;
</code></pre>
</video>
<p>Potreste anche prendere una flash cart (cartuccia flash) (io uso l’<a href="https://krikzz.com/store/home/47-everdrive-gb.html">EverDrive GB X5</a>, ma ci sono molte alternative), caricarci la vostra ROM e farla girare su una console vera e propria!</p>
<p><img src="part1/../assets/img/hello_dmg.jpg" alt="Immagine di Hello World in esecuzione su una console DMG reale" /></p>
<p>Bene, ora che abbiamo qualcosa che funziona, è il momento di togliere le tende per scoprire cosa c’è sotto…</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strumenti-di-lavoro"><a class="header" href="#strumenti-di-lavoro">Strumenti di lavoro</a></h1>
<p>Dunque, nella lezione precedente abbiamo scritto una piccola ROM “Hello World!”.
Ora è il momento di capire meglio cosa abbiamo fatto.</p>
<h2 id="rgbasm-e-rgblink"><a class="header" href="#rgbasm-e-rgblink">RGBASM e RGBLINK</a></h2>
<p>Iniziamo spiegando cosa fanno <code>rgbasm</code> e <code>rgblink</code>.</p>
<p>RGBASM è un <em>assembler</em> (compilatore).
Il suo compito è leggere il codice sorgente (nel nostro caso <code>hello-world.asm</code> e <code>hardware.inc</code>) e generare un file di codice che però è incompleto:
RGBASM non sempre ha tutte le informazioni che gli servono a generare una ROM, quindi produce dei <em>file oggetto</em> che fanno da intermediari (con estensione <code>.o</code>).</p>
<p>RGBLINK è un <em>linker</em>.
Il suo compito è usare le informazioni dei file oggetto (che nel nostro caso è solo uno) ed unirli (in inglese “link”) in una ROM.
RGBLINK potrebbe sembrare superfluo, ma è solo perché la ROM che abbiamo guardato è davvero piccola: quando nella seconda parte il nostro progetto crescerà, la sua utilità sarà più apparente.</p>
<p>Quindi: Codice sorgente → <code>rgbasm</code> → File oggetto → <code>rgblink</code> → ROM, giusto?
Beh, non esattamente.</p>
<h2 id="rgbfix"><a class="header" href="#rgbfix">RGBFIX</a></h2>
<p>RGBLINK does produce a ROM, but it’s not quite usable yet.
See, actual ROMs have what’s called a <em>header</em>.
It’s a special area of the ROM that contains <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html">metadata about the ROM</a>; for example, the game’s name, Game Boy Color compatibility, and more.
For simplicity, we defaulted a lot of these values to 0 for the time being; we’ll come back to them in Part Ⅱ.</p>
<p>However, the header contains three crucial fields:</p>
<ul>
<li>The <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0104-0133--nintendo-logo">Nintendo logo</a>,</li>
<li>the <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0148--rom-size">ROM’s size</a>,</li>
<li>and <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#014d--header-checksum">two checksums</a>.</li>
</ul>
<p>Quando la console viene accesa viene eseguito <a href="https://github.com/ISSOtm/gb-bootroms">un programma</a> chiamato <em>ROM di avvio</em> (boot ROM) responsabile, tra l’altro, dell’animazione di avvio leggendo il logo di Nintendo dalla ROM.
Alla fine dell’animazione, però, la ROM di avvio controlla che il logo di Nintendo sia corretto, e interrompe l’esecuzione se non lo è:
in pratica, se non azzecchiamo il logo il nostro gioco non partirà mai… 😦
Questo meccanismo era per evitare la pirateria; per nostra fortuna, però, <a href="https://en.wikipedia.org/wiki/Sega_v._Accolade">non è più valida</a> perciò non dobbiamo preoccuparci! 😄</p>
<p>Allo stesso modo, la ROM di avvio calcola anche un <em><a href="https://en.wikipedia.org/wiki/Checksum">checksum</a></em> dell’header, presumibilmente per garantire che non sia corrotto.
L’header contiene anche una copia di questo checksum; se non corrisponde a quello calcolato dalla ROM di avvio, la ROM di avvio <strong>si blocca!</strong></p>
<p>L’header contiene anche un checksum dell’intera ROM, ma non viene mai utilizzato.
Non costa niente ed è una buona idea, comunque, farlo bene.</p>
<p>Infine, l’header contiene anche la dimensione della ROM, necessaria per emulatori e dalle flash cart.</p>
<p>RGBFIX serve proprio a compilare l’header in automatico, in particolare questi tre campi senza i quali il GameBoy non farà funzionare il gioco.
L’opzione <code>-v</code> dice a RGBFIX di rendere <strong>v</strong>alido l’header, inserendo il logo e calcolando le checksum.
L’opzione <code>-p 0xFF</code> invece aggiunge dei byte alla ROM finché non raggiunge una dimensione valida (in inglese <strong>p</strong>adding), per poi scriverla nell’header.</p>
<p>Perfetto!
Quindi, per riassumere: <br>
codice sorgente → <code>rgbasm</code> → file oggetto → <code>rgblink</code> → ROM “vera” → <code>rgbfix</code> → ROM funzionante</p>
<p>A questo punto ti potresti chiedere: perché non si uniscono tutti questi programmi in uno solo?
Ci sono ragioni nella storia di questi programmi, ma soprattutto RGBLINK può fare altro (per esempio usando <code>-x</code>), e a volte RGBFIX è usato senza che RGBLINK sia minimamente necessario.</p>
<h2 id="nomi-dei-file"><a class="header" href="#nomi-dei-file">Nomi dei file</a></h2>
<p>A RGBDS, come alla maggior parte dei programmi, non importa come chiami i file né l’estensione che gli dai: l’importante è il contenuto.
Per esempio molti usano l’estensione <code>.s</code> per il sorgente, oppure <code>.obj</code> per gli oggetti.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binario-ed-esadecimale"><a class="header" href="#binario-ed-esadecimale">Binario ed esadecimale</a></h1>
<p>Prima di passare al codice dobbiamo introdurre alcuni concetti.</p>
<p>Quando si programma ad un basso livello è fondamentale capire bene i sistemi <em><a href="https://it.wikipedia.org/wiki/Sistema_numerico_binario">binario</a></em> ed <em><a href="https://it.wikipedia.org/wiki/esadecimale">esadecimale</a></em>.
Se già conoscessi questi concetti, in fondo alla pagina ci sono delle informazioni specifiche all’uso di RGDBS.</p>
<p>Cos’è il binario?
È semplicemente un modo alternativo di rappresentare i numeri, in <em>base 2</em>.
Noi contiamo in <a href="https://it.wikipedia.org/wiki/decimale">base 10</a>, ovvero con 10 cifre: 0, 1, 2, 3, 4, 5, 6, 7, 8, e 9.
Le cifre hanno una funzione ben specifica:</p>
<pre><code>  42 =                       4 × 10   + 2
     =                       4 × 10^1 + 2 × 10^0
                                  ↑          ↑
    These tens come from us counting in base 10!

1024 = 1 × 1000 + 0 × 100  + 2 × 10   + 4
     = 1 × 10^3 + 0 × 10^2 + 2 × 10^1 + 4 × 10^0
       ↑          ↑          ↑          ↑
And here we can see the digits that make up the number!
</code></pre>
<div class="box tip"><p class="box-title">CONVENTION</p>
<p><code>^</code> qui significa “alla potenza di”, dove <code>X^N</code> è uguale a moltiplicare <code>X</code> con se stesso <code>N</code> volte, e <code>X ^ 0 = 1</code>.</p>
</div>
<p>Con le cifre decimali ogni numero viene <em>scomposto</em> in maniera univoca in potenze di 10 (il <em>deci</em>male è la base 10, ricordi?).
Ma perché fermarsi alle potenze di 10?
Potremmo invece usare altre basi, come la base 2
(il perché della base 2 sarà spiegato più avanti).</p>
<p>Il sistema binario è in base 2, quindi ha solo due cifre (chiamate <em>bit</em>): 0 e 1.
Possiamo quindi generalizzare il principio descritto sopra e riscrivere i due numeri di prima in modo simile:</p>
<pre><code>  42 =                                                    1 × 32  + 0 × 16  + 1 × 8   + 0 × 4   + 1 × 2   + 0
     =                                                    1 × 2^5 + 0 × 2^4 + 1 × 2^3 + 0 × 2^2 + 1 × 2^1 + 0 × 2^0
                                                              ↑         ↑         ↑         ↑         ↑         ↑
                                          And since now we're counting in base 2, we're seeing twos instead of tens!

1024 = 1 × 1024 + 0 × 512 + 0 × 256 + 0 × 128 + 0 × 64  + 0 × 32  + 0 × 16  + 0 × 8   + 0 × 4   + 0 × 2   + 0
     = 1 × 2^10 + 0 × 2^9 + 0 × 2^8 + 0 × 2^7 + 0 × 2^6 + 0 × 2^5 + 0 × 2^4 + 0 × 2^3 + 0 × 2^2 + 0 × 2^1 + 0 × 2^0
       ↑          ↑         ↑         ↑         ↑         ↑         ↑         ↑         ↑         ↑         ↑
</code></pre>
<p>Quindi, applicando lo stesso principio, possiamo dire che in base 2, 42 si scrive come <code>101010</code> e 1024 come <code>10000000000</code>. 
Poiché non è possibile distinguere tra dieci (10 decimale) e due (10 binario), l’assemblaggio RGBDS prevede numeri binari preceduti da un segno di percentuale: 10 è dieci e %10 è due.</p>
<p>Ok, ma perché proprio la base 2?
Visto che un bit può essere solo 0 o 1, è molto facile rappresentarlo: può essere “ON” o “OFF”, vuoto o pieno, ecc!
Se ad esempio si vuole creare una memoria da un bit basta prendere una scatola:
se è vuota allora simboleggia uno 0; se contiene <em>qualcosa</em>, allora è un 1.
I computer manipolano quindi principalmente numeri binari e questo ha <em>molte</em> implicazioni, come vedremo nel corso di questo tutorial.</p>
<h2 id="esadecimale"><a class="header" href="#esadecimale">Esadecimale</a></h2>
<p>Ricapitolando: il decimale non è pratico per i computer, che si affidano invece ai numeri binari (base 2).
Ok, ma il binario è davvero difficile da usare per noi programmatori.
Prendiamo %10000000000, ovvero 2048; mentre per scriverlo in decimale bastano solo 4 cifre, in binario ne servono 12!
E probabilmente non avete neanche notato che ho scritto uno zero di troppo!
Per fortuna arriva l’esadecimale a salvare la situazione! 🦸</p>
<p>La base 16 funziona esattamente come tutte le altre basi, ma con 16 cifre (chiamate “<em>nibbles</em>” in inglese): 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, ed F.</p>
<pre><code>  42 =            2 × 16   + 10
     =            2 × 16^1 + A × 16^0

1024 = 4 × 256  + 0 × 16   + 0
     = 4 × 16^2 + 0 × 16^1 + 0 × 16^0
</code></pre>
<p>Come per il binario useremo un prefisso per indicare l’esadecimale, cioè <code>$</code>.
Quindi, 42 = $2A e 1024 = $400.
Questo è <em>molto</em> più compatto del binario, e anche un po’ più del decimale; ma ciò che rende l’esadecimale molto interessante è che una sua cifra corrisponde <em>esattamente</em> a 4 bit!</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Nibble</th><th style="text-align: center">Bits</th></tr></thead><tbody>
<tr><td style="text-align: center">$0</td><td style="text-align: center">%0000</td></tr>
<tr><td style="text-align: center">$1</td><td style="text-align: center">%0001</td></tr>
<tr><td style="text-align: center">$2</td><td style="text-align: center">%0010</td></tr>
<tr><td style="text-align: center">$3</td><td style="text-align: center">%0011</td></tr>
<tr><td style="text-align: center">$4</td><td style="text-align: center">%0100</td></tr>
<tr><td style="text-align: center">$5</td><td style="text-align: center">%0101</td></tr>
<tr><td style="text-align: center">$6</td><td style="text-align: center">%0110</td></tr>
<tr><td style="text-align: center">$7</td><td style="text-align: center">%0111</td></tr>
<tr><td style="text-align: center">$8</td><td style="text-align: center">%1000</td></tr>
<tr><td style="text-align: center">$9</td><td style="text-align: center">%1001</td></tr>
<tr><td style="text-align: center">$A</td><td style="text-align: center">%1010</td></tr>
<tr><td style="text-align: center">$B</td><td style="text-align: center">%1011</td></tr>
<tr><td style="text-align: center">$C</td><td style="text-align: center">%1100</td></tr>
<tr><td style="text-align: center">$D</td><td style="text-align: center">%1101</td></tr>
<tr><td style="text-align: center">$E</td><td style="text-align: center">%1110</td></tr>
<tr><td style="text-align: center">$F</td><td style="text-align: center">%1111</td></tr>
</tbody></table>
</div>
<p>Ciò rende facilissimo convertire tra binario ed esadecimale, e mantenere una notazione sufficientemente compatta.
Per questo, l’esadecimale è molto più utilizzato del binario.
E non preoccuparti, puoi ancora usare il decimale 😜</p>
<p>(Nota: si potrebbe pensare che anche l’ottale, cioè la base 8, funzioni altrettanto bene; tuttavia avremo a che fare perlopiù con unità di 8 bit, per le quali l’esadecimale funziona molto meglio dell’ottale. Volendo, RGBDS permette di usare l’ottale tramite il prefisso <code>&amp;</code>, ma non l’ho mai visto usare nella pratica)</p>
<div class="box tip">
<p>If you’re having trouble converting between decimal and binary/hexadecimal, check whether your favorite calculator program has a ‘programmer’ mode or a way to convert between bases.</p>
</div>
<h2 id="riepilogo"><a class="header" href="#riepilogo">Riepilogo</a></h2>
<ul>
<li>In RGBDS assembly, the hexadecimal prefix is <code>$</code>, and the binary prefix is <code>%</code>.</li>
<li>Hexadecimal can be used as a “compact binary” notation.</li>
<li>Using binary or hexadecimal is useful when individual bits matter; otherwise, decimal works just as well.</li>
<li>For when numbers get a bit too long, RGBASM allows underscores between digits (<code>123_465</code>, <code>%10_1010</code>, <code>$DE_AD_BE_EF</code>, etc.)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registri"><a class="header" href="#registri">Registri</a></h1>
<p>Alright!
Now that we know what bits are, let’s talk about how they’re used.
Don’t worry, this is mostly preliminary work for the next section, where we will—finally!—look at the code 👀</p>
<p>First, if you opened Emulicious, you have been greeted with just the Game Boy screen.
So, it’s time we pop the debugger open!
Go to “Tools”, then click “Debugger”, or press <kbd><kbd>F1</kbd></kbd>.
Then in the debugger’s menu, click “View”, then click “Show Addresses”</p>
<video controls poster="../assets/vid/debugger.poster.png">
	<source src="../assets/vid/debugger.webm" type="video/webm">
	<source src="../assets/vid/debugger.mp4" type="video/mp4">
<pre><code>&lt;img src=&quot;../assets/vid/debugger.gif&quot; alt=&quot;Video demonstration in Emulicious&quot;&gt;
</code></pre>
</video>
<p>Il debugger potrebbe sembrare incomprensibile all’inizio, ma non ti preoccupare: ti ci abituerai in fretta!
Per il momento guarda in alto a destra, dove c’è un piccolo spazio intitolato <em>register viewer</em> (visualizzatore dei registri).</p>
<p><img src="part1/../assets/img/reg_viewer.png" alt="Immagine della posizione del visualizzatore di registri" /></p>
<div class="box warning decorated"><p>⚠️</p>
<p>Il visualizzatore mostra sia i <em>registri della CPU</em> che alcuni <em>registri hardware</em>.
In questa lezione parleremo solo dei registri della CPU, perciò non ti preoccupare se salteremo alcuni nomi.</p>
</div>
<p>Ma cosa sono questi registri della CPU?
Ti faccio un esempio: immagina di star preparando una torta.
Ovviamente avrai una ricetta da seguire, come ad esempio “sciogli 125g di cioccolato e 125g di burro, mescola il tutto con due uova” e così via.
Dopo aver preso gli ingredienti, non li usi direttamente nel frigo; per comodità, li prenderai e li metterai su un banco da lavoro o un tavolo dove lavorarci più facilmente.</p>
<p>I registri sono questo tavolo, su cui il processore poggia temporaneamente i suoi ingredienti.
Più concretamente, sono dei piccoli spazi di memoria (Il GameBoy ne ha solo 10 byte, e anche le CPU moderne hanno meno di un kilobyte se non si contano i registri <a href="https://it.wikipedia.org/wiki/SIMD"><abbr title="Single Instruction, Multiple Data">SIMD</abbr></a>).
Eseguire le operazioni direttamente sulla memoria è scomodo, sarebbe come rompere le uova nel frigo: per questo le spostiamo sul tavolo, i registri, prima di romperle.</p>
<div class="box tip decorated"><p>ℹ️</p>
<p>Ovviamente ci sono eccezioni a questa regola, come un po’ tutte le regole che ti spiegheremo nel tutorial; stiamo semplificando di molto le cose per mantenerle ad un livello abbastanza facile da comprendere, perciò non prendere mai queste regole troppo alla lettera.</p>
</div>
<h2 id="registri-generici"><a class="header" href="#registri-generici">Registri Generici</a></h2>
<p>A grandi linee ci sono due tipi di registri: <em>registri generici</em> e <em>registri speciali</em>.
Un registro generico (abbreviato <abbr title="inglese: General-Purpose Register">GPR</abbr>) può essere usato per dati di qualunque tipo.
Qualche GPR ha anche delle funzioni più specifiche, come vedremo più in là; in generale per distinguerli da quelli speciali chiediti “posso inserirci dati arbitrari?”.</p>
<p>Parleremo poi dei registri speciali;
hanno funzioni particolari che non abbiamo ancora spiegato e perciò li spiegheremo quando parleremo della funzione specifica, visto che fino ad allora non ne capiremmo lo scopo.</p>
<p>La CPU del Game Boy ha sette GPR a 8 bit: <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>h</code> e <code>l</code>.
“8 bit” significa che memorizzano 8 bit.
Pertanto, possono memorizzare numeri interi da 0 a 255 (%1111_1111 alias $FF).</p>
<p>`a’ è l’<em>accumulatore</em>, e come vedremo più avanti può essere usato in modi particolari.</p>
<p>Questi registri hanno un’altra caratteristica interessante; sono tutti (tranne <code>a</code>) <em>accoppiati</em> ad un altro registro, e queste coppie possono funzionare da registri a 16 bit: <code>BC</code>, <code>DE</code>, e <code>HL</code>.
Ma tieni sempre a mente che le coppie <em>non</em> sono indipendenti dai registri che li formano; se, ad esempio, <code>D</code> contiene 192 ($C0) ed <code>E</code> 222 ($DE) allora <code>DE</code> conterrà 49374 ($C0DE) = <code>D × 0x100 + E</code>.
Tutte le altre coppie funzionano allo stesso modo.</p>
<p>Quindi, cambiare il valore di <code>DE</code> modifica sia quello di <code>D</code> che di <code>E</code> allo stesso tempo e modificare <code>D</code> o <code>E</code> cambierà il valore della coppia <code>DE</code>.
Ok, ma come facciamo a usare questi registri?
È il momento di dare un’occhiata all’Assembly!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primi-passi-in-assembly"><a class="header" href="#primi-passi-in-assembly">Primi passi in Assembly</a></h1>
<p>Bene, ora che sappiamo cosa <em>fanno</em> gli strumenti, vediamo che lingua parla RGBASM.
Prenderò una breve porzione dell’inizio di <code>hello-world.asm</code>, in modo da essere d’accordo sui numeri di riga e da avere un’evidenziazione della sintassi anche se il vostro editor non la supporta.</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;hardware.inc&quot;

SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header

EntryPoint:
	; Shut down audio circuitry
	ld a, 0
	ld [rNR52], a
</code></pre>
<p>Analizziamolo insieme.
Sappi che per il momento salteremo <em>molte</em> delle funzionalità di RGBASM; se fossi curioso di saperne di più, dovrai aspettare fino alla seconda o terza parte oppure leggere la <a href="https://rgbds.gbdev.io/docs">documentazione</a>.</p>
<h2 id="commenti"><a class="header" href="#commenti">Commenti</a></h2>
<p>Iniziamo dalla riga 10, che dovrebbe essere grigia nel riquadro qui sopra.
I punti e virgola <code>;</code> indicano un <em>commento</em>.
I commenti (che finiscono alla fine della riga) sono <em>ignorati</em> dall’assembler, indipendentemente dal contenuto.
Come vedi alla riga 7, puoi anche inserire commenti dopo aver scritto altro.</p>
<p>I commenti sono molto importanti in tutti i linguaggi di programmazione: ti aiutano a descrivere la funzione del tuo codice.
È più o meno la differenza tra “scalda il forno fino a 180°C” e “scalda il forno a 180°C, se lo scaldassi di più la torta brucerebbe”.
I commenti sono utilissimi in ogni linguaggio di programmazione, ma in Assembly sono ancora più importanti: infatti, il codice Assembly è molto più astratto.</p>
<h2 id="istruzioni"><a class="header" href="#istruzioni">Istruzioni</a></h2>
<p>Assembly is a very line-based language.
Each line can contain one of two things:</p>
<ul>
<li>a <em>directive</em>, which instructs RGBASM to do something, or</li>
<li>an <em>instruction</em><sup class="footnote-reference"><a href="#instr_directive">1</a></sup>, which is written directly into the ROM.</li>
</ul>
<p>Parleremo delle direttive più avanti, per ora concentriamoci sulle istruzioni: per esempio, nello snippet qui sopra, ignoreremo le righe 1 (<code>INCLUDE</code>), 7 (<code>ds</code>) e 3 (<code>SECTION</code>).</p>
<p>Per continuare l’analogia con la preparazione di una torta, le istruzioni sono come i passi di una ricetta.
Il processore (<abbr title="Central Processing Unit">CPU</abbr>) esegue un’istruzione alla volta. Istruzione dopo istruzione… dopo un po’ si arriva al risultato!
Come cuocere una torta, disegnare “Hello World”, oppure mostrarti un tutorial sull’Assembly del GameBoy!</p>
<p>Le istruzioni sono composte da una <em>mnemonica</em>, un nome con cui le puoi invocare, e dei <em>parametri</em>, ovvero su cosa va eseguita l’operazione.
Ad esempio: in “sciogli il cioccolato ed il burro in una padella” l’istruzione è <em>tutta la frase</em>; la mnemonica sarebbe l’<em>azione</em>, ovvero sciogli, mentre i parametri sono gli <em>oggetti</em> della frase (cioccolato, burro, padella).</p>
<p>Cominciamo dall’istruzione più importante: <strong><code>ld</code></strong>.
<code>ld</code> sta per “<abbr title="LoaD in inglese">carica</abbr>”, e semplicemente copia i dati contenuti nel secondo parametro (“<a href="https://en.wikipedia.org/wiki/Sides_of_an_equation"><abbr title="Right-Hand Side">RHS</abbr></a>”) nel primo (“<a href="https://en.wikipedia.org/wiki/Sides_of_an_equation"><abbr title="Left-Hand Side">LHS</abbr></a>”).
Per esempio, guardiamo la riga 11 del nostro programma, <code>ld a, 0</code>: copia (“carica”) il numero zero nel registro <code>a</code><sup class="footnote-reference"><a href="#ld_imm_from">2</a></sup>.
Per fare un altro esempio, a riga 33 troviamo <code>ld a, b</code>: significa semplicemente “copia il valore di <code>b</code> in <code>a</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Instruction</th><th>Mnemonic</th><th>Effect</th></tr></thead><tbody>
<tr><td>Load</td><td><code>ld</code></td><td>Copies values around</td></tr>
</tbody></table>
</div><div class="box tip decorated"><p>ℹ️</p>
<p>Per via delle limitazioni del processore, non tutte le combinazioni di operandi sono valide per <code>ld</code> e per molte altre istruzioni; ne parleremo in seguito, quando arriverà il momento di scrivere il nostro codice.</p>
</div>
<div class="box tip decorated"><p>🤔</p>
<p>RGBDS ha una <a href="https://rgbds.gbdev.io/docs/gbz80.7">lista delle istruzioni del GameBoy</a> che vale la pena tenere tra i preferiti, e che si può anche consultare dal terminale scrivendo <code>man 7 gbz80</code> se RGBDS è installato sulla propria macchina (tranne su Windows…).
Le descrizioni che trovate in quella pagina sono più concise: sono intese come un promemoria, non come un tutorial.</p>
</div>
<h2 id="direttive"><a class="header" href="#direttive">Direttive</a></h2>
<p>Quindi, in un certo senso, le istruzioni sono destinate al processore del GameBoy mentre i commenti sono destinati al programmatore.
Ma alcune righe non sono né l’una né l’altra cosa, e sono invece dei metadati destinati a RGBDS stesso.
Queste sono chiamate <em>direttive</em> e il nostro “Hello World” ne contiene tre.</p>
<h3 id="includere-un-altro-file"><a class="header" href="#includere-un-altro-file">Includere un altro file</a></h3>
<pre><code class="language-rgbasm linenos">INCLUDE &quot;hardware.inc&quot;
</code></pre>
<p>La riga 1 <em>include</em> <code>hardware.inc</code><sup class="footnote-reference"><a href="#hw_inc_directives">3</a></sup>.
<code>Include</code>ndo un file è come se copiassimo il suo contenuto alla riga dove inseriamo la direttiva.</p>
<p>Così facendo, si può riciclare facilmente il codice in diversi file: se, ad esempio, due file <code>a.asm</code> e <code>b.asm</code> includono <code>hardware.inc</code> basta modificare il file perché le modifiche si applichino ad <code>a.asm</code> e <code>b.asm</code>.
Se invece copiassi a mano il contenuto di <code>hardware.inc</code> in <code>a.asm</code> e <code>b.asm</code> dovresti modificare il contenuto di entrambi ogni volta che vuoi apportare un cambiamento, che non è solo uno spreco di tempo ma aumenta la possibilità di commettere errori.</p>
<p><code>hardware.inc</code> definisce alcune costanti molto utili per interfacciarsi con l’hardware del GameBoy.
Le costanti non sono altro che dei nomi a cui è assegnato un valore: scrivere una costante equivale a scrivere il valore che le è assegnato.
Questo torna molto utile: è molto più semplice ricordare il registro “<strong>LCD</strong> <strong>C</strong>ontrol” (impostazioni dello schermo) col nome <code>rLCDC</code> piuttosto che ricordare l’indirizzo <code>$FF40</code>.</p>
<p>Parleremo delle costanti in modo più approfondito nella Parte Ⅱ.</p>
<h3 id="sezioni"><a class="header" href="#sezioni">Sezioni</a></h3>
<p>Spieghiamo innanzitutto che cos’è una “sezione”, poi vedremo che cosa fa la riga 3.</p>
<p>Una sezione rappresenta un intervallo contiguo di memoria che, di base, finisce da <em>qualche</em> parte non nota in anticipo.
Se si vuole vedere dove finisce ogni sezione si può chiedere a RGBLINK di generare un “file mappa” con l’opzione <code>-m</code>:</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgblink hello-world.o -m hello-world.map</span>
</code></pre>
<p>…e possiamo vedere, per esempio, dove è finita la sezione <code>&quot;Tilemap&quot;</code>:</p>
<pre><code>  SECTION: $05a6-$07e5 ($0240 bytes) [&quot;Tilemap&quot;]
</code></pre>
<p>Le sezioni non possono essere divise da RGBDS, che è utile ad esempio per il codice poiché il processore esegue le istruzioni una dopo l’altra (a parte con i salti, che vedremo più avanti).
Va trovato il giusto equilibrio per il numero di sezioni: non troppe ma neanche troppo poche, anche se in genere non ha molta importanza fino a quando non si inizia a parlare di banche di memoria.</p>
<p>Quindi, per ora, assumiamo che una sezione debba contenere cose che “vanno insieme” dal punto di vista topico, ed esaminiamo una delle nostre.</p>
<pre><code class="language-rgbasm linenos start=3">SECTION &quot;Header&quot;, ROM0[$100]
</code></pre>
<p>Quindi!
Cosa fa questa riga?
Altro non è che la dichiarazione di una nuova sezione; tutte le istruzioni e i dati dopo questa riga e fino alla successiva dichiarazione <code>SECTION</code> saranno inseriti in questa sezione appena creata.
Prima della prima direttiva <code>SECTION</code> non c’è una sezione “attiva”: scrivere dati o codice al di fuori di una sezione ci darà l’errore <code>Cannot output data outside of a SECTION</code>.</p>
<p>Il nome della nuova sezione è “<code>Header</code>”.
I nomi delle sezioni possono contenere qualsiasi carattere (e anche essere vuoti, se si vuole) e devono essere unici<sup class="footnote-reference"><a href="#nome_sezione">4</a></sup>.
La parola chiave <code>ROM0</code> indica a quale “tipo di memoria” appartiene la sezione (<a href="https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.5#SECTIONS">ecco un elenco</a>).
Ne parleremo nella Parte Ⅱ.</p>
<p>Dove dice <code>[100$]</code> invece è più interessante, perché è un’indicazione speciale per questa sezione.
Se ricordi, prima abbiamo detto che:</p>
<blockquote>
<p>a section […] by default, ends up <em>somewhere</em> not known in advance.</p>
</blockquote>
<p>Però alcune parti della memoria sono speciali, e quindi a volte è necessario che una sezione specifica copra un intervallo di memoria specifico.
Per permetterlo, RGBASM ha la sintassi <code>[addr]</code> che <em>forza</em> l’indirizzo iniziale della sezione a essere <code>addr</code>.</p>
<p>In questo caso, l’intervallo di memoria $100-$14F è speciale perché è l’header della ROM.
Parleremo dell’header tra un paio di lezioni, ma per il momento basta sapere che <strong>non</strong> dobbiamo inserire né codice né dati in quello spazio.
E come facciamo?
Innanzitutto, iniziamo una sezione all’indirizzo $100, dopodiché riserviamo un po’ di spazio.</p>
<h3 id="lasciare-spazio"><a class="header" href="#lasciare-spazio">Lasciare spazio</a></h3>
<pre><code class="language-rgbasm linenos start=5">	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>La riga 7 afferma di “fare spazio per l’header”, di cui ho parlato brevemente poco sopra.
Per ora, concentriamoci su ciò che <code>ds</code> fa effettivamente.</p>
<p><code>ds</code> è usato per allocare <em>staticamente</em> della memoria.
Riserva un certo numero di byte, che sono impostati ad un certo valore dato.
Il primo argomento di <code>ds</code>, in questo caso <code>$150 - @</code>, è <em>quanti byte riservare</em>.
Il secondo argomento (che è opzionale), in questo caso <code>0</code>, è <em>il valore a cui impostare ogni byte riservato</em><sup class="footnote-reference"><a href="#ds_pattern">5</a></sup>.</p>
<p>Vedremo perché questi byte devono essere riservati in un paio di lezioni.</p>
<p>È importante notare che il primo argomento è un’<em>espressione</em>.
RGBDS (fortunatamente!) supporta l’inserimento di espressioni arbitrarie pressoché ovunque.
Quest’espressione è una semplice sottrazione: $150 meno <code>@</code>, che è un simbolo speciale che sta per “l’indirizzo in memoria attuale”.</p>
<div class="box tip">
<p>Un simbolo è essenzialmente “un nome associato a un valore”, di solito un numero.
Nel corso dell’esercitazione esploreremo i diversi tipi di simboli, a partire dalle etichette nella prossima sezione.</p>
<p>Un simbolo numerico utilizzato in un’espressione viene sostituito dal suo valore, che dev’essere noto al momento della compilazione della ROM; in particolare, non può dipendere dal contenuto di alcun registro.</p>
</div>
<p>Ora vi starete chiedendo cosa siano questi “indirizzi di memoria” di cui continuo a parlare.
Andiamo subito a scoprirlo!</p>
<hr />
<div class="footnote-definition" id="instr_directive"><sup class="footnote-definition-label">1</sup>
<p>Technically, instructions in RGBASM are implemented as directives, basically writing their encoded form to the ROM; but the distinction between the instructions in the source code and those in the final ROM is not worth bringing up right now.</p>
</div>
<div class="footnote-definition" id="ld_imm_from"><sup class="footnote-definition-label">2</sup>
<p>The curious reader may ask where the value is copied <em>from</em>. The answer is simply that the “immediate” byte ($00 in this example) is stored in ROM just after the instruction’s opcode byte, and it’s what gets copied to <code>a</code>.
We will come back to this when we talk about how instructions are encoded later on.</p>
</div>
<div class="footnote-definition" id="hw_inc_directives"><sup class="footnote-definition-label">3</sup>
<p><code>hardware.inc</code> itself contains more directives, in particular to define a lot of symbols.
They will be touched upon much later, so we won’t look into <code>hardware.inc</code> yet.</p>
</div>
<div class="footnote-definition" id="sect_name"><sup class="footnote-definition-label">6</sup>
<p>Section names actually only need to be unique for “plain” sections, and function differently with “unionized” and “fragment” sections, which we will discuss much later.</p>
</div>
<div class="footnote-definition" id="ds_pattern"><sup class="footnote-definition-label">5</sup>
<p>Actually, since RGBASM 0.5.0, <code>ds</code> can accept a <em>list</em> of bytes, and will repeat the pattern for as many bytes as specified.
It just complicates the explanation slightly, so I omitted it for now.
Also, if the argument is omitted, it defaults to what is specified using the <code>-p</code> option <strong>to RGBASM</strong>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memoria"><a class="header" href="#memoria">Memoria</a></h1>
<div class="box tip decorated"><p>🎉</p>
<p>Congratulazioni, avete appena finito le lezioni più difficili del tutorial!
Dal momento che avete le basi, d’ora in poi vedremo codice sempre più concreto.</p>
</div>
<p>Se guardiamo alla riga 29 leggiamo <code>ld a, [de]</code>.
Stando a quanto abbiamo appena appreso, questo copia un valore nel registro <code>a</code>… ma da dove?
Cosa significano queste parentesi?
Per rispondere dobbiamo parlare della <em>memoria</em>.</p>
<h2 id="cosè-una-memoria"><a class="header" href="#cosè-una-memoria">Cos’è una memoria?</a></h2>
<p>Lo scopo della memoria è quello di immagazzinare informazioni.
Su un foglio di carta o su una lavagna si possono scrivere lettere per memorizzare, ad esempio, la lista della spesa.
Ma cosa si può memorizzare nella memoria di un computer?
La risposta a questa domanda è <em>corrente</em><sup class="footnote-reference"><a href="#memoria_magnetica">1</a></sup>.
La memoria del computer è costituita da piccole celle in grado di immagazzinare corrente.
Ma, come abbiamo visto nella lezione sul binario, la presenza o l’assenza di corrente può essere utilizzata per codificare i numeri binari!</p>
<p>Per farla breve: la memoria <strong>immagazzina numeri</strong>.
Difatti la memoria è una <em>lunga</em> lista di numeri, memorizzati in celle.
Per identificare in modo univoco ogni cella, le viene assegnato un numero (e che altro!) chiamato <em>indirizzo</em>.
Come i numeri civici!
La prima cella ha l’indirizzo 0, poi l’indirizzo 1, 2 e così via.
Sul Game Boy ogni cella contiene <em>8 bit</em>, cioè un <em>byte</em>.</p>
<p>Quante cellule ci sono?
In realtà questa è una domanda trabocchetto…</p>
<h2 id="i-tanti-tipi-di-memoria"><a class="header" href="#i-tanti-tipi-di-memoria">I tanti tipi di memoria</a></h2>
<p>There are several memory chips in the Game Boy, but we can put them into two categories: <abbr title="Read-Only Memory">ROM</abbr> and <abbr title="Random Access Memory">RAM</abbr>
<sup class="footnote-reference"><a href="#rom_ram_and">2</a></sup>.
ROM simply designates memory that cannot be written to<sup class="footnote-reference"><a href="#rom_ro">3</a></sup>, and RAM memory that can be written to.</p>
<p>Per via del loro funzionamento il processore ed i circuiti di memoria possono utilizzare un solo numero per gli indirizzi.
Torniamo all’analogia dei “numeri civici”: ogni circuito di memoria è una strada, con la sua serie di numeri, ma il processore non ha idea di cosa sia una strada, si occupa solo di numeri civici.
Per consentire al processore di parlare con più circuiti serve una sorta di “servizio postale”, il <em>selezionatore di circuito</em> (“chip selector” in inglese), che ha il compito di tradurre i numeri civici del processore in una via ed un numero civico effettivi.</p>
<p>For example, let’s say a convention is established where addresses 0 through 1999 go to chip A’s addresses 0–1999, 2000–2999 to chip B’s 0–999, and 3000–3999 to chip C’s 0–999.
Then, if the CPU asks for the byte at address 2791, the chip selector will ask chip B for the byte at its <em>own</em> address 791, and forward the reply to the CPU.</p>
<p>Poiché gli indirizzi trattati dal processore non corrispondono direttamente a quelli dei circuiti si parla di indirizzi <em>logici</em> (qui, quelli del processore) e di indirizzi <em>fisici</em> (qui, quelli dei circuiti), e la corrispondenza è chiamata <em>mappa di memoria</em> (“memory map” in inglese).
Poiché stiamo programmando il processore ci occuperemo solo di indirizzi <strong>logici</strong>, ma è fondamentale tenere presente che indirizzi diversi possono essere supportati da circuiti di memoria diversi, poiché ogni circuito ha caratteristiche uniche.</p>
<p>This may sound complicated, so here is a summary:</p>
<ul>
<li>Memory stores numbers, each 8-bit on the Game Boy.</li>
<li>Memory is accessed byte by byte, and the cell being accessed is determined by an <em>address</em>, which is just a number.</li>
<li>The CPU deals with all memory uniformly, but there are several memory chips each with their own characteristics.</li>
</ul>
<h3 id="mappa-di-memoria-del-game-boy"><a class="header" href="#mappa-di-memoria-del-game-boy">Mappa di memoria del Game Boy</a></h3>
<p>Adesso rispondiamo alla domanda che ci aveva portato a questa sezione: quante celle di memoria ci sono sul Game Boy?
Ora possiamo riformulare meglio questa domanda come “quanti indirizzi logici ci sono?” o “quanti indirizzi fisici ci sono in totale?”.</p>
<p>Gli indirizzi logici, che sono solo numeri, sono a 16 bit sul Game Boy.
Pertanto, ci sono 2^16 = 65536 indirizzi logici, da $0000 a $FFFF.
Ma quanti sono gli indirizzi fisici?
Ecco una mappa della memoria <a href="https://gbdev.io/pandocs/Memory_Map.html">per gentile concessione di Pan Docs</a> (anche se la semplificherò un po’):</p>
<div class="table-wrapper"><table><thead><tr><th>Start</th><th>End</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>$0000</td><td>$7FFF</td><td>ROM</td><td>The game ROM, supplied by the cartridge.</td></tr>
<tr><td>$8000</td><td>$9FFF</td><td>VRAM</td><td>Video RAM, where graphics are stored and arranged.</td></tr>
<tr><td>$A000</td><td>$BFFF</td><td>SRAM</td><td>Save RAM, optionally supplied by the cartridge to save data to.</td></tr>
<tr><td>$C000</td><td>$DFFF</td><td>WRAM</td><td>Work RAM, general-purpose RAM for the game to store things in.</td></tr>
<tr><td>$FE00</td><td>$FE9F</td><td>OAM</td><td>Object Attribute Memory, where “objects” are stored.</td></tr>
<tr><td>$FF00</td><td>$FF7F</td><td>I/O</td><td>Neither ROM nor RAM, but this is where you control the console.</td></tr>
<tr><td>$FF80</td><td>$FFFE</td><td>HRAM</td><td>High RAM, a tiny bit of general-purpose RAM which can be accessed faster.</td></tr>
<tr><td>$FFFF</td><td>$FFFF</td><td>IE</td><td>A lone I/O byte that’s separated from the rest for some reason.</td></tr>
</tbody></table>
</div>
<p>$8000 + $2000 + $2000 + $2000 + $A0 + $80 + $7F + 1 fanno in totale $E1A0, ovvero 57760 byte di memoria che si possono <em>effettivamente</em> usare.
E a questo punto potreste chiedervi: “E i restanti 7776 byte? Cosa succede quando provo ad usarli?”; la risposta è: “Dipende, è complicato; evitate di accedervi”.</p>
<h2 id="etichette"><a class="header" href="#etichette">Etichette</a></h2>
<p>Ok, tutto questo è molto bello, ma non vi aspetterete certo che io tenga in mente tutti questi indirizzi per conto mio, giusto??
Beh, non temere, perché abbiamo le etichette!</p>
<p>Le etichette sono <a href="https://rgbds.gbdev.io/docs/v0.5.1/rgbasm.5#SYMBOLS">simboli</a> che in pratica permettono di assegnare un nome a un indirizzo di memoria.
Un’etichetta viene dichiarata come alla riga 9 (<code>EntryPoint:</code>): all’inizio della riga si scrive il nome dell’etichetta, seguito da due punti, ed essa si riferirà al byte immediatamente successivo.
Quindi, per esempio, <code>EntryPoint</code> si riferisce al <code>ld a, 0</code> subito dopo (più precisamente, al primo byte di quell’istruzione, ma ci arriveremo quando ci arriveremo).</p>
<div class="box tip">
<p>Sbirciando all’interno di <code>hardware.inc</code> si vedrà che, per esempio, <code>rNR52</code> non è definito come un’etichetta.
Il motivo è che queste sono <em>costanti</em>, di cui parleremo più in là; visto che si usano in modo quasi identico alle etichette, per il momento le considereremo uguali.</p>
</div>
<p>Scrivere il nome di un’etichetta equivale a scrivere l’indirizzo del byte a cui fa riferimento (con alcune eccezioni che vedremo nella Parte Ⅱ).
Per esempio, si consideri la <code>ld de, Tiles</code> alla riga 25.
<code>Tiles</code> (riga 64) si riferisce al primo byte dei dati delle mattonelle; se assumiamo che i dati delle mattonelle finiscono per essere memorizzati a partire da $0193, allora <code>ld de, Tiles</code> è equivalente a <code>ld de, $0193</code>!</p>
<h2 id="cosa-sono-queste-parentesi"><a class="header" href="#cosa-sono-queste-parentesi">Cosa sono queste parentesi?</a></h2>
<p>Bene, siamo arrivati a questo punto perché volevamo sapere cosa significano le parentesi in <code>ld a, [de]</code>.
In pratica, possono essere lette come “all’indirizzo…”.
Per esempio, <code>ld a, b</code> può essere letto come “copia in <code>a</code> il valore memorizzato in <code>b</code>”; <code>ld a, [$5414]</code> si legge come “copia in <code>a</code> il valore memorizzato all’indirizzo $5414”, e <code>ld a, [de]</code> si legge come “copia in <code>a</code> il valore memorizzato all’indirizzo <code>de</code>”.
Aspettate, cosa significa?
Beh, se <code>de</code> contiene il valore $5414, allora <code>ld a, [de]</code> farà la stessa cosa di <code>ld a, [$5414]</code>.</p>
<div class="box tip">
<p>Se avete familiarità con il C, queste parentesi sono sostanzialmente il modo in cui viene implementato l’operatore di dereferenziazione.</p>
</div>
<h3 id="hli"><a class="header" href="#hli"><code>hli</code></a></h3>
<p>I lettori attenti avranno notato il <code>ld [hli], a</code> appena sotto il <code>ld a, [de]</code> che abbiamo appena studiato.
<code>[de]</code> ha senso perché è una delle coppie di registri che abbiamo visto un paio di lezioni fa, ma <code>[hli]</code>?
In realtà, è una notazione speciale, che può essere scritta anche come <code>[hl+]</code>.
Funziona come <code>[hl]</code>, ma <code>hl</code> viene <em>incrementato</em> subito dopo l’accesso alla memoria.
<code>[hld]</code>/<code>[hl-]</code> è lo specchio di questa, <em>decrementando</em> <code>hl</code> invece di incrementarlo.</p>
<h2 id="un-esempio"><a class="header" href="#un-esempio">Un esempio</a></h2>
<p>Quindi, se osserviamo le prime due istruzioni di <code>CopyTiles</code>:</p>
<pre><code class="language-rgbasm linenos start=29">	ld a, [de]
	ld [hli], a
</code></pre>
<p>…possiamo vedere che stiamo copiando il byte in memoria <em>puntato</em> da <code>de</code> (cioè il cui indirizzo è contenuto in <code>de</code>) nel byte puntato da <code>hl</code>.
Qui, <code>a</code> serve come memoria temporanea, poiché la CPU non è in grado di eseguire direttamente <code>ld [hl], [de]</code>.</p>
<p>Già che ci siamo, esaminiamo il resto di <code>.copyTiles</code> nelle lezioni successive!</p>
<hr />
<div class="footnote-definition" id="memory_magnetic"><sup class="footnote-definition-label">4</sup>
<p>Actually, this depends a lot on the type of memory.
A lot of memory nowadays uses magnetic storage, but to keep the explanation simple, and to parallel the explanation of binary given earlier, let’s assume that current is being used.</p>
</div>
<div class="footnote-definition" id="rom_ram_and"><sup class="footnote-definition-label">2</sup>
<p>There are other types of memory, such as flash memory or EEPROM, but only Flash has been used on the Game Boy, and for only a handful of games; so we can mostly forget about them.</p>
</div>
<div class="footnote-definition" id="rom_ro"><sup class="footnote-definition-label">3</sup>
<p>No, really!
Mask ROM is created by literally punching holes into a layer of silicon using acid, and e.g. the console’s boot ROM is made of hard-wired transitors within the CPU die.
Good luck writing to that!
<br>
“ROM” is sometimes (mis)used to refer to “persistent memory” chips, such as flash memory, whose write functionality was disabled.
Most bootleg / “repro” Game Boy cartridges you can find nowadays actually contain flash; this is why you can reflash them using specialized hardware, but original cartridges cannot be.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header"><a class="header" href="#header">Header</a></h1>
<p>Torniamo a una certa riga all’inizio di <code>hello-world.asm</code>.</p>
<pre><code class="language-rgbasm linenos start=7">	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>Che cos’è questo misterioso header, detto anche intestazione? Perché dobbiamo allocargli uno spazio specifico? Queste e tante altre domande troveranno una risposta in questa lezione!</p>
<h2 id="cosè-lheader"><a class="header" href="#cosè-lheader">Cos’è l’header?</a></h2>
<p>La prima cosa da fare è spiegare <em>cosa è</em> l’header.
È la regione di memoria da $0104 a $014F (inclusa).
Contiene metadati sulla ROM, come il titolo, la compatibilità con il Game Boy Color, le dimensioni,
due checksum e, cosa interessante, il logo Nintendo che viene visualizzato durante l’animazione di accensione.</p>
<div class="box tip">
<p>Queste e altre informazioni sono disponibili <a href="https://gbdev.io/pandocs/The_Cartridge_Header">nei documenti Pan</a>.</p>
</div>
<p>È interessante notare che la maggior parte delle informazioni contenute nell’header non ha importanza in un hardware reale (la dimensione della ROM è determinata solo dalla capacità del chip ROM nella cartuccia, non dal byte nella intestazione).
Difatti, alcuni prototipi di ROM hanno addirittura informazioni errate nell’header!</p>
<p>La maggior parte dell’header veniva utilizzata solo dal reparto di produzione di Nintendo per sapere quali componenti inserire nella cartuccia quando si pubblicava una ROM.
Pertanto, solo le ROM inviate a Nintendo dovevano avere una intestazione perfettamente accurata; le ROM utilizzate per i test interni dovevano solo superare i controlli della ROM di avvio, che spiegheremo più avanti.</p>
<p>Tuttavia, nella nostra epoca “moderna”, l’header è molto importante.
Gli emulatori (compresi gli emulatori hardware, come le flashcard) devono emulare l’hardware presente nella cartuccia e fanno affidamento su alcuni dei valori presenti nell’header, dato che questa sezione è l’unica fonte di informazioni sull’hardware che la cartuccia della ROM dovrebbe contenere.</p>
<h2 id="rom-di-avvio"><a class="header" href="#rom-di-avvio">ROM di avvio</a></h2>
<p>L’intestazione è profondamente collegata alla cosiddetta <strong>boot ROM</strong> (ROM di “avvio”).</p>
<p>The most observant and/or nostalgic of you may have noticed the lack of the boot-up animation and the Game Boy’s signature “ba-ding!” in Emulicious.
When the console powers up, the CPU does not begin executing instructions at address $0100 (where our ROM’s entry point is), but at $0000.</p>
<p>Tuttavia, in quel momento, un piccolo programma chiamato <em>boot ROM</em>, masterizzato all’interno del silicio della CPU, viene “sovrapposto” alla nostra ROM!
La ROM di avvio è responsabile dell’animazione di avvio, ma controlla anche l’intestazione della ROM!
In particolare, verifica che i checksum del logo Nintendo e della intestazione siano corretti; se uno dei due controlli fallisce, la ROM di avvio si <em>blocca</em> intenzionalmente e il nostro gioco non verrà mai eseguito :(</p>
<div class="box tip"><p class="box-title">For the curious</p>
<p>È possibile trovare una descrizione più dettagliata di ciò che fa la ROM di avvio <a href="https://gbdev.io/pandocs/Power_Up_Sequence">nei Pan Docs</a>, nonché una spiegazione del controllo del logo.
Attenzione, però, perché si tratta di un argomento piuttosto avanzato.</p>
<p>If you want to enable the boot ROMs in Emulicious, you must obtain a copy of the boot ROM(s), whose SHA256 checksums can be found <a href="https://github.com/ISSOtm/gb-bootroms/blob/master/sha256sums.txt">in their disassembly</a> for verification.
If you wish, you can also compile <a href="https://github.com/LIJI32/SameBoy#compilation">SameBoy’s boot ROMs</a> and use those instead, as a free-software substitute.</p>
<p>Then, in Emulicious’ options, go to the <code>Options</code> tab, then <code>Emulation</code>→<code>Game Boy</code>, and choose which of GB and/or GBC boot roms you want to set.
Finally, set the path(s) to the boot ROM(s) you wish to use, and click <code>Open</code>.
Now, just reset the emulator, and voilà!</p>
</div>
<p>Un header viene tipicamente definito “valido” se supera i controlli della ROM di avvio e “non valido” in caso contrario.</p>
<h2 id="rgbfix-1"><a class="header" href="#rgbfix-1">RGBFIX</a></h2>
<p>RGBFIX è il terzo componente di RGBDS, il cui scopo è scrivere l’header di una ROM.
È separato da RGBLINK in modo da poter essere usato come strumento indipendente.
Il suo nome deriva dal fatto che RGBLINK di solito non produce una ROM con un header valido, quindi la ROM deve essere “aggiustata” prima di essere pronta per la produzione.</p>
<p>RGBFIX has <a href="https://rgbds.gbdev.io/docs/rgbfix.1">a bunch of options</a> to set various parts of the header; but the only two that we are using here are <code>-v</code>, which produces a <strong>v</strong>alid header (so, correct <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0104-0133---nintendo-logo">Nintendo logo</a> and <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#014d---header-checksum">checksums</a>), and <code>-p 0xFF</code>, which <strong>p</strong>ads the ROM to the next valid size (using $FF as the filler byte), and writes the appropriate value to the <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0148---rom-size">ROM size byte</a>.</p>
<p>Guardando altri progetti, si possono trovare invocazioni di RGBFIX con più opzioni, ma queste due dovrebbero essere quasi sempre presenti.</p>
<h2 id="allora-qual-è-il-problema-con-questa-linea"><a class="header" href="#allora-qual-è-il-problema-con-questa-linea">Allora, qual è il problema con questa linea?</a></h2>
<p>Si!
Questa linea.</p>
<pre><code class="language-rgbasm linenos start=7">	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>Vediamo cosa succede se la rimuoviamo (o la commentiamo).</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbasm -L -o hello-world.o hello-world.asm</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgblink -o hello-world.gb -n hello-world.sym hello-world.o</span>
</code></pre>
<p>(Sto intenzionalmente NON eseguendo RGBFIX; vedremo perché tra poco).</p>
<p><img src="part1/../assets/img/bad_warnings.png" alt="“Questa rom non funzionerebbe su un vero gameboy.”" /></p>
<p>Come ho spiegato, RGBFIX è responsabile della scrittura dell’intestazione, quindi dovremmo usarlo per risolvere questa eccezione.</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbfix -v -p 0xFF hello-world.gb</span>
warning: Overwrote a non-zero byte in the Nintendo logo
warning: Overwrote a non-zero byte in the header checksum
warning: Overwrote a non-zero byte in the global checksum
</code></pre>
<p><em>Sono sicuro che questi avvisi non sono nulla di cui preoccuparsi…</em>
(A seconda della versione di RGBDS in uso, è possibile che siano stati visualizzati avvisi diversi, o addirittura nessuno).</p>
<p>Let’s run the ROM, click on Console on the debugger’s bottom window, press <kbd><kbd>F5</kbd></kbd> a few times, and…</p>
<figure>
  <img src="part1/../assets/img/invalid_opcode.png" alt="Screenshot of Emulicious' debugger, PC won't advance past $0105">
  <figcaption>
    When the console reads "Executing illegal instruction", you <i>might</i> have screwed up somewhere.
  </figcaption>
</figure>
<p><img src="part1/../assets/img/fine.png" alt="“This is fine” meme" /></p>
<p>Ok, allora, cos’è successo?</p>
<p>Come si può vedere dallo screenshot, PC si trova a $0105.
Cosa sta facendo lì?</p>
<p>…Oh, <code>EntryPoint</code> è a $0103.
Quindi il <code>jp</code> a $0100 è andato lì e ha iniziato a eseguire le istruzioni (<code>3E CE</code> è la forma grezza di <code>ld a, $CE</code>), ma poi $ED non codifica alcuna istruzione valida, quindi la CPU si blocca.</p>
<p>Ma perché <code>EntryPoint</code> è lì?
Come avrete capito dagli avvisi stampati da RGBFIX, esso <em>sovrascrive</em> l’area dell’header nella ROM.
Tuttavia, RGBLINK <strong>non</strong> è a conoscenza dell’header (perché RGBLINK non è usato solo per generare ROM!), quindi è necessario riservare esplicitamente spazio per l’area dell’header.</p>
<div class="box danger decorated"><p>🥴</p>
<p>Dimenticare di riservare questo spazio può far sì che un pezzo di codice o di dati finisca lì e poi venga sovrascritto. Questo è un errore comune di chi è alle prime armi che può lasciare perplessi.
Fortunatamente, dalla versione 0.5.1 RGBFIX avverte quando rileva questo errore, come mostrato sopra.</p>
</div>
<p>Così, preveniamo disastri come questo:</p>
<pre><code class="language-rgbasm linenos start=3">SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>La direttiva <code>ds</code> sta per “define space” e consente di riempire un intervallo di memoria.
Questa riga specifica riempie tutti i byte da $103 a $14F (inclusi) con il valore $00.
Poiché parti diverse di codice e/o di dati non possono sovrapporsi, questo assicura che l’intervallo di memoria dell’header possa essere sovrascritto in modo sicuro da RGBFIX e che nessun altro venga accidentalmente sovrascritto.</p>
<p>Potrebbe non essere ovvio come questo <code>ds</code> finisca per riempire quello specifico intervallo di memoria.
Il <code>jp</code> a 3 byte copre gli indirizzi di memoria $100, $101 e $102.<br />
(Iniziamo da $100 perché è dove si trova la <code>SECTION</code> definita manualmente).<br />
Quando RGBASM elabora la direttiva <code>ds</code>, <code>@</code> (che è un simbolo speciale che valuta “l’indirizzo corrente”) ha quindi il valore $103, quindi riempie <code>$150 - $103 = $4D</code> byte con zeri, quindi $103, $104, …, $14E, $14F.</p>
<h2 id="bonus-il-ciclo-infinito"><a class="header" href="#bonus-il-ciclo-infinito">Bonus: il ciclo infinito</a></h2>
<p>(Questo non è propriamente collegato all’header, ma devo spiegarlo da qualche parte e questo è un posto come un altro)</p>
<p>Ci si potrebbe anche chiedere a cosa serva il ciclo infinito alla fine del codice.</p>
<pre><code class="language-rgbasm">Done:
	jp Done
</code></pre>
<p>Semplicemente, la CPU non smette mai di eseguire istruzioni; quindi, quando il nostro piccolo Hello World è finito e non c’è più nulla da fare, dobbiamo comunque dare alla CPU un po’ di lavoro: quindi, le facciamo fare nulla, per sempre.</p>
<p>Non possiamo lasciare che la CPU se ne vada, perché inizierebbe a eseguire altre parti della memoria come codice, con il rischio di bloccarsi.
(Per verificare: rimuovete o commentate queste due righe, compilate nuovamente la <a href="part1/hello_world.html">ROM</a> e vedete cosa succede)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operazioni-e-flag"><a class="header" href="#operazioni-e-flag">Operazioni e flag</a></h1>
<p>Va bene, sappiamo come passare i valori, ma copiare semplicemente i numeri non è divertente; vogliamo modificarli!</p>
<p>La CPU GB non fornisce tutte le operazioni sotto il sole (per esempio, non esiste un’istruzione di moltiplicazione), ma possiamo programmarle da soli con ciò che abbiamo.
Parliamo di alcune delle operazioni di cui dispone; per ora ne ometterò alcune non utilizzate in Hello World.</p>
<h2 id="aritmetica"><a class="header" href="#aritmetica">Aritmetica</a></h2>
<p>Le istruzioni aritmetiche più semplici supportate dalla CPU sono <code>inc</code> e <code>dec</code>, che rispettivamente INCrementano e DECrementano il loro operando.
(Se non siete sicuri, “incrementare” significa “aggiungere 1” e “decrementare” significa “sottrarre 1”).
Quindi, per esempio, il <code>dec bc</code> alla riga 32 di <code>hello-world.asm</code> sottrae semplicemente 1 da <code>bc</code>.</p>
<p>Ok, bene!
Possiamo però andare un po’ più veloci?
Certo che sì, con <code>add</code> e <code>sub</code>!
Questi rispettivamente aggiungono e sottraggono valori arbitrari (una costante o un registro).
Nessuno dei due viene usato nel tutorial, ma c’è un parente di <code>sub</code>: avete notato il piccolo <code>cp</code> alla riga 17?
<code>cp</code> permette di confrontare i valori.
Funziona come <code>sub</code>, ma scarta il risultato invece di riscriverlo.
“Aspettate, quindi non fa nulla?”, vi chiederete; beh, aggiorna le <strong>flag</strong>.</p>
<h2 id="flag"><a class="header" href="#flag">Flag</a></h2>
<p>È arrivato il momento di parlare del registro speciale (ve lo ricordate?) <code>f</code>, per, beh, <em>flag</em>.
Il registro <code>f</code> contiene 4 bit, chiamati “flag”, che vengono aggiornati a seconda dei risultati di un’operazione.
Questi 4 flag sono:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>Z</td><td>Zero flag</td></tr>
<tr><td>N</td><td>Addition/subtraction</td></tr>
<tr><td>H</td><td>Half-carry</td></tr>
<tr><td>C</td><td>Carry</td></tr>
</tbody></table>
</div>
<p>Sì, esistono sia un flag chiamato “C” che un registro chiamato “c” e <strong>sono cose diverse e non correlate</strong>.
Questo rende la sintassi un po’ confusa all’inizio, ma vengono sempre usati in contesti diversi, quindi basta farci caso.</p>
<p>Per ora dimentichiamo N e H; concentriamoci su Z e C.
Z è il flag più semplice: viene impostato quando il risultato di un’operazione è 0 e viene azzerato altrimenti.
C viene impostato quando un’operazione va in <em>overflow</em> o in <em>underflow</em>.</p>
<p>Che cos’è un overflow?
Prendiamo la semplice istruzione <code>add a, 42</code>.
Questa istruzione aggiunge semplicemente 42 al contenuto del registro <code>a</code> e scrive il risultato in <code>a</code>.</p>
<pre><code class="language-rgbasm">    ld a, 200
    add a, 42
</code></pre>
<p>Alla fine di questo snippet, <code>a</code> è uguale a 200 + 42 = 242, fantastico!
Ma se invece scrivessi questo?</p>
<pre><code class="language-rgbasm">    ld a, 220
    add a, 42
</code></pre>
<p>Si potrebbe pensare che <code>a</code> sia uguale a 220 + 42 = 262, ma non sarebbe corretto.
Ricordate che <code>a</code> è un registro a 8 bit, <em>può memorizzare solo otto bit di informazione</em>!
E se dovessimo scrivere 262 in binario, otterremmo %100000110, che richiede almeno 9 bit…
Quindi cosa succede?
Semplicemente, il nono bit viene <em>perduto</em> e il valore che otteniamo è %00000110 = 6. Questo si chiama <em>overflow</em>.
Questo si chiama <em>overflow</em>: dopo l’<strong>aggiunta</strong>, otteniamo un valore <strong>più piccolo</strong> di quello con cui abbiamo iniziato.</p>
<p>We can also do the opposite with <code>sub</code>, and—for example—subtract 42 from 6; as we know, for all <code>X</code> and <code>Y</code>, <code>X + Y - Y = X</code>, and we just saw that 220 + 42 = 6 (this is called <em>modulo 256 arithmetic</em>, by the way); so, 6 - 42 = (220 + 42) - 42 = 220.
This is called an <em>underflow</em>: after <strong>subtracting</strong>, we get a value <strong>greater</strong> than what we started with.</p>
<p>Quando viene eseguita un’operazione, imposta il flag di riporto se si è verificato un overflow o un underflow, altrimenti lo azzera.
(Vedremo più avanti che non tutte le operazioni aggiornano il flag di riporto)</p>
<div class="box tip"><p class="box-title">Summary</p>
<ul>
<li>We can add and subtract numbers.</li>
<li>The Z flag lets us know if the result was 0.</li>
<li>However, registers can only store a limited range of integers.</li>
<li>Going outside this range is called an <strong>overflow</strong> or <strong>underflow</strong>, for addition and subtraction respectively.</li>
<li>The C flag lets us know if either occurred.</li>
</ul>
</div>
<h2 id="confronto"><a class="header" href="#confronto">Confronto</a></h2>
<p>Parliamo ora di come <code>cp</code> viene utilizzato per confrontare i numeri.
Ecco un ripasso: <code>cp</code> sottrae il suo operando da <code>a</code> e aggiorna i flag di conseguenza, ma non scrive il risultato.
Possiamo usare i flag per controllare le proprietà dei valori confrontati e vedremo nella prossima lezione come usarli.</p>
<p>L’interazione più semplice è quella con il flag Z.
Se è impostato, sappiamo che la sottrazione ha prodotto 0, cioè <code>a - operando == 0</code>; quindi, <code>a == operando</code>!
Se non è impostato, allora sappiamo che <code>a != operando</code>.</p>
<p>Ok, controllare l’uguaglianza è bello, ma potremmo anche voler eseguire dei <em>confronti</em>.
Non preoccupatevi, perché il flag di riporto serve proprio a questo!
Quando si esegue una sottrazione, il flag di riporto viene impostato quando il risultato scende sotto lo 0, ma è solo un modo elegante per dire “diventa negativo”!</p>
<p>Quindi, quando il flag di riporto viene impostato, sappiamo che <code>a - operando &lt; 0</code> e di conseguenza che <code>a &lt; operando</code>…!
E, al contrario, sappiamo che se non è impostato, <code>a &gt;= operando</code>.
Ottimo!</p>
<h2 id="riassunto-dellistruzione"><a class="header" href="#riassunto-dellistruzione">Riassunto dell’istruzione</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Instruction</th><th>Mnemonic</th><th>Effect</th></tr></thead><tbody>
<tr><td>Add</td><td><code>add</code></td><td>Adds values to <code>a</code></td></tr>
<tr><td>Subtract</td><td><code>sub</code></td><td>Subtracts values from <code>a</code></td></tr>
<tr><td>Compare</td><td><code>cp</code></td><td>Compares values with what’s contained in <code>a</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="jumps"><a class="header" href="#jumps">Jumps</a></h1>
<div class="box tip">
<p>Una volta terminata questa lezione, saremo in grado di capire tutto di <code>CopyTiles</code>!</p>
</div>
<p>Finora tutto il codice che abbiamo visto era lineare: veniva eseguito dall’alto verso il basso.
Ma questo non è sufficiente: a volte è necessario eseguire alcune azioni in base al risultato di altre (“se le crêpes iniziano ad attaccarsi, ungi di nuovo la padella”), e a volte è necessario eseguire azioni ripetutamente (“se è rimasta della pastella, ripeti dal passo 5”).</p>
<p>Entrambe le cose implicano una lettura non lineare della ricetta.
In assembly, questo si ottiene con i <em>salti</em>.</p>
<p>La CPU dispone di un registro speciale chiamato “PC”, che sta per Program Counter.
Esso contiene l’indirizzo dell’istruzione in corso di esecuzione<sup class="footnote-reference"><a href="#pc_updates">1</a></sup>, come se si tenesse a mente il numero del passo della ricetta che si sta eseguendo.
Il PC aumenta automaticamente quando la CPU legge le istruzioni, quindi “per impostazione predefinita” vengono lette in sequenza; tuttavia, le istruzioni di salto consentono di scrivere un valore diverso nel PC, saltando di fatto a un’altra parte del programma.
Da qui il nome.</p>
<p>Ok, allora parliamo di queste istruzioni di salto, che ne dite?
Ce ne sono quattro:</p>
<div class="table-wrapper"><table><thead><tr><th>Instruction</th><th>Mnemonic</th><th>Effect</th></tr></thead><tbody>
<tr><td>Jump</td><td><code>jp</code></td><td>Jump execution to a location</td></tr>
<tr><td>Jump Relative</td><td><code>jr</code></td><td>Jump to a location close by</td></tr>
<tr><td>Call</td><td><code>call</code></td><td>Call a subroutine</td></tr>
<tr><td>Return</td><td><code>ret</code></td><td>Return from a subroutine</td></tr>
</tbody></table>
</div>
<p>Per ora ci concentreremo su <code>jp</code>.
<code>jp</code>, come quello della riga 5, imposta semplicemente PC al suo argomento, saltando l’esecuzione a quel punto.
In altre parole, dopo l’esecuzione di <code>jp EntryPoint</code> (riga 5), l’istruzione successiva eseguita è quella sotto <code>EntryPoint</code> (riga <!-- should be 9 + 1 --> 16).</p>
<div class="box tip decorated"><p>🤔</p>
<p>Ci si potrebbe chiedere a cosa serva questo specifico <code>jp</code>.
Non preoccupatevi, vedremo più avanti perché è necessario.</p>
</div>
<h2 id="salti-condizionati"><a class="header" href="#salti-condizionati">Salti condizionati</a></h2>
<p>Passiamo ora alla parte <em>davvero</em> interessante.
Esaminiamo il ciclo responsabile della copia delle tile:</p>
<pre><code class="language-rgbasm linenos start=24">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
CopyTiles:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTiles
</code></pre>
<div class="box tip">
<p>Non preoccupatevi se non capite bene quanto segue, perché lo vedremo in azione nella prossima lezione.
Se avete problemi, provate ad andare alla prossima lezione e guardate il codice eseguito passo per passo; poi, tornando a questo punto, dovrebbe avere tutto più senso.</p>
</div>
<p>Per prima cosa, copiamo <code>Tiles</code>, l’indirizzo del primo byte dei dati delle tile, in <code>de</code>.
Poi, impostiamo <code>hl</code> a $9000, che è l’indirizzo in cui inizieremo a copiare i dati delle tile.
<code>ld bc, TilesEnd - Tiles</code> imposta <code>bc</code> sulla lunghezza dei dati delle tile: <code>TilesEnd</code> è l’indirizzo del primo byte <em>dopo</em> i dati delle tile, quindi sottraendogli <code>Tiles</code> si ottiene la lunghezza.</p>
<p>Quindi, in pratica:</p>
<ul>
<li><code>de</code> contains the address where data will be copied from;</li>
<li><code>hl</code> contains the address where data will be copied to;</li>
<li><code>bc</code> contains how many bytes we have to copy.</li>
</ul>
<p>Arriviamo quindi al ciclo principale.
Leggiamo un byte dalla sorgente (riga 29) e lo scriviamo nella destinazione (riga 30).
Incrementiamo i puntatori alla destinazione (tramite l’implicito <code>inc hl</code> fatto da <code>ld [hli], a</code>) e alla sorgente (riga 31), in modo che la successiva iterazione del ciclo elabori il byte successivo.</p>
<p>Ecco la parte interessante: poiché abbiamo appena copiato un byte, significa che ne abbiamo uno in meno, quindi dobbiamo fare <code>dec bc</code>.
(Abbiamo già visto <code>dec</code> due lezioni fa; per rinfrescare la memoria, si tratta semplicemente di diminuire di uno il valore memorizzato in <code>bc</code>).
Poiché <code>bc</code> contiene la quantità di byte che devono ancora essere copiati, è facile capire che dobbiamo semplicemente ripetere l’operazione se <code>bc</code> != 0.</p>
<div class="box danger decorated"><p>😓</p>
<p><code>dec</code> di solito aggiorna i flag, ma sfortunatamente <code>dec bc</code> non lo fa, quindi dobbiamo controllare manualmente se <code>bc</code> ha raggiunto 0.</p>
</div>
<p><code>ld a, b</code> e <code>or a, c</code> applicano “bitwise OR” a <code>b</code> e <code>c</code> insieme; per ora è sufficiente sapere che lascia 0 in <code>a</code> se e solo se <code>bc</code> == 0.
E <code>or</code> aggiorna il flag Z!
Quindi, dopo la riga 34, il flag Z è impostato se e solo se <code>bc</code> == 0, cioè se dobbiamo uscire dal ciclo.</p>
<p>Ed è qui che entrano in gioco i salti condizionati!
È possibile “prendere” <strong>condizionatamente</strong> un salto a seconda dello stato dei flag.</p>
<p>Le “condizioni” sono quattro:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Mnemonic</th><th>Description</th></tr></thead><tbody>
<tr><td>Zero</td><td><code>z</code></td><td>Z is set (last operation had a result of 0)</td></tr>
<tr><td>Non-zero</td><td><code>nz</code></td><td>Z is not set (last operation had a non-zero result)</td></tr>
<tr><td>Carry</td><td><code>c</code></td><td>C is set (last operation overflowed)</td></tr>
<tr><td>No carry</td><td><code>nc</code></td><td>C is not set (last operation did not overflow)</td></tr>
</tbody></table>
</div>
<p>Quindi, <code>jp nz, CopyTiles</code> può essere letto come “se il flag Z non è impostato, allora salta a <code>CopyTiles</code>”.
Poiché stiamo saltando <em>all’indietro</em>, ripeteremo di nuovo le istruzioni: abbiamo appena creato un <strong>ciclo</strong>!</p>
<p>Ok, abbiamo parlato molto del codice e lo abbiamo visto girare, ma non abbiamo visto <em>come</em> gira.
Guardiamo la magia che si svolge al rallentatore nella prossima lezione!</p>
<hr />
<div class="footnote-definition" id="pc_updates"><sup class="footnote-definition-label">1</sup>
<p>Not exactly; instructions may be several bytes long, and PC increments after reading each byte.
Notably, this means that when an instruction finishes executing, PC is pointing to the following instruction.
Still, it’s pretty much “where the CPU is currently reading from”, but it’s better to keep it simple and avoid mentioning instruction encoding for now.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracciamento"><a class="header" href="#tracciamento">Tracciamento</a></h1>
<p>Avete mai sognato di essere dei maghi?
Beh, questo non vi darà poteri magici, ma vediamo come gli emulatori possono essere usati per controllare il tempo!</p>
<p>Per prima cosa, assicuratevi di mettere a fuoco la finestra del debugger.
Spieghiamo innanzitutto il layout del debugger:
<img src="part1/../assets/img/debugger.png" alt="" />
In alto a sinistra c’è il visualizzatore del codice, in basso a sinistra c’è il visualizzatore dei dati, in alto a destra ci sono alcuni registri (come abbiamo visto nella <a href="part1/registers.html">lezione sui registri</a>) e in basso a destra c’è il visualizzatore dello stack.
Che cos’è lo stack?
Risponderemo a questa domanda un po’ più avanti… nella Parte Ⅱ 😅</p>
<h2 id="preparazione-1"><a class="header" href="#preparazione-1">Preparazione</a></h2>
<p>For now, let’s focus on the code viewer.</p>
<p>As Emulicious can load our source code, our code’s labels and comments are automatically shown in the debugger.
As we have seen a couple of lessons ago, labels are merely a convenience provided by RGBASM, but they are not part of the ROM itself.
In other emulators, it is very much inconvenient to debug without them, and so sym files (for “<strong>sym</strong>bols”) have been developed.
Let’s run RGBLINK to generate a sym file for our ROM:</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgblink -n hello-world.sym hello-world.o</span>
</code></pre>
<div class="box warning decorated"><p>‼️</p>
<p>The file names matter!
When looking for a ROM’s sym file, emulators take the ROM’s file name, strip the extension (here, <code>.gb</code>), replace it with <code>.sym</code>, and look for a file <strong>in the same directory</strong> with that name.</p>
</div>
<h2 id="passo"><a class="header" href="#passo">Passo</a></h2>
<p>Quando si mette in pausa l’esecuzione, il debugger si concentra automaticamente sull’istruzione che la CPU sta per eseguire, come indicato dalla riga evidenziata in blu.
<img src="part1/../assets/img/pc.png" alt="Schermata del debugger che mostra che la riga evidenziata corrisponde a PC" /></p>
<div class="box tip decorated"><p>ℹ️</p>
<p>The instruction highlighted in blue is always what the CPU is <em>about to execute</em>, not what it <em>just executed</em>. Keep this in mind.</p>
</div>
<p>If we want to watch execution from the beginning, we need to reset the emulator.
Go into the emulator’s “File” menu, and select “Reset”, or press <kbd><kbd>Ctrl</kbd>+<kbd>Backspace</kbd></kbd>.</p>
<p>La linea blu dovrebbe spostarsi automaticamente all’indirizzo $0100<sup class="footnote-reference"><a href="#boot_addr">1</a></sup> e ora siamo pronti a tracciare!
Tutti i comandi per farlo si trovano nel menu “Esegui”.</p>
<ul>
<li>“Resume” simply unpauses the emulator.</li>
<li>“Step Into” and “Step Over” advance the emulator by one instruction.
They only really differ on the <code>call</code> instruction, interrupts, and when encountering a conditional jump, neither of which we are using here, so we will use “Step Into”.</li>
<li>The other options are not relevant for now.</li>
</ul>
<p>We will have to “Step Into” a bunch of times, so it’s a good idea to use the key shortcut.
If we press <kbd><kbd>F5</kbd></kbd> once, the <code>jp EntryPoint</code> is executed.
And if we press it a few more times, can see the instructions being executed, one by one!</p>
<video controls poster="../assets/vid/reset_trace.poster.png">
  <source src="../assets/vid/reset_trace.webm" type="video/webm">
  <source src="../assets/vid/reset_trace.mp4" type="video/mp4">
<img src="part1/../assets/vid/reset_trace.gif" alt="Video demonstration in Emulicious">
</video>
<p>Now, you may notice the <code>WaitVBlank</code> loop runs a <em>lot</em> of times, but what we are interested in is the <code>CopyTiles</code> loop.
We can easily skip over it in several ways; this time, we will use a <em>breakpoint</em>.
We will place the breakpoint on the <code>ld de, Tiles</code> at <code>00:0162</code>; either double-click on that line, or select it and press <kbd><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>B</kbd></kbd>.</p>
<p><img src="part1/../assets/img/breakpoint.png" alt="Schermata del debugger che mostra il punto di interruzione" /></p>
<p>Then you can resume execution by pressing <kbd><kbd>F8</kbd></kbd>.
Whenever Emulicious is running, and the (emulated) CPU is about to execute an instruction a breakpoint was placed on, it automatically pauses.</p>
<p><img src="part1/../assets/img/bkpt_pause.png" alt="Schermata del debugger che mostra l’esecuzione in pausa sul punto di interruzione" /></p>
<p>La freccia verde e il valore di PC indicano il punto in cui l’esecuzione è in pausa.</p>
<p>Se tracciamo le tre istruzioni successive, possiamo vedere che i tre argomenti del ciclo <code>CopyTiles</code> vengono caricati nei registri.</p>
<p><img src="part1/../assets/img/regs_copytiles.png" alt="Lo stato di alcuni registri all’inizio del ciclo CopyTiles" /></p>
<p>For fun, let’s watch the tiles as they’re being copied.
For that, obviously, we will use the Memory Editor, and position it at the destination.
As we can see from the image above, that would be $9000!</p>
<p>Click on “Memory” on the bottom window, then “VRAM”, and press <kbd><kbd>Ctrl</kbd>+<kbd>G</kbd></kbd> (for “Goto”).</p>
<video controls poster="../assets/vid/trace_copy.poster.png">
  <source src="../assets/vid/trace_copy.webm" type="video/webm">
  <source src="../assets/vid/trace_copy.mp4" type="video/mp4">
<img src="part1/../assets/vid/trace_copy.gif" alt="Video demonstration in Emulicious">
</video>
<p>Fantastico, vero?</p>
<h2 id="e-poi"><a class="header" href="#e-poi">E poi?</a></h2>
<p>Congrats, you have just learned how to use a debugger!
We have only scratched the surface, though; we will use more of Emulicious’ tools to illustrate the next parts.
Don’t worry, from here on, lessons will go with a lot more images—you’ve made it through the hardest part!</p>
<hr />
<div class="footnote-definition" id="boot_addr"><sup class="footnote-definition-label">1</sup>
<p>Why does execution start at $0100?
That’s because it’s where the <a href="https://gbdev.io/pandocs/Power_Up_Sequence">boot ROM</a> hands off control to our game once it’s done.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tile"><a class="header" href="#tile">Tile</a></h1>
<div class="box tip decorated"><p>💭</p>
<p>Le “tile” venivano chiamate in modo diverso nella documentazione di un tempo.
Di solito venivano chiamate “schemi” o “caratteri” e quest’ultima ha dato origine all’abbreviazione “CHR”, che a volte viene usata per riferirsi alle tile.</p>
<p>Ad esempio, sul NES, i dati dei tile sono solitamente forniti dalla cartuccia in <a href="http://wiki.nesdev.com/w/index.php/CHR_ROM_vs._CHR_RAM">CHR ROM o CHR RAM</a>.
Il termine “CHR” non è tipicamente utilizzato sul Game Boy, anche se gli scambi tra le comunità fanno sì che i termini “trapelino”, per cui alcuni si riferiscono all’area della VRAM in cui sono memorizzati i tile come “CHR RAM” o “CHR VRAM”, ad esempio.</p>
<p>Come per tutti i gerghi di questo tipo, il cui significato può dipendere dall’interlocutore, per coerenza mi atterrò a “tile” in tutto il tutorial, essendo ormai lo standard più diffuso nella comunità degli sviluppatori di GB.</p>
</div>
<p>Copiare questi dati alla cieca va benissimo, ma perché i dati sono “grafici”?</p>
<figure>
  <img src="part1/../assets/img/ah_yes_pixels.png" alt="Screenshot of some tile definitions in the code">
  <figcaption><q>Ah, sì, i pixel.</q></figcaption>
</figure>
<p>Vediamo un po’!</p>
<h2 id="un-aiuto"><a class="header" href="#un-aiuto">Un Aiuto</a></h2>
<p>Now, figuring out the format with an explanation alone is going to be very confusing; but fortunately, Emulicious got us covered thanks to its <em>Tile Viewer</em>.
You can open it either by selecting “Tools” then “Tile Viewer”, or by clicking on the grid of colored tiles in the debugger’s toolbar.</p>
<p><img src="part1/../assets/img/vram_viewer.png" alt="Schermata del Tile Viewer" /></p>
<p>You can combine the various VRAM viewers by going to “View”, then “Combine Video Viewers”.
We will come to the other viewers in due time.
This one shows the tiles present in the Game Boy’s video memory (or “<abbr title="Video RAM">VRAM</abbr>”).</p>
<div class="box tip decorated"><p>🤔</p>
<p>Vi invito a sperimentare con il visualizzatore di VRAM, a passare il mouse sulle cose, a spuntare e deselezionare le caselle di controllo, a scoprire da soli cosa è cosa. Tutte le domande che vi porrete troveranno risposta a tempo debito, non preoccupatevi! E se quello che vedete in seguito non corrisponde alle mie schermate, assicuratevi di avere le mie stesse caselle spuntate.</p>
</div>
<p>Don’t mind the “®” icon in the top-left; we did not put it there ourselves, and we will see why it’s there later.</p>
<h2 id="primer-breve"><a class="header" href="#primer-breve">Primer breve</a></h2>
<p>Potreste aver già sentito parlare di tiles, soprattutto perché erano molto popolari nei sistemi a 8 e 16 bit.
Non è una coincidenza: le tile sono molto utili.
Invece di memorizzare ogni pixel sullo schermo (144 × 160 pixel × 2 bit/pixel = 46080 bit = 5760 byte, rispetto agli 8192 byte di VRAM della console), i pixel vengono raggruppati in tile, che vengono poi assemblate in vari modi per produrre l’immagine finale.</p>
<p>In particolare, le tile possono essere riutilizzate molto facilmente e praticamente a costo zero, risparmiando molta memoria!
Inoltre, la manipolazione di intere tile in una sola volta è molto più economica rispetto alla manipolazione dei singoli pixel e questo fa risparmiare tempo di elaborazione.</p>
<p>Il concetto di “tile” è molto generico, ma sul Game Boy le tile sono <em>sempre</em> di 8 per 8 pixel.
Spesso le tile hardware vengono raggruppate per essere manipolate come tile più grandi (spesso 16×16); per evitare la confusione, queste vengono chiamate <strong>meta-tile</strong>.</p>
<h3 id="bpp"><a class="header" href="#bpp">“bpp”?</a></h3>
<p>Vi starete chiedendo da dove provenga la cifra di “2 bit/pixel” di cui sopra…
Si tratta della cosiddetta “profondità di bit”.</p>
<p>I colori non sono memorizzati nelle tile stesse!
Invece, funziona come un libro da colorare: la tile in sé contiene <em>indici</em> di 8 x 8, non colori; si dà all’hardware una tile e un insieme di colori - una <strong>tavolozza</strong> - e lui li colora!
(Questo è anche il motivo per cui le varianti di colore erano molto comuni all’epoca: si potevano creare diverse versioni di un nemico memorizzando piccole tavolozze invece di grandi grafiche diverse.)</p>
<p>In ogni caso, le tavolozze del Game Boy sono grandi 4 colori.<sup class="footnote-reference"><a href="#pal_size">1</a></sup>
Ciò significa che gli indici di tali tavolozze, memorizzati nelle tile, possono essere rappresentati con solo <em>due bit</em>!
Questo si definisce “2 bit per pixel”, noto come “2bpp”.</p>
<p>Con queste premesse, siamo pronti a spiegare come questi byte si trasformano in pixel!</p>
<h2 id="codifica"><a class="header" href="#codifica">Codifica</a></h2>
<p>Come ho spiegato, ogni pixel occupa 2 bit.
Poiché ci sono 8 bit in un byte, ci si potrebbe aspettare che ogni byte contenga 4 pixel… e non sarebbe né del tutto giusto né del tutto sbagliato.
Ogni riga di 8 pixel è memorizzata in 2 byte, ma nessuno di questi byte contiene le informazioni per 4 pixel.
(Pensate a una banconota da 10 € strappata a metà: nessuna delle due metà ha valore, ma la banconota intera vale, beh, 10 €).</p>
<p>Per ogni pixel, il bit meno significativo del suo indice è memorizzato nel primo byte, mentre il bit più significativo è memorizzato nel secondo byte.
Poiché ogni byte è una raccolta di uno dei bit di ciascun pixel, questo insieme viene chiamato <strong>bitplane</strong>.</p>
<p>Il pixel più a sinistra è memorizzato nel primo bit da sinistra di entrambi i byte, il pixel alla sua destra nel secondo bit da sinistra e così via.
La prima coppia di byte memorizza la riga superiore, il secondo byte quella inferiore e così via.</p>
<p>Ecco una dimostrazione più visiva:</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/txkHN6izK2Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Questa codifica può sembrare un po’ strana all’inizio, e può esserlo; è fatta per essere più conveniente per l’hardware da decodificare, mantenendo la circuiteria semplice e a basso consumo.
Rende possibili anche alcuni trucchi interessanti, come vedremo (molto) più avanti!</p>
<p>Si possono trovare ulteriori informazioni sulla codifica <a href="https://gbdev.io/pandocs/Tile_Data.html">nei Pan Docs</a> e <a href="https://www.huderlem.com/demos/gameboy2bpp.html">nel sito di ShantyTown</a>.</p>
<p>Nella prossima lezione vedremo come si applicano i colori!</p>
<hr />
<div class="footnote-definition" id="pal_size"><sup class="footnote-definition-label">1</sup>
<p>Other consoles can have varying bit depths; for example, the SNES has 2bpp, 4bpp, and 8bpp depending on the graphics mode and a few other parameters.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tavolozze"><a class="header" href="#tavolozze">Tavolozze</a></h1>
<p>In the previous lesson, I briefly mentioned that colors are applied to tiles via <em>palettes</em>, but we haven’t talked much about those yet.</p>
<p>Il Game Boy in bianco e nero ha tre tavolozze, una per lo sfondo chiamata <a href="https://gbdev.io/pandocs/Palettes.html#ff47---bgp-bg-palette-data-rw---non-cgb-mode-only"><code>BGP</code></a> (“BackGround Palette”) e due per gli oggetti chiamate <a href="https://gbdev.io/pandocs/Palettes.html#ff48---obp0-object-palette-0-data-rw---non-cgb-mode-only"><code>OBP0</code></a> e <a href="https://gbdev.io/pandocs/Palettes.html#ff48---obp1-object-palette-1-data-rw---non-cgb-mode-only"><code>OBP1</code></a> (“OBject Palette 0/1”).
Se vi state chiedendo cosa siano gli “oggetti”, dovrete aspettare la Parte Ⅱ per scoprirlo; per ora, concentriamoci sullo sfondo.</p>
<div class="box tip decorated"><p>🌈</p>
<p>Il Game Boy Color ha introdotto, ovviamente, i colori e questo è stato fatto principalmente rielaborando il modo in cui vengono gestite le tavolozze.
Non parleremo delle caratteristiche del Game Boy Color nella Parte Ⅰ per semplicità, ma lo faremo nelle parti successive.</p>
</div>
<p>If you chose to combine the video viewers in the previous chapter, the palette viewer should show up on the bottom right of the video viewer.
Otherwise, please select Emulicious’ “Tools” tab, then select <code>Palette Viewer</code>.</p>
<p><img src="part1/../assets/img/pal_viewer.png" alt="Schermata della scheda Palette del visualizzatore VRAM" /></p>
<p>Daremo un’occhiata alla linea “BGP”.
Come ho spiegato in precedenza, le tile memorizzano gli “indici di colore” per ciascun pixel, i quali vengono utilizzati per indicizzare la tavolozza.
Il colore numero 0<sup class="footnote-reference"><a href="#numbering_zero">1</a></sup> è quello più a sinistra in questa riga e il numero 3 è quello più a destra.</p>
<p>Quindi, nel nostro caso, il colore numero 0 è “bianco”, il numero 1 è “grigio chiaro”, il numero 2 è “grigio scuro” e il numero 3 è “nero”.
Ho messo le virgolette perché “nero” non è nero puro e “bianco” non è bianco puro.
Inoltre, notate che il Game Boy originale aveva sfumature di verde, mentre lo schermo del successivo Game Boy Pocket produceva sfumature di grigio.
E, meglio ancora, il Game Boy Color è in grado di colorare automaticamente i giochi che non supportano il Game Boy Color!</p>
<p><img src="part1/../assets/img/hello_world_autocolor.png" alt="Schermata del nostro Hello World, colorato automaticamente dal Game Boy Color" /></p>
<p>Tutto questo per dire che non ci si deve aspettare colori specifici da un gioco per Game Boy<sup class="footnote-reference"><a href="#console_detection">2</a></sup>, ma solo quattro colori più o meno luminosi.</p>
<h2 id="sporchiamoci-le-mani"><a class="header" href="#sporchiamoci-le-mani">Sporchiamoci le mani</a></h2>
<p>In questo tutorial, finora, a parte l’esecuzione di Hello World siamo stati piuttosto passivi, osservando il suo svolgimento.
Che ne dite se iniziamo a smuovere un po’ la ROM?</p>
<p>In Emulicious’ debugger, select the “Variables” tab on the left to show the IO registers.</p>
<p><img src="part1/../assets/img/io_map.png" alt="Schermata della IO map" /></p>
<p>While the VRAM viewer offers a visual representation of the palette, the IO map shows the nitty-gritty: how it’s encoded.
The IO map also lets us modify BGP easily; but to do so, we need to understand <em>how</em> values we write are turned into colors.</p>
<h3 id="codifica-1"><a class="header" href="#codifica-1">Codifica</a></h3>
<p>Fortunatamente, la codifica è molto semplice.
La spiegherò e allo stesso tempo fornirò un esempio con la tavolozza che abbiamo a portata di mano, $E4.</p>
<p>Take the byte, break its 8 bits into 4 groups of 2.</p>
<pre><code>[BGP] = $E4
$E4 = %11100100 (refresh your memory in the &quot;Binary and hexadecimal&quot; lesson if needed!)
That gets broken down into %11, %10, %01, %00
</code></pre>
<p>Il colore numero 0 è il “gruppo” più a destra, il colore numero 3 è quello più a sinistra.
Semplice!
E questo corrisponde a ciò che ci mostra il visualizzatore VRAM: il colore numero 0, quello più a destra, è quello più chiaro (%00), fino al colore numero 3, che è quello più a sinistra e il più scuro (%11).</p>
<h3 id="luci-spente"><a class="header" href="#luci-spente">Luci spente</a></h3>
<p>Per divertimento, rendiamo lo schermo completamente nero.
Lo si può fare facilmente impostando tutti i colori della tavolozza sul nero (%11).
Questo si traduce in <code>%11 %11 %11 %11 = $FF</code>.</p>
<p>In the “Variables” tab in the debugger, click on the byte to the right of BGP, erase the “E4”, type “FF”, and hit Enter.
BGP immediately updates, turning the screen black!</p>
<figure>
	<img src="part1/../assets/img/pal_viewer_black.png" alt="Screenshot of the palette viewer with the BGP line entirely black">
	<figcaption>Osservate come la linea BGP sia ora completamente nera. Inoltre, avrei potuto mostrare un'immagine della schermata nera, ma sarebbe stato stupido.</figcaption>
</figure>
<p>E se volessimo prendere la tavolozza originale, ma invertirla?
%11 diventerebbe %00, %01 diventerebbe %10, %10 diventerebbe %01 e %00 diventerebbe %11.
Otterremmo così:</p>
<pre><code>%11_10_01_00
 ↓  ↓  ↓  ↓
%00_01_10_11
</code></pre>
<p>(Non fornirò il valore in esadecimale, usate questa opportunità per esercitare le vostre conversioni da bin a esadecimale!)</p>
<figure>
	<img src="part1/../assets/img/hello_world_inv.png" alt="Screenshot of the color-inverted Hello World">
	<figcaption>Se avete fatto bene, dovrebbe apparire così!</figcaption>
</figure>
<p>If you go to the Tile Viewer and change “Palette” to “Gray”, you will notice that the tile data stays the same regardless of how the palette is modified!
This is an advantage of using palettes: fading the screen in and out is very cheap, just modifying a single byte, instead of having to update every single on-screen pixel.</p>
<p>Avete capito tutto?
Allora diamo un’occhiata all’ultimo pezzo mancante del puzzle nel processo di rendering di Hello World, la <strong>tilemap</strong>!</p>
<hr />
<div class="footnote-definition" id="numbering_zero"><sup class="footnote-definition-label">1</sup>
<p>Numbering often starts at 0 when working with computers.
We will understand why later, but for now, please bear with it!</p>
</div>
<div class="footnote-definition" id="console_detection"><sup class="footnote-definition-label">2</sup>
<p>Well, it is possible to detect these different models and account for them, but this would require taking plenty of corner cases into consideration, so it’s probably not worth the effort.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tilemap"><a class="header" href="#tilemap">Tilemap</a></h1>
<div class="box tip decorated"><p>🧐</p>
<p>Alcuni li chiamano “tile map”, altri “tilemap”.
Io userò quest’ultimo di preferenza, ma lo userò anche nel codice (<code>Tilemap</code> e non <code>TileMap</code>), così come più avanti quando parleremo di mappe di attributi (“attrmap” e <code>Attrmap</code> invece di <code>AttrMap</code>).</p>
</div>
<p>Ci siamo quasi.
Abbiamo visto come la grafica del Game Boy sia composta da “tessere” 8×8 e come il colore venga aggiunto al mix.</p>
<p>Ma non abbiamo ancora visto come queste tessere vengono disposte in un’immagine finale!</p>
<p>Tiles are basically a grid of pixels; well, the tilemaps are basically a grid of tiles!
To allow for cheap reuse, tiles aren’t stored in the tilemap directly; instead, tiles are referred to by an <em>ID</em>, which you can see in Emulicious’ Tile Viewer.</p>
<figure>
  <img src="part1/../assets/img/tile_id.png" alt="Screenshot highlighting where a tile's ID can be seen">
  <figcaption>
    L'ID è visualizzato in esadecimale senza prefisso, quindi questa è la tessera numero 10$, ovvero 16.
    Come avrete notato, le tessere sono visualizzate in file da 16, così è più facile individuarle in base all'ID esadecimale.
    Fantastico!
  </figcaption>
</figure>
<p>Naturalmente gli ID delle tessere sono numeri, come tutti i computer.
Gli ID sono memorizzati in byte, quindi ci sono 256 possibili ID di piastrelle.
Tuttavia, il lettore più attento avrà notato che ci sono 384 tessere in totale<sup class="footnote-reference"><a href="#blocchi_di_tile">1</a></sup>!
In virtù del <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">principio della piccionaia</a>, ciò significa che alcuni ID si riferiscono a più piastrelle contemporaneamente.</p>
<p>Indeed, Emulicious reports that the first 128 tiles have the same IDs as the last 128.
There exists a mechanism to select whether IDs 0–127 reference the first or last 128 tiles, but for simplicity’s sake, we will overlook this for now, so please ignore the first (topmost) 128 tiles for the time being.</p>
<p>Now, please turn your attention to Emulicious’ Tilemap Viewer, pictured below.</p>
<p><img src="part1/../assets/img/tilemap_viewer.png" alt="Schermata del visualizzatore delle mappe Tiles" /></p>
<div class="box tip">
<p>You may notice that the image shown is larger than what is displayed on-screen.
Only part of the tilemap, outlined by a thicker border in the Tilemap Viewer, is displayed on-screen at a given time.
We will explain this in more detail in Part Ⅱ.</p>
</div>
<p>Qui potremo vedere la potenza del riutilizzo dei tile in tutta la sua forza.
Per comodità e per rinfrescare la memoria, ecco le tessere che il nostro Hello World carica nella VRAM:</p>
<p><img src="part1/../assets/img/hello_world_tiles.png" alt="Vista ingrandita delle tessere caricate nella VRAM" /></p>
<p>Si può notare che abbiamo caricato una sola tessera “vuota” ($00, la prima a sinistra in alto), ma può essere ripetuta per coprire l’intero sfondo senza costi aggiuntivi!</p>
<p>La ripetizione può essere più sottile: ad esempio, la tessera $01 è utilizzata per l’angolo superiore sinistro di H, E, L, L e W (linee rosse in basso)!
Anche la R, la L e la D condividono la loro tessera in alto a sinistra ($2D, linee blu in basso); e così via.
È possibile confermarlo passando il mouse sulle tessere nella scheda BG map, che mostra l’ID della tessera in quella posizione.</p>
<figure>
  <img src="part1/../assets/img/hello_world_mappings.svg" alt="Diagram of some tile mappings">
  <figcaption>
    Ecco alcuni esempi di riutilizzo delle tessere. Non tutto è disegnato, perché diventerebbe un pasticcio.
  </figcaption>
</figure>
<p>Tutto sommato, possiamo dedurre che la visualizzazione della grafica sul Game Boy consiste nel caricare i “modelli” (le tessere) e nel dire alla console quale tessera visualizzare per ciascuna posizione.</p>
<hr />
<div class="footnote-definition" id="tile_blocks"><sup class="footnote-definition-label">2</sup>
<p>The even more astute (astuter?) reader will have noticed that 384 = 3 × 128.
Thus, tiles are often conceptually grouped into three “blocks” of 128 tiles each, which Emulicious shows as separated by thicker horizontal lines.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-conclusione"><a class="header" href="#in-conclusione">In conclusione</a></h1>
<p>Congratulazioni!
Avete superato la prima parte di questa guida.
A questo punto, avete una conoscenza di base della console tale da sapere come visualizzare un’immagine.
Non sembra molto, ma considerate tutto ciò che avete visto finora: c’è stato molto da fare!</p>
<div class="box tip decorated"><p>🥳</p>
<p>Sinceramente, congratulazioni per essere arrivati fino a questo punto: molte persone si sono arrese prima.
Quindi potete darvi una pacca sulla spalla, ve la meritate davvero!
Se state leggendo tutto questo in un solo tratto, <strong>potrebbe essere un buon momento per fare una pausa</strong>.
Vi incoraggio a dare un po’ di tempo per assimilare il tutto e magari a tornare alle lezioni su cui avete fatto più fatica.
Forse una seconda lettura può aiutarvi.</p>
</div>
<hr />
<p>E sì, si poteva semplicemente lasciare che fosse una libreria a gestire tutto questo.
Tuttavia, i dettagli trapelano sempre alla fine, quindi conoscerli è utile, anche solo per il debug.</p>
<p>Inoltre, capire cosa succede davvero sotto il cofano vi renderà programmatori migliori, anche se alla fine non userete ASM.
È divertente notare che anche i sistemi moderni funzionano in modo simile a quelli più vecchi in punti inaspettati, quindi alcune cose che avete appena imparato si ripeteranno!
Fidatevi, tutto ciò che avete imparato e imparerete ne vale la pena! ✊</p>
<p>That said, right now, you may have a lot of questions.</p>
<ul>
<li>Why do we turn off the LCD?</li>
<li>We know how to make a static picture, but how to we add motion into the mix?</li>
<li>Also, how do I get input from the player?</li>
<li>The code mentions shutting down audio, but how do I play some of those famed beeps and bloops?</li>
<li>Writing graphics in that way sound tedious, is there no other way?</li>
<li>Actually, wait, how do we make a game out of all this??</li>
</ul>
<p>… Tutte queste risposte, e altre ancora, nella Parte Ⅱ! 👀</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="come-iniziare"><a class="header" href="#come-iniziare">Come iniziare</a></h1>
<p>In questa lezione inizieremo un nuovo progetto da zero.
Creeremo un clone di <a href="https://en.wikipedia.org/wiki/Breakout_%28video_game%29">Breakout</a> / <a href="https://en.wikipedia.org/wiki/Arkanoid">Arkanoid</a>, che chiameremo “Unbricked”!
(Anche se siete liberi di dargli qualsiasi altro nome, perché sarà il <em>vostro</em> progetto).</p>
<p>Aprire un terminale e creare una nuova directory (<code>mkdir unbricked</code>), quindi entrarvi (<code>cd unbricked</code>), proprio come si è fatto per <a href="part2/../part1/hello_world.html">“Hello, world!”</a>.</p>
<p>Si inizia creando un file chiamato <code>main.asm</code> e si include <code>hardware.inc</code> nel codice.</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;hardware.inc&quot;
</code></pre>
<p>You may be wondering what purpose <code>hardware.inc</code> serves.
Well, the code we write only really affects the CPU, but does not do anything with the rest of the console (not directly, anyway).
To interact with other components (like the graphics system, say), <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">Memory-Mapped <abbr title="Input/Output">I/O</abbr></a> (MMIO) is used: basically, <a href="part2/../part1/memory.html">memory</a> in a certain range (addresses $FF00–FF7F) does special things when accessed.</p>
<p>Essendo questi byte di memoria interfacce per l’hardware, sono chiamati <em>registri hardware</em> (da non confondere con <a href="part2/../part1/registers.html">i registri della CPU</a>).
Ad esempio, il registro “stato PPU” si trova all’indirizzo $FF41.
La lettura di questo indirizzo riporta varie informazioni sul sistema grafico e la scrittura consente di modificare alcuni parametri.
Ma dover ricordare tutti i numeri (<a href="https://gbdev.io/pandocs/Power_Up_Sequence.html#hardware-registers">elenco non esaustivo</a>) sarebbe molto noioso, ed è qui che entra in gioco <code>hardware.inc</code>!
<code>hardware.inc</code> definisce una costante per ciascuno di questi registri (per esempio, <code>rSTAT</code> per il già citato registro “stato della PPU”), più alcune costanti aggiuntive per i valori letti o scritti in questi registri.</p>
<div class="box tip">
<p>Non preoccupatevi se tutto questo vi è sfuggito di mano: di seguito vedremo un esempio con <code>rLCDC</code> e <code>LCDCF_ON</code>.</p>
<p>A proposito, la <code>r</code> sta per “registro” e la <code>F</code> in <code>LCDCF</code> sta per “flag”.</p>
</div>
<p>Quindi, fare spazio per l’intestazione.
<a href="part2/../part1/header.html">Ricordiamo dalla Parte Ⅰ</a> che l’intestazione è il luogo in cui vengono memorizzate alcune informazioni su cui il Game Boy fa affidamento, quindi non bisogna lasciarla fuori per sbaglio.</p>
<pre><code class="language-rgbasm linenos start=3">SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>L’intestazione salta a <code>EntryPoint</code>, quindi scriviamola ora:</p>
<pre><code class="language-rgbasm linenos start=9">EntryPoint:
	; Do not turn the LCD off outside of VBlank
WaitVBlank:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank

	; Turn the LCD off
	ld a, 0
	ld [rLCDC], a
</code></pre>
<p>Le righe successive attendono fino a “VBlank”, che è l’unico momento in cui è possibile spegnere lo schermo in modo sicuro (farlo nel momento sbagliato potrebbe danneggiare un vero Game Boy, quindi è molto importante).
Spiegheremo cos’è il VBlank e ne parleremo più avanti nel corso dell’esercitazione.</p>
<p>Spegnere lo schermo è importante perché il caricamento di nuove tessere a schermo acceso è complicato, come vedremo nella terza parte.</p>
<p>A proposito di tessere, ora ne caricheremo alcune nella VRAM, utilizzando il seguente codice:</p>
<pre><code class="language-rgbasm linenos start=20">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
CopyTiles:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTiles
</code></pre>
<p>Questo ciclo potrebbe essere <a href="part2/../part1/jumps.html#conditional-jumps">che ricorda la parte Ⅰ</a>.
Copia a partire da <code>Tiles</code> fino a <code>$9000</code>, che è la parte di VRAM in cui verrà memorizzato il nostro <a href="part2/../part1/tiles.html">tiles</a>.
Ricordiamo che <code>$9000</code> è il luogo in cui si trovano i dati del tile di sfondo $00, e i dati dei tile successivi seguono subito dopo.
Per ottenere il numero di byte da copiare, faremo come nella parte Ⅰ: usando un’altra etichetta alla fine, chiamata <code>TilesEnd</code>, la differenza tra questa (= l’indirizzo dopo l’ultimo byte dei dati delle tile) e <code>Tiles</code> (= l’indirizzo del primo byte) sarà esattamente quella lunghezza.</p>
<p>Detto questo, non abbiamo ancora scritto <code>Tiles</code> né i relativi dati.
Ci arriveremo più tardi!</p>
<p>Quasi finito ora - il prossimo, scrivere un altro ciclo, questa volta per copiare <a href="part2/../part1/tilemap.html">la mappa delle piastrelle</a>.</p>
<pre><code class="language-rgbasm linenos start=33">	; Copy the tilemap
	ld de, Tilemap
	ld hl, $9800
	ld bc, TilemapEnd - Tilemap
CopyTilemap:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTilemap
</code></pre>
<p>Si noti che, mentre il corpo di questo ciclo è esattamente lo stesso di <code>CopyTiles</code>, i 3 valori caricati in <code>de</code>, <code>hl</code> e <code>bc</code> sono diversi.
Questi determinano rispettivamente l’origine, la destinazione e la dimensione della copia.</p>
<div class="box tip"><p class="box-title">"Don't Repeat Yourself"</p>
<p>Se pensate che tutto ciò sia superfluo, non avete torto: vedremo più avanti come scrivere delle vere e proprie <em>funzioni</em> riutilizzabili.
Ma c’è molto di più di quello che sembra, quindi inizieremo ad affrontarle molto più avanti.</p>
</div>
<p>Infine, riaccendiamo lo schermo e impostiamo una <a href="part2/../part1/palettes.html">palette di sfondo</a>.
Invece di scrivere il numero non descritto <code>%10000001</code> (o $81 o 129, a seconda dei gusti), usiamo due costanti gentilmente fornite da <code>hardware.inc</code>: <code>LCDCF_ON</code> e <code>LCDCF_BGON</code>.
Quando vengono scritte su <a href="https://gbdev.io/pandocs/LCDC"><code>rLCDC</code></a>, la prima fa sì che la PPU e lo schermo si riaccendano, mentre la seconda permette di disegnare lo sfondo.
(Ci sono altri elementi che potrebbero essere disegnati, ma non li abilitiamo ancora).
La combinazione di queste costanti deve essere fatta usando <code>|</code>, l’operatore <em>binario “o “</em>; vedremo perché più avanti.</p>
<pre><code class="language-rgbasm linenos start=46">	; Turn the LCD on
	ld a, LCDCF_ON | LCDCF_BGON
	ld [rLCDC], a

	; During the first (blank) frame, initialize display registers
	ld a, %11100100
	ld [rBGP], a

Done:
	jp Done
</code></pre>
<p>C’è un’ultima cosa di cui abbiamo bisogno prima di costruire la ROM: la grafica.
Disegneremo la seguente schermata:</p>
<p><img src="part2/../assets/part2/img/tilemap.png" alt="Layout di unbricked" /></p>
<p>In <code>hello-world.asm</code>, tile data had been written out by hand in hexadecimal; this was to let you see how the sausage is made at the lowest level, but <em>boy</em> is it impractical to write!
This time, we will employ a more friendly way, which will let us write each row of pixels more easily.
For each row of pixels, instead of writing <a href="part2/../part1/tiles.html#encoding">the bitplanes</a> directly, we will use a backtick (```) followed by 8 characters.
Each character defines a single pixel, intuitively from left to right; it must be one of 0, 1, 2, and 3, representing the corresponding color index in <a href="part2/../part1/palettes.html">the palette</a>.</p>
<div class="box tip">
<p>Se la selezione dei caratteri non è di vostro gradimento, potete usare <a href="https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.1#g">l’opzione <code>-g</code> di RGBASM</a> o <a href="https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.5/#Changing_options_while_assembling"><code>OPT g</code></a> per sceglierne altri.
Per esempio, <code>rgbasm -g '.xXO' (...)</code> o <code>OPT g.xXO</code> scambiano i quattro caratteri rispettivamente con <code>.</code>, <code>x</code>, <code>X</code> e <code>O</code>.</p>
</div>
<p>Ad esempio:</p>
<pre><code class="language-rgbasm">	dw `01230123 ; This is equivalent to `db $55,$33`
</code></pre>
<p>Avrete notato che stiamo usando <code>dw</code> invece di <code>db</code>; la differenza tra questi due elementi sarà spiegata più avanti.
Abbiamo già delle piastrelle per questo progetto, quindi potete copiare <a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tileset.asm">questo file premade</a> e incollarlo alla fine del vostro codice.</p>
<p>Quindi copiare la mappa delle piastrelle da [questo file] (https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tilemap.asm) e incollarla dopo l’etichetta <code>TilesEnd</code>.</p>
<p>È possibile creare la ROM ora, eseguendo i seguenti comandi nel terminale:</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbasm -o main.o main.asm</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgblink -o unbricked.gb main.o</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgbfix -v -p 0xFF unbricked.gb</span>
</code></pre>
<p>Se si esegue questa operazione nell’emulatore, si dovrebbe vedere quanto segue:</p>
<p><img src="part2/../assets/part2/img/screenshot.png" alt="Schermata del nostro gioco" /></p>
<p>Quel quadrato bianco sembra essere scomparso!
Forse avete notato questo commento in precedenza, da qualche parte nei dati delle piastrelle:</p>
<pre><code class="language-rgbasm linenos start=135">	dw `22322232
	dw `23232323
	dw `33333333
	; Paste your logo here:

TilesEnd:
</code></pre>
<p>Le tessere del logo sono state lasciate intenzionalmente vuote, in modo che possiate scegliere il vostro.
Potete utilizzare uno dei seguenti loghi già pronti, oppure provare a crearne uno vostro!</p>
<ul>
<li>
<p><strong>RGBDS Logo</strong></p>
<p><img src="part2/../assets/part2/img/rgbds.png" alt="The RGBDS Logo" /></p>
<p><a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/rgbds.asm">Source</a></p>
</li>
<li>
<p><strong>Duck</strong></p>
<p><img src="part2/../assets/part2/img/duck.png" alt="A pixel-art duck" /></p>
<p><a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/duck.asm">Source</a></p>
</li>
<li>
<p><strong>Tail</strong></p>
<p><img src="part2/../assets/part2/img/tail.png" alt="A silhouette of a tail" /></p>
<p><a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tail.asm">Source</a></p>
</li>
</ul>
<p>Aggiungete i dati del logo scelto (cliccate su uno dei link “Source” qui sopra) dopo il commento, create di nuovo il gioco e dovreste vedere il logo scelto in basso a destra!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oggetti"><a class="header" href="#oggetti">Oggetti</a></h1>
<p>Lo sfondo è molto utile quando l’intero schermo deve muoversi contemporaneamente, ma non è l’ideale per tutto.
Ad esempio, il cursore in un menu, i PNG e il giocatore in un RPG, i proiettili in uno shmup o le palline in un clone di <em>Arkanoid</em>… devono tutti muoversi indipendentemente dallo sfondo.
Fortunatamente, il Game Boy ha una funzione perfetta per queste situazioni!
In questa lezione parleremo di <em>oggetti</em> (talvolta chiamati “OBJ”).</p>
<div class="box tip">
<p>La descrizione precedente potrebbe avervi fatto pensare al termine “sprite” invece che a “oggetto”.
Il termine “sprite” ha <em>molti</em> significati a seconda del contesto, quindi, per evitare confusione, questo tutorial cerca di usare alternative specifiche, come <em>oggetto</em>, <em>metasprite</em>, <em>attore</em>, ecc.</p>
</div>
<p>Ogni oggetto permette di disegnare una o due piastrelle (rispettivamente 8×8 o 8×16 pixel) in qualsiasi posizione sullo schermo, a differenza dello sfondo, dove tutte le piastrelle sono disegnate in una griglia.
Pertanto, un oggetto è composto dalla sua posizione sullo schermo, da un ID tile (come <a href="part2/../part1/tilemap.html">con la tilemap</a>) e da alcune proprietà extra chiamate “attributi”.
Queste proprietà extra consentono, ad esempio, di visualizzare la piastrella capovolta.
Ne parleremo più avanti.</p>
<p>Just like how the tilemap is stored in VRAM, objects live in a region of memory called OAM, meaning <strong>Object Attribute Memory</strong>.
Recall from above that an object consists of:</p>
<ul>
<li>Its on-screen position</li>
<li>A tile ID</li>
<li>The “attributes”</li>
</ul>
<p>Questi sono memorizzati in 4 byte: uno per la coordinata Y, uno per la coordinata X, uno per l’ID della piastrella e uno per gli attributi.
L’OAM è lungo 160 byte e poiché 160 ∕ 4 = 40, il Game Boy memorizza un totale di <strong>40</strong> oggetti in qualsiasi momento.</p>
<p>C’è però un problema: i byte delle coordinate Y e X di un oggetto in OAM non memorizzano la sua posizione sullo schermo!
Invece, la posizione X <em>sullo schermo</em> è la posizione X <em>memorizzata</em> <strong>meno 8</strong>, e la posizione Y <em>sullo schermo</em> è la posizione Y <em>memorizzata</em> <strong>meno 16</strong>.
Per interrompere la visualizzazione di un oggetto, è sufficiente metterlo fuori dallo schermo, ad esempio impostando la sua posizione Y a 0.</p>
<div class="box tip">
<p>Questi offset non sono arbitrari!
Si consideri la dimensione massima di un oggetto: 8 x 16 pixel.
Questi offset consentono agli oggetti di essere tagliati dai bordi sinistro e superiore dello schermo.
Il NES, ad esempio, non dispone di tali offset, per cui si noterà che gli oggetti scompaiono sempre dopo aver toccato il bordo sinistro o superiore dello schermo.</p>
</div>
<p>Scopriamo gli oggetti sperimentandoli!</p>
<p>Innanzitutto, all’accensione del Game Boy, l’OAM si riempie di valori semicasuali, che possono coprire lo schermo di spazzatura casuale.
Risolviamo questo problema cancellando l’OAM prima di attivare gli oggetti per la prima volta.
Aggiungiamo quanto segue subito dopo il ciclo <code>CopyTilemap</code>:</p>
<pre><code class="language-rgbasm linenos start=59">	ld a, 0
	ld b, 160
	ld hl, _OAMRAM
ClearOam:
	ld [hli], a
	dec b
	jp nz, ClearOam
</code></pre>
<p>Questo è un buon momento per farlo, poiché proprio come la VRAM, lo schermo deve essere spento per accedere in modo sicuro alla OAM.</p>
<p>Una volta che l’OAM è svuotato, possiamo disegnare un oggetto scrivendo le sue proprietà.</p>
<pre><code class="language-rgbasm linenos start=67">	ld hl, _OAMRAM
	ld a, 128 + 16
	ld [hli], a
	ld a, 16 + 8
	ld [hli], a
	ld a, 0
	ld [hli], a
	ld [hli], a
</code></pre>
<p>Si ricordi che ogni oggetto in OAM è composto da 4 byte, nell’ordine Y, X, Tile ID, Attributi.
Quindi, il pixel in alto a sinistra dell’oggetto si trova a 128 pixel dalla parte superiore dello schermo e a 16 da quella sinistra.
L’ID tessera e gli attributi sono entrambi impostati a 0.</p>
<p>Come si ricorderà dalla lezione precedente, stiamo già usando l’ID 0, che è l’inizio della grafica del nostro sfondo.
Tuttavia, per impostazione predefinita, gli oggetti e gli sfondi utilizzano un insieme diverso di piastrelle, almeno per i primi 128 ID.
Le mattonelle con ID 128-255 sono condivise da entrambi, il che è utile se si ha una mattonella che viene utilizzata sia dallo sfondo che da un oggetto.</p>
<p>If you go to “Tools”, then “Tile Viewer” in Emulicious’ debugger, you should see three distinct sections.</p>
<p><img src="part2/../assets/img/vram_viewer.png" alt="image" /></p>
<p>Poiché dobbiamo caricarla in un’area diversa, useremo l’indirizzo $8000 e caricheremo una grafica per la paletta del gioco.
Lo faremo subito dopo <code>CopyTilemap</code>:</p>
<pre><code class="language-rgbasm linenos start=46">	; Copy the paddle tile
	ld de, Paddle
	ld hl, $8000
	ld bc, PaddleEnd - Paddle
CopyPaddle:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyPaddle
</code></pre>
<p>E non dimenticate di aggiungere <code>Paddle</code> alla fine del codice.</p>
<pre><code class="language-rgbasm">Paddle:
	dw `13333331
	dw `30000003
	dw `13333331
	dw `00000000
	dw `00000000
	dw `00000000
	dw `00000000
	dw `00000000
PaddleEnd:
</code></pre>
<p>Infine, abilitiamo gli oggetti e vediamo il risultato.
Gli oggetti devono essere abilitati dal noto registro <code>rLCDC</code>, altrimenti non vengono visualizzati.
(Questo è il motivo per cui non abbiamo dovuto cancellare l’OAM nelle lezioni precedenti).
Dobbiamo anche inizializzare una delle tavolozze degli oggetti, <code>rOBP0</code>.
In realtà ci sono due tavolozze di oggetti, ma ne useremo solo una.</p>
<pre><code class="language-rgbasm linenos start=76">	; Turn the LCD on
	ld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJON
	ld [rLCDC], a

	; During the first (blank) frame, initialize display registers
	ld a, %11100100
	ld [rBGP], a
	ld a, %11100100
	ld [rOBP0], a
</code></pre>
<h2 id="movimento"><a class="header" href="#movimento">Movimento</a></h2>
<p>Ora che abbiamo un oggetto sullo schermo, spostiamolo.
In precedenza, il ciclo <code>Done</code> non faceva nulla; rinominiamolo in <code>Main</code> e usiamolo per spostare il nostro oggetto.
Aspetteremo il VBlank prima di cambiare OAM, proprio come abbiamo fatto prima di spegnere lo schermo.</p>
<pre><code class="language-rgbasm linenos start=90">Main:
    ; Wait until it's *not* VBlank
    ld a, [rLY]
    cp 144
    jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	; Move the paddle one pixel to the right.
	ld a, [_OAMRAM + 1]
	inc a
	ld [_OAMRAM + 1], a
	jp Main
</code></pre>
<div class="box tip decorated"><p>🤨</p>
<p>In questo caso, si accede all’OAM senza spegnere lo schermo LCD, ma è comunque sicuro.
Per spiegarne il motivo è necessaria una spiegazione più approfondita del rendering del Game Boy, quindi per ora ignoriamolo.</p>
</div>
<p>Now you should see the paddle moving… very quickly.
Because it moves by a pixel every frame, it’s going at a speed of 60 pixels per second!
To slow this down, we’ll use a <em>variable</em>.</p>
<p>Finora abbiamo lavorato solo con i registri della CPU, ma è possibile creare anche variabili globali!
Per farlo, creiamo un’altra sezione, ma mettiamola in <code>WRAM0</code> invece che in <code>ROM0</code>.
A differenza della ROM (“Read-Only Memory”, memoria di sola lettura), la RAM (“Random-Access Memory”, memoria ad accesso casuale) può essere scritta; quindi, la WRAM, o Work RAM, è il luogo in cui possiamo memorizzare le variabili del nostro gioco.</p>
<p>Aggiungete questo in fondo al vostro file:</p>
<pre><code class="language-rgbasm linenos start=359">SECTION &quot;Counter&quot;, WRAM0
wFrameCounter: db
</code></pre>
<p>Now we’ll use the <code>wFrameCounter</code> variable to count how many frames have passed since we last moved the paddle.
Every 15th frame, we’ll move the paddle by one pixel, slowing it down to 4 pixels per second.
Don’t forget that RAM is filled with garbage values when the Game Boy starts, so we need to initialize our variables before first using them.</p>
<pre><code class="language-rgbasm linenos start=86">	; Initialize global variables
	ld a, 0
	ld [wFrameCounter], a

Main:
	ld a, [rLY]
	cp 144
	jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	ld a, [wFrameCounter]
	inc a
	ld [wFrameCounter], a
	cp a, 15 ; Every 15 frames (a quarter of a second), run the following code
	jp nz, Main

	; Reset the frame counter back to 0
	ld a, 0
	ld [wFrameCounter], a

	; Move the paddle one pixel to the right.
	ld a, [_OAMRAM + 1]
	inc a
	ld [_OAMRAM + 1], a
	jp Main
</code></pre>
<p>Bene!
Il prossimo passo è prendere il controllo della tessera.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funzioni"><a class="header" href="#funzioni">Funzioni</a></h1>
<p>Finora abbiamo scritto un solo “flusso” di codice, ma possiamo già individuare alcuni frammenti che sembrano ridondanti.
Usiamo le <strong>funzioni</strong> per “sfoltire” il codice!</p>
<p>Per esempio, in tre punti stiamo copiando pezzi di memoria.
Scriviamo una funzione sotto la <code>jp Main</code> e chiamiamola <code>Memcpy</code>, come <a href="https://man7.org/linux/man-pages/man3/memcpy.3.html">l’analoga funzione C</a>:</p>
<pre><code class="language-rgbasm linenos start=94">; Copy bytes from one area to another.
; @param de: Source
; @param hl: Destination
; @param bc: Length
Memcopy:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, Memcopy
	ret
</code></pre>
<p>La nuova istruzione <code>ret' dovrebbe catturare immediatamente l'attenzione. È, senza sorpresa, quella che fa sì che l'esecuzione *ritorni* al punto in cui la funzione è stata *chiamata*. È importante notare che molti linguaggi prevedono una &quot;fine&quot; precisa per una funzione: in C o Rust, è la parentesi graffa di chiusura </code>}<code>; in Pascal o Lua, la parola chiave </code>end<code>, e così via; la funzione ritorna implicitamente quando l'esecuzione raggiunge la sua fine. Tuttavia, **non è così in assembly**, quindi bisogna ricordarsi di aggiungere un'istruzione </code>ret` alla fine della funzione per ritornare da essa!
Altrimenti, i risultati sono imprevedibili.</p>
<p>Notate il commento sopra la funzione, che spiega quali registri prende in ingresso.
Questo commento è importante per sapere come interfacciarsi con la funzione; l’assembly non ha parametri formali, quindi i commenti che li spiegano sono ancora più importanti che in altri linguaggi.
Ne vedremo altri man mano che procediamo.</p>
<p>Ci sono tre punti nel codice di inizializzazione in cui possiamo usare la funzione <code>Memcpy</code>.
Trovate ognuno di questi cicli di copia e sostituiteli con una chiamata a <code>Memcpy</code>; per questo, utilizziamo l’istruzione <code>call</code>.
I registri servono come parametri alla funzione, quindi li lasceremo così come sono.</p>
<div class="table-wrapper"><table><thead><tr><th>Prima di</th><th>Dopo</th></tr></thead><tbody><tr><td>
<pre><code class="language-rgbasm linenos start=20">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
CopyTiles:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTiles
</code></pre>
</td><td>
<pre><code class="language-rgbasm linenos start=20">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
	call Memcopy
</code></pre>
</td></tr><tr><td>
<pre><code class="language-rgbasm linenos start=33">	; Copy the tilemap
	ld de, Tilemap
	ld hl, $9800
	ld bc, TilemapEnd - Tilemap
CopyTilemap:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTilemap
</code></pre>
</td><td>
<pre><code class="language-rgbasm linenos start=26">	; Copy the tilemap
	ld de, Tilemap
	ld hl, $9800
	ld bc, TilemapEnd - Tilemap
	call Memcopy
</code></pre>
</td></tr><tr><td>
<pre><code class="language-rgbasm linenos start=46">	; Copy the paddle tile
	ld de, Paddle
	ld hl, $8000
	ld bc, PaddleEnd - Paddle
CopyPaddle:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyPaddle
</code></pre>
</td><td>
<pre><code class="language-rgbasm linenos start=32">	; Copy the paddle tile
	ld de, Paddle
	ld hl, $8000
	ld bc, PaddleEnd - Paddle
	call Memcopy
</code></pre>
</td></tr></tbody></table></div>
<p>Nel prossimo capitolo, scriveremo un’altra funzione, questa volta per leggere gli input del giocatore.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-giocatore"><a class="header" href="#input-giocatore">Input Giocatore</a></h1>
<p>Abbiamo le fondamenta di un gioco, ma manca ancora l’input del giocatore.
Un gioco che si gioca da solo non è molto divertente, quindi cerchiamo di risolvere questo problema.</p>
<p>Incollare questo codice sotto il ciclo <code>Main</code>.
Come <code>Memcpy</code>, questa è una funzione che può essere riutilizzata da diversi punti, utilizzando l’istruzione <code>call</code>.</p>
<pre><code class="language-rgbasm linenos start=113">UpdateKeys:
  ; Poll half the controller
  ld a, P1F_GET_BTN
  call .onenibble
  ld b, a ; B7-4 = 1; B3-0 = unpressed buttons

  ; Poll the other half
  ld a, P1F_GET_DPAD
  call .onenibble
  swap a ; A7-4 = unpressed directions; A3-0 = 1
  xor a, b ; A = pressed buttons + directions
  ld b, a ; B = pressed buttons + directions

  ; And release the controller
  ld a, P1F_GET_NONE
  ldh [rP1], a

  ; Combine with previous wCurKeys to make wNewKeys
  ld a, [wCurKeys]
  xor a, b ; A = keys that changed state
  and a, b ; A = keys that changed to pressed
  ld [wNewKeys], a
  ld a, b
  ld [wCurKeys], a
  ret

.onenibble
  ldh [rP1], a ; switch the key matrix
  call .knownret ; burn 10 cycles calling a known ret
  ldh a, [rP1] ; ignore value while waiting for the key matrix to settle
  ldh a, [rP1]
  ldh a, [rP1] ; this read counts
  or a, $F0 ; A7-4 = 1; A3-0 = unpressed keys
.knownret
  ret
</code></pre>
<p>Sfortunatamente, la lettura degli input sul Game Boy è piuttosto complessa (come potete vedere!) e sarebbe piuttosto difficile spiegare cosa fa questa funzione in questo momento.
Vi chiedo quindi di fare un’eccezione e di fidarvi del fatto che questa funzione legge l’input.
Va bene? Bene!</p>
<p>Ora che sappiamo come usare le funzioni, chiamiamo la funzione <code>UpdateKeys</code> nel nostro ciclo principale per leggere l’input dell’utente.
La funzione <code>UpdateKeys</code> scrive i pulsanti tenuti in una posizione in memoria che abbiamo chiamato <code>wCurKeys</code>, da cui possiamo leggere dopo il ritorno della funzione.
Per questo motivo, è sufficiente chiamare <code>UpdateKeys</code> una sola volta per ogni fotogramma.</p>
<p>Questo è importante, perché non solo è più veloce ricaricare gli input che abbiamo già elaborato, ma significa anche che agiremo sempre sugli stessi input, anche se il giocatore preme o rilascia un pulsante a metà fotogramma.</p>
<p>Per prima cosa, mettiamo da parte un po’ di spazio per le due variabili che <code>UpdateKeys</code> utilizzerà; incollate questo alla fine del file <code>main.asm</code>:</p>
<pre><code class="language-rgbasm linenos start=410">SECTION &quot;Input Variables&quot;, WRAM0
wCurKeys: db
wNewKeys: db
</code></pre>
<p>Ogni variabile deve risiedere nella RAM e non nella ROM, perché la ROM è “Read-Only” (quindi non può essere modificata).
Inoltre, ogni variabile deve essere grande solo un byte, quindi si usa <code>db</code> (“Define Byte”) per riservare un byte di RAM a ciascuna.</p>
<p>Before we read these variables we will also want to initialize them.
We can do that below our initialization  of <code>wFrameCounter</code>.</p>
<pre><code class="language-rgbasm linenos start=65">	; Initialize global variables
	ld a, 0
	ld [wFrameCounter], a
	ld [wCurKeys], a
	ld [wNewKeys], a
</code></pre>
<p>Utilizzeremo l’opcode <code>and</code>, che può essere utilizzato per impostare il flag di zero (<code>z</code>) sul valore del bit.
Possiamo usare questo insieme alle costanti <code>PADF</code> in hardware.inc per leggere un particolare tasto.</p>
<pre><code class="language-rgbasm linenos start=71">Main:
	ld a, [rLY]
	cp 144
	jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	; Check the current keys every frame and move left or right.
	call UpdateKeys

	; First, check if the left button is pressed.
CheckLeft:
	ld a, [wCurKeys]
	and a, PADF_LEFT
	jp z, CheckRight
Left:
	; Move the paddle one pixel to the left.
	ld a, [_OAMRAM + 1]
	dec a
	; If we've already hit the edge of the playfield, don't move.
	cp a, 15
	jp z, Main
	ld [_OAMRAM + 1], a
	jp Main

; Then check the right button.
CheckRight:
	ld a, [wCurKeys]
	and a, PADF_RIGHT
	jp z, Main
Right:
	; Move the paddle one pixel to the right.
	ld a, [_OAMRAM + 1]
	inc a
	; If we've already hit the edge of the playfield, don't move.
	cp a, 105
	jp z, Main
	ld [_OAMRAM + 1], a
	jp Main
</code></pre>
<p>Ora, se compilate il progetto, dovreste essere in grado di muovere la racchetta a destra e a sinistra usando il d-pad!!!
Urrà, abbiamo l’inizio di un gioco!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collisioni"><a class="header" href="#collisioni">Collisioni</a></h1>
<p>Potersi muovere è fantastico, ma c’è ancora un oggetto di cui abbiamo bisogno per questo gioco: una palla!
Come per la racchetta, il primo passo è creare un riquadro per la palla e caricarlo nella VRAM.</p>
<h2 id="grafica"><a class="header" href="#grafica">Grafica</a></h2>
<p>Add this to the bottom of your file along with the other graphics:</p>
<pre><code class="language-rgbasm linenos start=573">Ball:
	dw `00033000
	dw `00322300
	dw `03222230
	dw `03222230
	dw `00322300
	dw `00033000
	dw `00000000
	dw `00000000
BallEnd:
</code></pre>
<p>Now copy it to VRAM somewhere in your initialization code, e.g. after copying the paddle’s tile.</p>
<pre><code class="language-rgbasm linenos start=38">	; Copy the ball tile
	ld de, Ball
	ld hl, $8010
	ld bc, BallEnd - Ball
	call Memcopy
</code></pre>
<p>In addition, we need to initialize an entry in OAM, following the code that initializes the paddle.</p>
<pre><code class="language-rgbasm linenos start=52">	; Initialize the paddle sprite in OAM
	ld hl, _OAMRAM
	ld a, 128 + 16
	ld [hli], a
	ld a, 16 + 8
	ld [hli], a
	ld a, 0
	ld [hli], a
	ld [hli], a
	; Now initialize the ball sprite
	ld a, 100 + 16
	ld [hli], a
	ld a, 32 + 8
	ld [hli], a
	ld a, 1
	ld [hli], a
	ld a, 0
	ld [hli], a
</code></pre>
<p>As the ball bounces around the screen its momentum will change, sending it in different directions.
Let’s create two new variables to track the ball’s momentum in each axis: <code>wBallMomentumX</code> and <code>wBallMomentumY</code>.</p>
<pre><code class="language-rgbasm linenos start=584">SECTION &quot;Counter&quot;, WRAM0
wFrameCounter: db

SECTION &quot;Input Variables&quot;, WRAM0
wCurKeys: db
wNewKeys: db

SECTION &quot;Ball Data&quot;, WRAM0
wBallMomentumX: db
wBallMomentumY: db
</code></pre>
<p>We will need to initialize these before entering the game loop, so let’s do so right after we write the ball to OAM.
By setting the X momentum to 1, and the Y momentum to -1, the ball will start out by going up and to the right.</p>
<pre><code class="language-rgbasm linenos start=61">	; Now initialize the ball sprite
	ld a, 100 + 16
	ld [hli], a
	ld a, 32 + 8
	ld [hli], a
	ld a, 1
	ld [hli], a
	ld a, 0
	ld [hli], a

	; The ball starts out going up and to the right
	ld a, 1
	ld [wBallMomentumX], a
	ld a, -1
	ld [wBallMomentumY], a
</code></pre>
<h2 id="lavoro-di-preparazione"><a class="header" href="#lavoro-di-preparazione">Lavoro di preparazione</a></h2>
<p>Now for the fun part!
Add a bit of code at the beginning of your main loop that adds the momentum to the OAM positions.
Notice that since this is the second OAM entry, we use <code>+ 4</code> for Y and <code>+ 5</code> for X.
This can get pretty confusing, but luckily we only have two objects to keep track of.
In the future, we’ll go over a much easier way to use OAM.</p>
<pre><code class="language-rgbasm linenos start=93">Main:
	ld a, [rLY]
	cp 144
	jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	; Add the ball's momentum to its position in OAM.
	ld a, [wBallMomentumX]
	ld b, a
	ld a, [_OAMRAM + 5]
	add a, b
	ld [_OAMRAM + 5], a

	ld a, [wBallMomentumY]
	ld b, a
	ld a, [_OAMRAM + 4]
	add a, b
	ld [_OAMRAM + 4], a
</code></pre>
<p>Si consiglia di compilare nuovamente il gioco per vedere cosa fa.
Se lo fate, dovreste vedere la palla muoversi, ma passerà attraverso i muri e poi volerà fuori dallo schermo.</p>
<p>Per risolvere questo problema, dobbiamo aggiungere il rilevamento delle collisioni, in modo che la palla possa rimbalzare.
Dovremo ripetere il controllo delle collisioni un paio di volte, quindi utilizzeremo due funzioni per farlo.</p>
<div class="box tip">
<p>Non perdetevi nei dettagli di questa funzione, perché utilizza alcune tecniche e istruzioni che non abbiamo ancora discusso.
L’idea di base è che converte la posizione dello sprite in una posizione sulla mappa delle piastrelle.
In questo modo, possiamo controllare quale piastrella sta toccando la nostra palla, in modo da sapere quando rimbalzare!</p>
</div>
<pre><code class="language-rgbasm linenos start=229">; Convert a pixel position to a tilemap address
; hl = $9800 + X + Y * 32
; @param b: X
; @param c: Y
; @return hl: tile address
GetTileByPixel:
	; First, we need to divide by 8 to convert a pixel position to a tile position.
	; After this we want to multiply the Y position by 32.
	; These operations effectively cancel out so we only need to mask the Y value.
	ld a, c
	and a, %11111000
	ld l, a
	ld h, 0
	; Now we have the position * 8 in hl
	add hl, hl ; position * 16
	add hl, hl ; position * 32
	; Convert the X position to an offset.
	ld a, b
	srl a ; a / 2
	srl a ; a / 4
	srl a ; a / 8
	; Add the two offsets together.
	add a, l
	ld l, a
	adc a, h
	sub a, l
	ld h, a
	; Add the offset to the tilemap's base address, and we are done!
	ld bc, $9800
	add hl, bc
	ret
</code></pre>
<p>The next function is called <code>IsWallTile</code>, and it’s going to contain a list of tiles which the ball can bounce off of.</p>
<pre><code class="language-rgbasm linenos start=261">; @param a: tile ID
; @return z: set if a is a wall.
IsWallTile:
	cp a, $00
	ret z
	cp a, $01
	ret z
	cp a, $02
	ret z
	cp a, $04
	ret z
	cp a, $05
	ret z
	cp a, $06
	ret z
	cp a, $07
	ret
</code></pre>
<p>Questa funzione può sembrare un po’ strana all’inizio.
Invece di restituire il risultato in un <em>registro</em>, come <code>a</code>, lo restituisce in <a href="part2/../part1/operations.html#flags">un <em>flag</em></a>: <code>Z</code>!
Se in qualsiasi punto una piastrella corrisponde, la funzione ha trovato un muro ed esce con <code>Z</code> impostato.
Se l’ID della piastrella di destinazione (in <code>a</code>) corrisponde a uno degli ID delle piastrelle del muro, il corrispondente <code>cp</code> lascerà <code>Z</code> impostato; in tal caso, si ritorna immediatamente (tramite <code>ret z</code>), con <code>Z</code> impostato.
Ma se, dopo aver effettuato l’ultimo confronto, <code>Z</code> non viene ancora impostato, sapremo che non abbiamo colpito un muro e non abbiamo bisogno di rimbalzare.</p>
<h2 id="unificare-il-tutto"><a class="header" href="#unificare-il-tutto">Unificare il tutto</a></h2>
<p>Time to use these new functions to add collision detection!
Add the following after the code that updates the ball’s position:</p>
<pre><code class="language-rgbasm linenos start=115">BounceOnTop:
	; Remember to offset the OAM position!
	; (8, 16) in OAM coordinates is (0, 0) on the screen.
	ld a, [_OAMRAM + 4]
	sub a, 16 + 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel ; Returns tile address in hl
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnRight
	ld a, 1
	ld [wBallMomentumY], a
</code></pre>
<p>Vedrete che quando carichiamo le posizioni dello sprite, le sottraiamo prima di chiamare <code>GetTileByPixel</code>.
Forse ricorderete dall’ultimo capitolo che le posizioni OAM sono leggermente sfalsate; cioè, (0, 0) in OAM è in realtà completamente fuori dallo schermo.
Queste istruzioni <code>sub</code> annullano questo offset.</p>
<p>Tuttavia, c’è dell’altro: avrete notato che abbiamo sottratto un pixel in più dalla posizione Y. Questo perché (come suggerisce l’etichetta) questo codice controlla la presenza di una piastrella sopra la palla.
Questo perché (come suggerisce l’etichetta), il codice controlla la presenza di una piastrella sopra la palla.
In realtà abbiamo bisogno di controllare <em>tutti e quattro</em> i lati della palla, in modo da sapere come cambiare la quantità di moto a seconda del lato che si è scontrato, quindi… aggiungiamo il resto!</p>
<pre><code class="language-rgbasm linenos start=131">BounceOnRight:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 - 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnLeft
	ld a, -1
	ld [wBallMomentumX], a

BounceOnLeft:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 + 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnBottom
	ld a, 1
	ld [wBallMomentumX], a

BounceOnBottom:
	ld a, [_OAMRAM + 4]
	sub a, 16 - 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceDone
	ld a, -1
	ld [wBallMomentumY], a
BounceDone:
</code></pre>
<p>Era molto, ma ora la palla rimbalza sullo schermo!
C’è solo un’ultima cosa da fare prima della fine di questo capitolo: la collisione tra palla e paddle.</p>
<h2 id="rimbalzo-della-pagaia"><a class="header" href="#rimbalzo-della-pagaia">Rimbalzo della pagaia</a></h2>
<p>A differenza di quanto accade con la tilemap, qui non è necessario effettuare conversioni di posizione, ma solo confronti diretti.
Tuttavia, per questi ultimi, avremo bisogno <a href="part2/../part1/operations.html#flags">del flag <em>carry</em></a>.
Il flag di riporto è indicato con <code>C</code>, come il flag zero è indicato con <code>Z</code>, ma non bisogna confonderlo con il registro <code>c</code>!</p>
<div class="box tip"><p class="box-title">A refresher on comparisons</p>
<p>Proprio come <code>Z</code>, è possibile utilizzare il flag di riporto per fare salti condizionati.
Tuttavia, mentre <code>Z</code> viene utilizzato per verificare se due numeri sono uguali, <code>C</code> può essere utilizzato per verificare se un numero è maggiore o minore di un altro.
Per esempio, <code>cp a, b</code> imposta <code>C</code> se <code>a &lt; b</code> e lo azzera se <code>a &gt;= b</code>.
(Per verificare <code>a &lt;= b</code> o <code>a &gt; b</code> si possono usare <code>Z</code> e <code>C</code> in tandem con due istruzioni <code>jp</code>)</p>
</div>
<p>Armed with this knowledge, let’s work through the paddle bounce code:</p>
<pre><code class="language-rgbasm linenos start=174">	; First, check if the ball is low enough to bounce off the paddle.
	ld a, [_OAMRAM]
	ld b, a
	ld a, [_OAMRAM + 4]
	cp a, b
	jp nz, PaddleBounceDone ; If the ball isn't at the same Y position as the paddle, it can't bounce.
	; Now let's compare the X positions of the objects to see if they're touching.
	ld a, [_OAMRAM + 5] ; Ball's X position.
	ld b, a
	ld a, [_OAMRAM + 1] ; Paddle's X position.
	sub a, 8
	cp a, b
	jp nc, PaddleBounceDone
	add a, 8 + 16 ; 8 to undo, 16 as the width.
	cp a, b
	jp c, PaddleBounceDone

	ld a, -1
	ld [wBallMomentumY], a

PaddleBounceDone:
</code></pre>
<p>Il controllo della posizione Y è semplice, poiché la nostra racchetta è piatta.
Tuttavia, la posizione X ha due controlli che ampliano l’area in cui la palla può rimbalzare.
Innanzitutto aggiungiamo 16 alla posizione della pallina; se la pallina si trova a più di 16 pixel a destra della racchetta, non dovrebbe rimbalzare.
Poi annulliamo questa operazione sottraendo 16 e, già che ci siamo, sottraiamo altri 8 pixel; se la palla si trova a più di 8 pixel a sinistra della racchetta, non dovrebbe rimbalzare.</p>
<svg viewBox="-10 -10 860 520">
	<style>
		text { text-anchor: middle; fill: var(--fg); font-size: 20px; }
		.left { text-anchor: start; }
		.right { text-anchor: end; }
		.grid { stroke: var(--fg); opacity: 0.7; }
		.ball { stroke: verde acqua; }
		.paddle { stroke: orange; }
		.excl { stroke: red; } text.excl { stroke: initial; fill: red; font-family: "Source Code Pro", Consolas, "Ubuntu Mono", Menlo, "DejaVu Sans Mono", monospace, monospace !important; }
		/* Sovrapposizioni */
		rect, polyline { opacity: 0.5; stroke-width: 3; }
		/* Freccia */
		poligono { stroke: inherit; fill: var(--bg); }
		uso + linea { stroke-dasharray: 0 32 999; larghezza tratto: 2; }
	</style>
	<defs>
		<polygon id="arrow-head" points="0,0 -40,-16 -32,0 -40,16" stroke="context-stroke"/>
		<pattern id="ball-hatched" viewBox="0 0 4 4" width="8" height="8" patternUnits="userSpaceOnUse">
			<line x1="5" y1="-1" x2="-1" y2="5" class="ball"/>
			<line x1="5" y1="3" x2="3" y2="5" class="ball"/>
			<line x1="1" y1="-1" x2="-1" y2="1" class="ball"/>
		</pattern>
		<pattern id="paddle-hatched" viewBox="0 0 4 4" width="8" height="8" patternUnits="userSpaceOnUse">
			<line x1="5" y1="-1" x2="-1" y2="5" class="paddle"/>
			<line x1="5" y1="3" x2="3" y2="5" class="paddle"/>
			<line x1="1" y1="-1" x2="-1" y2="1" class="paddle"/>
		</pattern>
		<pattern id="excl-hatched" viewBox="0 0 4 4" width="8" height="8" patternUnits="userSpaceOnUse">
			<line x1="5" y1="-1" x2="-1" y2="5" class="excl"/>
			<line x1="5" y1="3" x2="3" y2="5" class="excl"/>
			<line x1="1" y1="-1" x2="-1" y2="1" class="excl"/>
		</pattern>
	</defs>
	<image x="128" y="0" width="256" height="256" href="../assets/part2/img/ball.png"/>
	<rect x="128" y="0" width="32" height="32" fill="url(#ball-hatched)"/>
	<image x="288" y="256" width="256" height="256" href="../assets/part2/img/paddle.png"/>
	<rect x="288" y="256" width="32" height="32" fill="url(#paddle-hatched)"/>
	<line class="grid" x1="-10" y1="0" x2="850" y2="0"/>
	<line class="grid" x1="-10" y1="32" x2="850" y2="32"/>
	<line class="grid" x1="-10" y1="64" x2="850" y2="64"/>
	<line class="grid" x1="-10" y1="96" x2="850" y2="96"/>
	<line class="grid" x1="-10" y1="128" x2="850" y2="128"/>
	<line class="grid" x1="-10" y1="160" x2="850" y2="160"/>
	<line class="grid" x1="-10" y1="192" x2="850" y2="192"/>
	<line class="grid" x1="-10" y1="224" x2="850" y2="224"/>
	<line class="grid" x1="-10" y1="256" x2="850" y2="256"/>
	<line class="grid" x1="-10" y1="288" x2="850" y2="288"/>
	<line class="grid" x1="-10" y1="320" x2="850" y2="320"/>
	<line class="grid" x1="-10" y1="352" x2="850" y2="352"/>
	<line class="grid" x1="0" y1="-20" x2="0" y2="351"/>
	<line class="grid" x1="32" y1="-20" x2="32" y2="351"/>
	<line class="grid" x1="64" y1="-20" x2="64" y2="351"/>
	<line class="grid" x1="96" y1="-20" x2="96" y2="351"/>
	<line class="grid" x1="128" y1="-20" x2="128" y2="351"/>
	<line class="grid" x1="160" y1="-20" x2="160" y2="351"/>
	<line class="grid" x1="192" y1="-20" x2="192" y2="351"/>
	<line class="grid" x1="224" y1="-20" x2="224" y2="351"/>
	<line class="grid" x1="256" y1="-20" x2="256" y2="351"/>
	<line class="grid" x1="288" y1="-20" x2="288" y2="351"/>
	<line class="grid" x1="320" y1="-20" x2="320" y2="351"/>
	<line class="grid" x1="352" y1="-20" x2="352" y2="351"/>
	<line class="grid" x1="384" y1="-20" x2="384" y2="351"/>
	<line class="grid" x1="416" y1="-20" x2="416" y2="351"/>
	<line class="grid" x1="448" y1="-20" x2="448" y2="351"/>
	<line class="grid" x1="480" y1="-20" x2="480" y2="351"/>
	<line class="grid" x1="512" y1="-20" x2="512" y2="351"/>
	<line class="grid" x1="544" y1="-20" x2="544" y2="351"/>
	<line class="grid" x1="576" y1="-20" x2="576" y2="351"/>
	<line class="grid" x1="608" y1="-20" x2="608" y2="351"/>
	<line class="grid" x1="640" y1="-20" x2="640" y2="351"/>
	<line class="grid" x1="672" y1="-20" x2="672" y2="351"/>
	<line class="grid" x1="704" y1="-20" x2="704" y2="351"/>
	<line class="grid" x1="736" y1="-20" x2="736" y2="351"/>
	<line class="grid" x1="768" y1="-20" x2="768" y2="351"/>
	<line class="grid" x1="800" y1="-20" x2="800" y2="351"/>
	<line class="grid" x1="832" y1="-20" x2="832" y2="351"/>
	<rect x="128" y="0" width="256" height="256" class="ball" style="fill: none;"/>
	<polyline points="288,352 288,256 544,256 544,352" class="paddle" style="fill: none;"/>
	<rect x="-15" y="-15" width="47" height="440" class="excl" fill="url(#excl-hatched)"/>
	<text x="40" y="430" class="excl left">jp c, DoNotBounce</text>
	<rect x="800" y="-15" width="52" height="510" class="excl" fill="url(#excl-hatched)"/>
	<text x="790" y="500" class="excl right">jp nc, DoNotBounce</text>
	<use href="#arrow-head" x="48" y="380" transform="rotate(-180,48,380)" class="paddle"/><line x1="48" y1="380" x2="304" y2="380" class="paddle"/>
	<text x="176" y="400">- 8</text>
	<use href="#arrow-head" x="304" y="450" class="paddle"/><line x1="304" y1="450" x2="48" y2="450" class="paddle"/>
	<use href="#arrow-head" x="816" y="450" class="paddle"/><line x1="816" y1="450" x2="304" y2="450" class="paddle"/>
	<text x="432" y="470">+ 8 + 16</text>
</svg>
<div class="box tip"><p class="box-title">Paddle width</p>
<p>Ci si potrebbe chiedere perché abbiamo controllato 16 pixel a destra ma solo 8 pixel a sinistra.
Ricordate che le posizioni OAM rappresentano l’angolo superiore <em>sinistro</em> di uno sprite, quindi il centro della nostra paletta è in realtà 4 pixel a destra della posizione in OAM.
Se si considera questo, in realtà stiamo controllando 12 pixel su entrambi i lati dal centro della paletta.</p>
<p>12 pixel possono sembrare molti, ma danno un po’ di tolleranza al giocatore nel caso in cui il suo posizionamento sia sbagliato.
Se si preferisce rendere il tutto più facile o più difficile, è possibile regolare i valori!</p>
</div>
<h2 id="bonus-modifica-dellaltezza-di-rimbalzo"><a class="header" href="#bonus-modifica-dellaltezza-di-rimbalzo">BONUS: modifica dell’altezza di rimbalzo</a></h2>
<p>Si può notare che la pallina sembra “affondare” un po’ nella paletta prima di rimbalzare. Questo perché la pallina rimbalza quando la sua riga superiore di pixel si allinea con la riga superiore della paletta (si veda l’immagine sopra). Se volete, provate a regolare questo aspetto in modo che la pallina rimbalzi quando la sua fila di pixel inferiore tocca quella superiore della paletta.</p>
<p>Suggerimento: è possibile farlo con una sola istruzione!</p>
<details><summary>Risposta:</summary>
<pre><code class="language-diff linenos start=174">	ld a, [_OAMRAM]
	ld b, a
	ld a, [_OAMRAM + 4]
+	add a, 6
	cp a, b
</code></pre>
<p>Alternatively, you can add <code>sub a, 6</code> just after <code>ld a, [_OAMRAM]</code>.</p>
<p>In entrambi i casi, provate a giocare con il valore <code>6</code>; vedete cosa vi sembra giusto!</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bricks"><a class="header" href="#bricks">Bricks</a></h1>
<p>Up until this point our ball hasn’t done anything but bounce around, but now we’re going to make it destroy the bricks.</p>
<p>Before we start, let’s go over a new concept: constants.
We’ve already used some constants, like <code>rLCDC</code> from <code>hardware.inc</code>, but we can also create our own for anything we want.
Let’s make three constants at the top of our file, representing the tile IDs of left bricks, right bricks, and blank tiles.</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;hardware.inc&quot;

DEF BRICK_LEFT EQU $05
DEF BRICK_RIGHT EQU $06
DEF BLANK_TILE EQU $08
</code></pre>
<p>Constants are a kind of <em>symbol</em> (which is to say, “a thing with a name”).
Writing a constant’s name in an expression is equivalent to writing the number the constant is equal to, so <code>ld a, BRICK_LEFT</code> is the same as <code>ld a, $05</code>.
But I think we can all agree that the former is much clearer, right?</p>
<h2 id="destroying-bricks"><a class="header" href="#destroying-bricks">Destroying bricks</a></h2>
<p>Now we’ll write a function that checks for and destroys bricks.
Our bricks are two tiles wide, so when we hit one we’ll have to remove the adjacent tile as well.
If we hit the left side of a brick (represented by <code>BRICK_LEFT</code>), we need to remove it and the tile to its right (which should be the right side).
If we instead hit the right side, we need to remove the left!</p>
<pre><code class="language-rgbasm linenos start=285">; Checks if a brick was collided with and breaks it if possible.
; @param hl: address of tile.
CheckAndHandleBrick:
	ld a, [hl]
	cp a, BRICK_LEFT
	jr nz, CheckAndHandleBrickRight
	; Break a brick from the left side.
	ld [hl], BLANK_TILE
	inc hl
	ld [hl], BLANK_TILE
CheckAndHandleBrickRight:
	cp a, BRICK_RIGHT
	ret nz
	; Break a brick from the right side.
	ld [hl], BLANK_TILE
	dec hl
	ld [hl], BLANK_TILE
	ret
</code></pre>
<p>Just insert this function into each of your bounce checks now.
Make sure you don’t miss any!
It should go right <strong>before</strong> the momentum is modified.</p>
<pre><code class="language-diff linenos start=119">BounceOnTop:
	; Remember to offset the OAM position!
	; (8, 16) in OAM coordinates is (0, 0) on the screen.
	ld a, [_OAMRAM + 4]
	sub a, 16 + 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel ; Returns tile address in hl
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnRight
+	call CheckAndHandleBrick
	ld a, 1
	ld [wBallMomentumY], a

BounceOnRight:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 - 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnLeft
+	call CheckAndHandleBrick
	ld a, -1
	ld [wBallMomentumX], a

BounceOnLeft:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 + 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnBottom
+	call CheckAndHandleBrick
	ld a, 1
	ld [wBallMomentumX], a

BounceOnBottom:
	ld a, [_OAMRAM + 4]
	sub a, 16 - 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceDone
+	call CheckAndHandleBrick
	ld a, -1
	ld [wBallMomentumY], a
BounceDone:
</code></pre>
<p>Tutto qui!
Piuttosto semplice, no?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lavori-in-corso"><a class="header" href="#lavori-in-corso">Lavori in corso</a></h1>
<div class="box warning"><p class="box-title">🚧 🚧 🚧 🚧 🚧 🚧 🚧</p>
<p>Come spiegato nella presentazione iniziale del tutorial, la Parte Ⅱ consiste nella costruzione di un gioco <em>Arkanoid</em>.
Tuttavia, questo non è ancora finito; le lezioni vengono caricate man mano che vengono realizzate, quindi il tutorial si interrompe bruscamente a un certo punto.
Mi dispiace!</p>
<p>Tenete duro mentre ci lavoriamo, <a href="https://twitter.com/gbdev0">seguiteci su Twitter</a> per gli aggiornamenti e andate alla pagina successiva per scoprire cosa potete fare nel frattempo!</p>
<p>Grazie per la vostra pazienza 😊 e ci vediamo su GBDev!</p>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-galactic-armada"><a class="header" href="#introducing-galactic-armada">Introducing Galactic Armada</a></h1>
<img class="pixelated" src="part3/../assets/part3/img/rgbds-shmup-gameplay2.gif">
<p>This guide will help you create a classic shoot-em-up in RGBDS. This guide builds on knowledge from the previous tutorials, so some basic (or previously explained) concepts will not be explained.</p>
<h2 id="feature-set"><a class="header" href="#feature-set">Feature set</a></h2>
<p>Here’s a list of features that will be included in the final product.</p>
<ul>
<li>Vertical Scrolling Background</li>
<li>Basic HUD (via Window) &amp; Score</li>
<li>4-Directional Player Movement</li>
<li>Enemies</li>
<li>Bullets</li>
<li>Enemy/Bullet Collision</li>
<li>Enemy/Player Collision</li>
<li>Smooth Movement via Scaled Integers - Instead of using counters, smoother motion can be achieved using 16-bit (scaled) integers.</li>
<li>Multiple Game States: Title Screen, Gameplay, Story State</li>
<li>STAT Interrupts - used to properly draw the HUD at the top of gameplay.</li>
<li>RGBGFX &amp; INCBIN</li>
<li>Writing Text</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struttura-progetti"><a class="header" href="#struttura-progetti">Struttura progetti</a></h1>
<p>This page is going to give you an idea of how the Galactic Armada project is structured. This includes the folders, resources, tools, entry point, and compilation process.</p>
<p>The code can be found at <a href="https://github.com/gbdev/gb-asm-tutorial/tree/master/galactic-armada">https://github.com/gbdev/gb-asm-tutorial/tree/master/galactic-armada</a>.</p>
<h2 id="struttura-della-cartella"><a class="header" href="#struttura-della-cartella">Struttura della cartella</a></h2>
<p>For organizational purposes, many parts of the logic are separated into reusable functions. This is to reduce duplicate code, and make logic more clear.</p>
<p>Here’s a basic look at how the project is structured:</p>
<div class="box tip">
<p>Generated files should never be included in VCS repositories. It unneccessarily bloats the repo. The folders below marked with * contains assets generated from running the Makefile and are not included in the repository.</p>
</div>
<ul>
<li><code>libs</code> - Two assembly files for input and sprites are located here.</li>
<li><code>src</code>
<ul>
<li><code>generated</code> - the results of RGBGFX are stored here. *</li>
<li><code>resources</code> - Here exist some PNGs and Aseprite files for usage with RGBGFX</li>
<li><code>main</code> - All assembly files are located here, or in subfolders
<ul>
<li><code>states</code>
<ul>
<li><code>gameplay</code> - for gameplay related files
<ul>
<li><code>objects</code> - for gameplay objects like the player, bullets, and enemies
<ul>
<li>collision - for collision among objects</li>
</ul>
</li>
</ul>
</li>
<li><code>story</code> - for our story state’s related files</li>
<li><code>title-screen</code> - for our title screen’s related files</li>
</ul>
</li>
<li><code>utils</code> - Extra functions includes to assist with development
<ul>
<li><code>macros</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>dist</code> - The final ROM file will be created here. *</li>
<li><code>obj</code> - Intermediate files from the compile process. *</li>
<li><code>Makefile</code> - used to create the final ROM file and intermediate files</li>
</ul>
<h2 id="background--sprite-resources"><a class="header" href="#background--sprite-resources">Background &amp; Sprite Resources</a></h2>
<p>The following backgrounds and sprites are used in Galactic Armada:</p>
<ul>
<li>Backgrounds
<ul>
<li>Star Field</li>
<li>Title Screen</li>
<li>Text Font (Tiles only)</li>
</ul>
</li>
<li>Sprites
<ul>
<li>Enemy Ship</li>
<li>Player Ship</li>
<li>Bullet</li>
</ul>
</li>
</ul>
<img class="pixelated" src="part3/../assets/part3/img/star-field.png">
<img class="pixelated" src="part3/../assets/part3/img/title-screen.png">
<br>
<img class="pixelated" src="part3/../assets/part3/img/text-font.png" height="48px">
<br>
<img class="pixelated sprites" src="part3/../assets/part3/img/player-ship.png" height="48px">
<img class="pixelated sprites" src="part3/../assets/part3/img/enemy-ship.png" height="48px">
<img class="pixelated sprites" src="part3/../assets/part3/img/bullet.png" height="48x">
<p>These images were originally created in Aseprite. The original templates are also included in the repository. They were exported as a PNG <strong>with a specific color palette</strong>. Ater being exported as a PNG, when you run <code>make</code>, they are converted into <code>.2bpp</code> and <code>.tilemap</code> files via the RGBDS tool: RGBGFX.</p>
<blockquote>
<p>The <strong><code>rgbgfx</code></strong> program converts PNG images into data suitable for display on the Game Boy and Game Boy Color, or vice-versa.</p>
<p>The main function of <strong><code>rgbgfx</code></strong> is to divide the input PNG into 8×8 pixel <em><a href="https://rgbds.gbdev.io/docs/v0.6.1/rgbgfx.1#squares">squares</a></em>, convert each of those squares into 1bpp or 2bpp tile data, and save all of the tile data in a file. It also has options to generate a tile map, attribute map, and/or palette set as well; more on that and how the conversion process can be tweaked below.</p>
</blockquote>
<p>RGBGFX can be found here: <a href="https://rgbds.gbdev.io/docs/v0.6.1/rgbgfx.1">https://rgbds.gbdev.io/docs/v0.6.1/rgbgfx.1</a></p>
<p>We’ll use it to convert all of our graphics to .2bpp, and .tilemap formats (binary files)</p>
<pre><code class="language-bash linenos start=47">NEEDED_GRAPHICS = \
	$(GENSPRITES)/player-ship.2bpp \
	$(GENSPRITES)/enemy-ship.2bpp \
	$(GENSPRITES)/bullet.2bpp \
	$(GENBACKGROUNDS)/text-font.2bpp \
	$(GENBACKGROUNDS)/star-field.tilemap \
	$(GENBACKGROUNDS)/title-screen.tilemap

# Generate sprites, ensuring the containing directories have been created.
$(GENSPRITES)/%.2bpp: $(RESSPRITES)/%.png | $(GENSPRITES)
	$(GFX) -c &quot;#FFFFFF,#cfcfcf,#686868,#000000;&quot; --columns -o $@ $&lt;

# Generate background tile set, ensuring the containing directories have been created.
$(GENBACKGROUNDS)/%.2bpp: $(RESBACKGROUNDS)/%.png | $(GENBACKGROUNDS)
	$(GFX) -c &quot;#FFFFFF,#cbcbcb,#414141,#000000;&quot; -o $@ $&lt;

# Generate background tile map *and* tile set, ensuring the containing directories
# have been created.
$(GENBACKGROUNDS)/%.tilemap: $(RESBACKGROUNDS)/%.png | $(GENBACKGROUNDS)
	$(GFX) -c &quot;#FFFFFF,#cbcbcb,#414141,#000000;&quot; \
		--tilemap $@ \
		--unique-tiles \
		-o $(GENBACKGROUNDS)/$*.2bpp \
		$&lt;
</code></pre>
<p>From there, INCBIN commands are used to store reference the binary tile data.</p>
<pre><code class="language-rgbasm">; in src/main/states/gameplay/objects/player.asm
playerShipTileData: INCBIN &quot;src/generated/sprites/player-ship.2bpp&quot;
playerShipTileDataEnd:

; in src/main/states/gameplay/objects/enemies.asm
enemyShipTileData:: INCBIN &quot;src/generated/sprites/enemy-ship.2bpp&quot;
enemyShipTileDataEnd::

; in src/main/states/gameplay/objects/bullets.asm
bulletTileData:: INCBIN &quot;src/generated/sprites/bullet.2bpp&quot;
bulletTileDataEnd::
</code></pre>
<div class="box tip"><p class="box-title">Including binary files</p>
<p>You probably have some graphics, level data, etc. you’d like to include. Use <strong><code>INCBIN</code></strong> to include a raw binary file as it is. If the file isn’t found in the current directory, the include-path list passed to <a href="https://rgbds.gbdev.io/docs/v0.6.1/rgbasm.1">rgbasm(1)</a> (see the <strong><code>-i</code></strong> option) on the command line will be searched.</p>
<pre><code>INCBIN &quot;titlepic.bin&quot;
INCBIN &quot;sprites/hero.bin&quot;
</code></pre>
<p>You can also include only part of a file with <strong><code>INCBIN</code></strong>. The example below includes 256 bytes from data.bin, starting from byte 78.</p>
<pre><code>INCBIN &quot;data.bin&quot;,78,256
</code></pre>
<p>The length argument is optional. If only the start position is specified, the bytes from the start position until the end of the file will be included.</p>
<p>See also: <a href="https://rgbds.gbdev.io/docs/v0.6.1/rgbasm.5#Including_binary_files">Including binary files - RGBASM documentation</a></p>
</div>
<h2 id="compilazione"><a class="header" href="#compilazione">Compilazione</a></h2>
<p>Compilation is done via a Makefile. This Makefile can be run using the <code>make</code> command. Make should be preinstalled on Linux and Mac systems. For Windows users, check out <a href="https://www.cygwin.com/">cygwin</a>.</p>
<p>Without going over everything in detail, here’s what the Makefile does:</p>
<ul>
<li>Clean generated folders</li>
<li>Recreate generated folders</li>
<li>Convert PNGs in src/resources to <code>.2bpp</code>, and <code>.tilemap</code> formats</li>
<li>Convert <code>.asm</code> files to <code>.o</code></li>
<li>Use the <code>.o</code> files to build the ROM file</li>
<li>Apply the RGBDS “fix” utility.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punto-di-ingresso"><a class="header" href="#punto-di-ingresso">Punto di ingresso</a></h2>
<p>We’ll start this tutorial out like the previous, with our “header” section (at address: $100). We’re also going to declare some global variables that will be used throughout the game.</p>
<ul>
<li><code>wLastKeys</code> and <code>wCurKeys</code> are used for joypad input</li>
<li><code>wGameState</code> will keep track what our current game state is</li>
</ul>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;

SECTION &quot;GameVariables&quot;, WRAM0

wLastKeys:: db
wCurKeys:: db
wNewKeys:: db
wGameState::db

SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header

EntryPoint:
</code></pre>
<p>dopo l’etichetta <code>EntryPoint</code>, faremo quanto segue:</p>
<ul>
<li>set our default game state</li>
<li>initiate <a href="https://github.com/eievui5/gb-sprobj-lib">gb-sprobj-lib</a>, the sprite library we’re going to use</li>
<li>setup our display registers</li>
<li>load tile data for our font into VRAM.</li>
</ul>
<p>The tile data we are going to load is used by all game states, which is why we’ll do it here &amp; now, for them all to use.</p>
<img class="pixelated" src="part3/../assets/part3/img/text-font-large.png">
<p>This character-set is called “Area51”. It, and more 8x8 pixel fonts can ne found here: <a href="https://damieng.com/typography/zx-origins/">https://damieng.com/typography/zx-origins/</a> . These 52 tiles will be placed at the beginning of our background/window VRAM region.</p>
<p><img src="part3/../assets/part3/img/TextFontDiagram.png" alt="TextFontDiagram.png" /></p>
<p>One important thing to note. Character maps for each letter must be defined. This let’s RGBDS know what byte value to give a specific letter.</p>
<p>For the Galactic Armada space mapping, we’re going off the “text-font.png” image. Our space character is the first character in VRAM. Our alphabet starts at 26. Special additions could be added if desired. For now, this is all that we’ll need. We’ll define that map in “src/main/utils/macros/text-macros.inc”.</p>
<pre><code class="language-rgbasm linenos start=1">; The character map for the text-font 
CHARMAP &quot; &quot;, 0
CHARMAP &quot;.&quot;, 24
CHARMAP &quot;-&quot;, 25
CHARMAP &quot;a&quot;, 26
CHARMAP &quot;b&quot;, 27
CHARMAP &quot;c&quot;, 28
CHARMAP &quot;d&quot;, 29
CHARMAP &quot;e&quot;, 30
CHARMAP &quot;f&quot;, 31
CHARMAP &quot;g&quot;, 32
CHARMAP &quot;h&quot;, 33
CHARMAP &quot;i&quot;, 34
CHARMAP &quot;j&quot;, 35
CHARMAP &quot;k&quot;, 36
CHARMAP &quot;l&quot;, 37
CHARMAP &quot;m&quot;, 38
CHARMAP &quot;n&quot;, 39
CHARMAP &quot;o&quot;, 40
CHARMAP &quot;p&quot;, 41
CHARMAP &quot;q&quot;, 42
CHARMAP &quot;r&quot;, 43
CHARMAP &quot;s&quot;, 44
CHARMAP &quot;t&quot;, 45
CHARMAP &quot;u&quot;, 46
CHARMAP &quot;v&quot;, 47
CHARMAP &quot;w&quot;, 48
CHARMAP &quot;x&quot;, 49
CHARMAP &quot;y&quot;, 50
CHARMAP &quot;z&quot;, 51
</code></pre>
<p>Getting back to our entry point. Were going to wait until a vertical blank begins to do all of this. We’ll also turn the LCD off before loading our tile data into VRAM..</p>
<pre><code class="language-rgbasm linenos start=18">	; Shut down audio circuitry
	xor a
	ld [rNR52], a
	; We don't actually need another xor a here, because the value of A doesn't change between these two instructions
	ld [wGameState], a

	; Wait for the vertical blank phase before initiating the library
    call WaitForOneVBlank

	; from: https://github.com/eievui5/gb-sprobj-lib
	; The library is relatively simple to get set up. First, put the following in your initialization code:
	; Initilize Sprite Object Library.
	call InitSprObjLibWrapper

	; Turn the LCD off
	xor a
	ld [rLCDC], a

	; Load our common text font into VRAM
	call LoadTextFontIntoVRAM

	; Turn the LCD on
	ld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16 | LCDCF_WINON | LCDCF_WIN9C00
	ld [rLCDC], a

	; During the first (blank) frame, initialize display registers
	ld a, %11100100
	ld [rBGP], a
	ld [rOBP0], a

</code></pre>
<div class="box tip">
<p>Even though we haven’t specifically defined a color palette. The <a href="https://emulicious.net/">emulicious</a> emulator may automatically apply a default color palette if in “Automatic” or “Gameboy Color” mode.</p>
</div>
<div class="box tip">
<p>Instead of <code>ld a, 0</code>, we can use <code>xor a</code> to set <code>a</code> to 0. It takes one byte less, which matters a lot on the Game Boy.</p>
</div>
<p>In the above snippet you saw use of a function called <code>WaitFOrOneVBLank</code>. We’ve setup some vblank utility functions in the “src/main/utils/vblank-utils.asm” file:</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;

SECTION &quot;VBlankVariables&quot;, WRAM0

wVBlankCount:: db 

SECTION &quot;VBlankFunctions&quot;, ROM0

WaitForOneVBlank::

    ; Wait a small amount of time
    ; Save our count in this variable
    ld a, 1
    ld [wVBlankCount], a

WaitForVBlankFunction::

WaitForVBlankFunction_Loop::

	ld a, [rLY] ; Copy the vertical line to a
	cp 144 ; Check if the vertical line (in a) is 0
	jp c, WaitForVBlankFunction_Loop ; A conditional jump. The condition is that 'c' is set, the last operation overflowed

    ld a, [wVBlankCount]
    sub 1
    ld [wVBlankCount], a
    ret z

WaitForVBlankFunction_Loop2::

	ld a, [rLY] ; Copy the vertical line to a
	cp 144 ; Check if the vertical line (in a) is 0
	jp nc, WaitForVBlankFunction_Loop2 ; A conditional jump. The condition is that 'c' is set, the last operation overflowed

    jp WaitForVBlankFunction_Loop

</code></pre>
<p>In the next section, we’ll go on next to setup our <code>NextGameState</code> label. Which is used for changing game states.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changing-game-states"><a class="header" href="#changing-game-states">Changing Game States</a></h1>
<p>In our GalacticArmada.asm file, we’ll define label called “NextGameState”. Our game will have 3 game states:</p>
<ul>
<li>Title Screen</li>
<li>Story Screen</li>
<li>Gameplay</li>
</ul>
<p>Ecco come scorreranno:</p>
<p><img src="part3/../assets/part3/img/Game_States_Visualized.png" alt="Game States Visualized.png" /></p>
<p>When one game state wants to go to another, it will need to change our previously declared ‘wGameState’ variable and then jump to the “NextGameState” label. There are some common things we want to accomplish when changing game states:</p>
<p>(during a Vertical Blank)</p>
<ul>
<li>Turn off the LCD</li>
<li>Reset our Background &amp; Window positions</li>
<li>Clear the Background</li>
<li>Disable Interrupts</li>
<li>Clear All Sprites</li>
<li>Initiate our NEXT game state</li>
<li>Jump to our NEXT game state’s (looping) update logic</li>
</ul>
<blockquote>
<p>It will be the responsibility of the “init” function for each game state to turn the LCD back on.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=48">
NextGameState::

	; Do not turn the LCD off outside of VBlank
    call WaitForOneVBlank

	call ClearBackground


	; Turn the LCD off
	xor a
	ld [rLCDC], a

	ld [rSCX], a
	ld [rSCY], a
	ld [rWX], a
	ld [rWY], a
	; disable interrupts
	call DisableInterrupts
	
	; Clear all sprites
	call ClearAllSprites

	; Initiate the next state
	ld a, [wGameState]
	cp 2 ; 2 = Gameplay
	call z, InitGameplayState
	ld a, [wGameState]
	cp 1 ; 1 = Story
	call z, InitStoryState
	ld a, [wGameState]
	and a ; 0 = Menu
	call z, InitTitleScreenState

	; Update the next state
	ld a, [wGameState]
	cp 2 ; 2 = Gameplay
	jp z, UpdateGameplayState
	cp 1 ; 1 = Story
	jp z, UpdateStoryState
	jp UpdateTitleScreenState

</code></pre>
<p>The goal here is to ( as much as possible) give each new game state a <em>blank slate</em> to start with.</p>
<p>That’s it for the GalacticArmada.asm file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schermata-del-titolo"><a class="header" href="#schermata-del-titolo">Schermata del titolo</a></h1>
<p>The title screen shows a basic title image using the background and draws text asking the player to press A. Once the user presses A, it will go to the story screen.</p>
<img src="part3/../assets/part3/img/title-screen-large.png" class="pixelated">
<p>Our title screen has 3 pieces of data:</p>
<ul>
<li>The “Press A to play” text</li>
<li>The title screen tile data</li>
<li>The title screen tilemap</li>
</ul>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;
INCLUDE &quot;src/main/utils/macros/text-macros.inc&quot;

SECTION &quot;TitleScreenState&quot;, ROM0

PressPlayText::  db &quot;press a to play&quot;, 255
 
titleScreenTileData: INCBIN &quot;src/generated/backgrounds/title-screen.2bpp&quot;
titleScreenTileDataEnd:
 
titleScreenTileMap: INCBIN &quot;src/generated/backgrounds/title-screen.tilemap&quot;
titleScreenTileMapEnd:
</code></pre>
<h2 id="avvio-della-schermata-del-titolo"><a class="header" href="#avvio-della-schermata-del-titolo">Avvio della schermata del titolo</a></h2>
<p>In our title screen’s “InitTitleScreen” function, we’ll do the following:</p>
<ul>
<li>draw the title screen graphic</li>
<li>draw our “Press A to play”</li>
<li>turn on the LCD. </li>
</ul>
<p>Here is what our “InitTitleScreenState” function looks like</p>
<pre><code class="language-rgbasm linenos start=13">InitTitleScreenState::

	call DrawTitleScreen
	
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Draw the press play text
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Call Our function that draws text onto background/window tiles
    ld de, $99C3
    ld hl, PressPlayText
    call DrawTextTilesLoop

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Turn the LCD on
	ld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16
	ld [rLCDC], a

    ret
</code></pre>
<p>In order to draw text in our game, we’ve created a function called “DrawTextTilesLoop”. We’ll pass this function which tile to start on in <code>de</code>, and the address of our text in <code>hl</code>.</p>
<pre><code class="language-rgbasm linenos start=16">DrawTextTilesLoop::

    ; Check for the end of string character 255
    ld a, [hl]
    cp 255
    ret z

    ; Write the current character (in hl) to the address
    ; on the tilemap (in de)
    ld a, [hl]
    ld [de], a

    inc hl
    inc de

    ; move to the next character and next background tile
    jp DrawTextTilesLoop
</code></pre>
<p>The “DrawTitleScreen” function puts the tiles for our title screen graphic in VRAM, and draws its tilemap to the background:</p>
<blockquote>
<p><strong>NOTE:</strong> Because of the text font, we’ll add an offset of 52 to our tilemap tiles. We’ve created a function that adds the 52 offset, since we’ll need to do so more than once.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=36">DrawTitleScreen::
	
	; Copy the tile data
	ld de, titleScreenTileData ; de contains the address where data will be copied from;
	ld hl, $9340 ; hl contains the address where data will be copied to;
	ld bc, titleScreenTileDataEnd - titleScreenTileData ; bc contains how many bytes we have to copy.
	call CopyDEintoMemoryAtHL
	
	; Copy the tilemap
	ld de, titleScreenTileMap
	ld hl, $9800
	ld bc, titleScreenTileMapEnd - titleScreenTileMap
	jp CopyDEintoMemoryAtHL_With52Offset

</code></pre>
<p>The “CopyDEintoMemoryAtHL” and “CopyDEintoMemoryAtHL_With52Offset” functions are defined in “src/main/utils/memory-utils.asm”:</p>
<pre><code class="language-rgbasm linenos start=1">SECTION &quot;MemoryUtilsSection&quot;, ROM0

CopyDEintoMemoryAtHL::
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or c
	jp nz, CopyDEintoMemoryAtHL ; Jump to CopyTiles if the last operation had a non zero result.
	ret

CopyDEintoMemoryAtHL_With52Offset::
	ld a, [de]
    add a, 52 
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or c
	jp nz, CopyDEintoMemoryAtHL_With52Offset ; Jump to COpyTiles, if the z flag is not set. (the last operation had a non zero result)
	ret
</code></pre>
<h2 id="updating-the-title-screen"><a class="header" href="#updating-the-title-screen">Updating the Title Screen</a></h2>
<p>The title screen’s update logic is the simplest of the 3. All we are going to do is wait until the A button is pressed. Afterwards, we’ll go to the story screen game state.</p>
<pre><code class="language-rgbasm linenos start=51">UpdateTitleScreenState::

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Wait for A
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Save the passed value into the variable: mWaitKey
    ; The WaitForKeyFunction always checks against this vriable
    ld a, PADF_A
    ld [mWaitKey], a

    call WaitForKeyFunction

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ld a, 1
    ld [wGameState],a
    jp NextGameState
</code></pre>
<p>Our “WaitForKeyFunction” is defined in “src/main/utils/input-utils.asm”. We’ll poll for input and infinitely loop until the specified button is pressed down.</p>
<pre><code class="language-rgbasm linenos start=1">SECTION &quot;InputUtilsVariables&quot;, WRAM0

mWaitKey:: db

SECTION &quot;InputUtils&quot;, ROM0

WaitForKeyFunction::

    ; Save our original value
    push bc

	
WaitForKeyFunction_Loop:

	; save the keys last frame
	ld a, [wCurKeys]
	ld [wLastKeys], a
    
	; This is in input.asm
	; It's straight from: https://gbdev.io/gb-asm-tutorial/part2/input.html
	; In their words (paraphrased): reading player input for gameboy is NOT a trivial task
	; So it's best to use some tested code
    call Input

    
	ld a, [mWaitKey]
    ld b, a
	ld a, [wCurKeys]
    and b
    jp z, WaitForKeyFunction_NotPressed
    
	ld a, [wLastKeys]
    and b
    jp nz, WaitForKeyFunction_NotPressed

	; restore our original value
	pop bc

    ret


WaitForKeyFunction_NotPressed:

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Wait a small amount of time
    ; Save our count in this variable
    ld a, 1
    ld [wVBlankCount], a

    ; Call our function that performs the code
    call WaitForVBlankFunction
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    jp WaitForKeyFunction_Loop
</code></pre>
<p>That’s it for our title screen. Next up is our story screen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schermata-della-storia"><a class="header" href="#schermata-della-storia">Schermata della storia</a></h1>
<p>The story screen shows a basic story on 2 pages. Afterwards, it sends the player to the gameplay game state.</p>
<img src="part3/../assets/part3/img/GalacticArmada-1.png" class="pixelated" height="288px">
<img src="part3/../assets/part3/img/GalacticArmada-2.png" class="pixelated" height="288px">
<h2 id="initiating-up-the-story-screen"><a class="header" href="#initiating-up-the-story-screen">Initiating up the Story Screen</a></h2>
<p>In the <code>InitStoryState</code> we’ll just going to turn on the LCD. Most of the game state’s logic will occur in its update function.</p>
<div class="box tip">
<p>The text macros file is included so our story text has the proper character maps.</p>
</div>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;
INCLUDE &quot;src/main/utils/macros/text-macros.inc&quot;

SECTION &quot;StoryStateASM&quot;, ROM0

InitStoryState::

	; Turn the LCD on
	ld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16
	ld [rLCDC], a

    ret
</code></pre>
<h2 id="updating-the-story-screen"><a class="header" href="#updating-the-story-screen">Updating the Story Screen</a></h2>
<p>Here’s the data for our story screen. We have this defined just above our <code>UpdateStoryState</code> function:</p>
<pre><code class="language-rgbasm linenos start=14">Story: 
    .Line1 db &quot;the galatic empire&quot;, 255
    .Line2 db &quot;rules the galaxy&quot;, 255
    .Line3 db &quot;with an iron&quot;, 255
    .Line4 db &quot;fist.&quot;, 255
    .Line5 db &quot;the rebel force&quot;, 255
    .Line6 db &quot;remain hopeful of&quot;, 255
    .Line7 db &quot;freedoms light&quot;, 255
	
</code></pre>
<p>The story text is shown using a typewriter effect. This effect is done similarly to the “press a to play” text that was done before, but here we wait for 3 vertical blank phases between writing each letter, giving some additional delay.</p>
<blockquote>
<p>You could bind this to a variable and make it configurable via an options screen too!</p>
</blockquote>
<p>For this effect, we’ve defined a function in our “src/main/utils/text-utils.asm” file:</p>
<pre><code class="language-rgbasm linenos start=34">DrawText_WithTypewriterEffect::

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Wait a small amount of time
    ; Save our count in this variable
    ld a, 3
    ld [wVBlankCount], a

    ; Call our function that performs the code
    call WaitForVBlankFunction
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    
    ; Check for the end of string character 255
    ld a, [hl]
    cp 255
    ret z

    ; Write the current character (in hl) to the address
    ; on the tilemap (in de)
    ld a, [hl]
    ld [de], a

    ; move to the next character and next background tile
    inc hl
    inc de

    jp DrawText_WithTypewriterEffect
</code></pre>
<p>We’ll call the <code>DrawText_WithTypewriterEffect</code> function exactly how we called the <code>DrawTextTilesLoop</code> function. We’ll pass this function which tile to start on in de, and the address of our text in hl.</p>
<p>We’ll do that four times for the first page, and then wait for the A button to be pressed:</p>
<pre><code class="language-rgbasm linenos start=23">UpdateStoryState::

    ; Call Our function that typewrites text onto background/window tiles
    ld de, $9821
    ld hl, Story.Line1
    call DrawText_WithTypewriterEffect


    ; Call Our function that typewrites text onto background/window tiles
    ld de, $9861
    ld hl, Story.Line2
    call DrawText_WithTypewriterEffect


    ; Call Our function that typewrites text onto background/window tiles
    ld de, $98A1
    ld hl, Story.Line3
    call DrawText_WithTypewriterEffect


    ; Call Our function that typewrites text onto background/window tiles
    ld de, $98E1
    ld hl, Story.Line4
    call DrawText_WithTypewriterEffect

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Wait for A
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Save the passed value into the variable: mWaitKey
    ; The WaitForKeyFunction always checks against this vriable
    ld a, PADF_A
    ld [mWaitKey], a

    call WaitForKeyFunction
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

</code></pre>
<p>Once the user presses the A button, we want to show the second page. To avoid any lingering “leftover” letters, we’ll clear the background. All this function does is turn off the LCD, fill our background tilemap with the first tile, then turn back on the lcd. We’ve defined this function in the “src/main/utils/background.utils.asm” file:</p>
<pre><code class="language-rgbasm linenos start=1">include &quot;src/main/utils/hardware.inc&quot;

SECTION &quot;Background&quot;, ROM0

ClearBackground::

	; Turn the LCD off
	xor a
	ld [rLCDC], a

	ld bc, 1024
	ld hl, $9800

ClearBackgroundLoop:

	xor a
	ld [hli], a

	
	dec bc
	ld a, b
	or c

	jp nz, ClearBackgroundLoop


	; Turn the LCD on
	ld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16
	ld [rLCDC], a


	ret
</code></pre>
<p>Getting back to our Story Screen: After we’ve shown the first page and cleared the background, we’ll do the same thing for page 2:</p>
<pre><code class="language-rgbasm linenos start=65">    ; Call Our function that typewrites text onto background/window tiles
    ld de, $9821
    ld hl, Story.Line5
    call DrawText_WithTypewriterEffect


    ; Call Our function that typewrites text onto background/window tiles
    ld de, $9861
    ld hl, Story.Line6
    call DrawText_WithTypewriterEffect


    ; Call Our function that typewrites text onto background/window tiles
    ld de, $98A1
    ld hl, Story.Line7
    call DrawText_WithTypewriterEffect


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Wait for A
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Save the passed value into the variable: mWaitKey
    ; The WaitForKeyFunction always checks against this vriable
    ld a, PADF_A
    ld [mWaitKey], a

    call WaitForKeyFunction
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    
</code></pre>
<p>With our story full shown, we’re ready to move onto the next game state: Gameplay. We’ll end our <code>UpdateStoryState</code> function by updating our game state variable and jump back to the <code>NextGameState</code> label like previously discussed.</p>
<pre><code class="language-rgbasm linenos start=98">    ld a, 2
    ld [wGameState],a
    jp NextGameState
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gameplay-state"><a class="header" href="#gameplay-state">Gameplay State</a></h1>
<p>In this game state, the player will control a spaceship. Flying over a vertically scrolling space background. They’ll be able to freely move in 4 directions , and shoot oncoming alien ships. As alien ships are destroyed by bullets, the player’s score will increase.</p>
<p><img src="part3/../assets/part3/img/rgbds-shmup-gameplay.gif" alt="rgbds-shmup-gameplay.gif" /></p>
<p>Gameplay is the core chunk of the source code. It also took the most time to create. Because of such, this game state has to be split into multiple sub-pages. Each page will explain a different gameplay concept.</p>
<p>Our gameplay state defines the following data and variables:</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;
INCLUDE &quot;src/main/utils/macros/text-macros.inc&quot;

SECTION &quot;GameplayVariables&quot;, WRAM0

wScore:: ds 6
wLives:: db

SECTION &quot;GameplayState&quot;, ROM0

wScoreText::  db &quot;score&quot;, 255
wLivesText::  db &quot;lives&quot;, 255
</code></pre>
<p>For simplicity reasons, our score uses 6 bytes. Each byte repesents one digit in the score.</p>
<h2 id="initiating-the-gameplay-game-state"><a class="header" href="#initiating-the-gameplay-game-state">Initiating the Gameplay Game State:</a></h2>
<p>When gameplay starts we want to do all of the following:</p>
<ul>
<li>reset the player’s score to 0</li>
<li>reset the player’s lives to 3. </li>
<li>Initialize all of our gameplay elements ( background, player, bullets, and enemies)</li>
<li>Enable STAT interrupts for the HUD</li>
<li>Draw our “score” &amp; “lives”  on the HUD.</li>
<li>Reset the window’s position back to 7,0</li>
<li>Turn the LCD on with the window enabled at $9C00</li>
</ul>
<pre><code class="language-rgbasm linenos start=14">InitGameplayState::

	ld a, 3
	ld [wLives], a

	xor a
	ld [wScore], a
	ld [wScore+1], a
	ld [wScore+2], a
	ld [wScore+3], a
	ld [wScore+4], a
	ld [wScore+5], a

	call InitializeBackground
	call InitializePlayer
	call InitializeBullets
	call InitializeEnemies

	; Initiate STAT interrupts
	call InitStatInterrupts

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Call Our function that draws text onto background/window tiles
    ld de, $9c00
    ld hl, wScoreText
    call DrawTextTilesLoop

	; Call Our function that draws text onto background/window tiles
    ld de, $9c0d
    ld hl, wLivesText
    call DrawTextTilesLoop
	
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	call DrawScore
	call DrawLives

	ld a, 0
	ld [rWY], a

	ld a, 7
	ld [rWX], a

	; Turn the LCD on
	ld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16 | LCDCF_WINON | LCDCF_WIN9C00|LCDCF_BG9800
	ld [rLCDC], a

    ret
</code></pre>
<p>The initialization logic for our the background, the player, the enemies, the bullets will be explained in later pages. Every game state is responsible for turning the LCD back on. The gameplay game state needs to use the window layer, so we’ll make sure that’s enabled before we return.</p>
<h2 id="updating-the-gameplay-game-state"><a class="header" href="#updating-the-gameplay-game-state">Updating the Gameplay Game State</a></h2>
<p>Our “UpdateGameplayState” function doesn’t have very complicated logic. Most of the logic has been split into separate files for the background, player, enemies, and bullets.</p>
<p>During gameplay, we do all of the following:</p>
<ul>
<li>Poll for input</li>
<li>Reset our Shadow OAM</li>
<li>Reset our current shadow OAM sprite</li>
<li>Update our gameplay elements (player, background, enemies, bullets, background)</li>
<li>Remove any unused sprites from the screen</li>
<li>End gameplay if we’ve lost all of our lives</li>
<li>inside of the vertical blank phase
<ul>
<li>Apply shadow OAM sprites </li>
<li>Update our background tilemap’s position</li>
</ul>
</li>
</ul>
<p>We’ll poll for input like in the previous tutorial. We’ll always save the previous state of the gameboy’s buttons in the “wLastKeys” variable.</p>
<pre><code class="language-rgbasm linenos start=66">UpdateGameplayState::

	; save the keys last frame
	ld a, [wCurKeys]
	ld [wLastKeys], a

	; This is in input.asm
	; It's straight from: https://gbdev.io/gb-asm-tutorial/part2/input.html
	; In their words (paraphrased): reading player input for gameboy is NOT a trivial task
	; So it's best to use some tested code
    call Input
</code></pre>
<p>Next, we’ll reset our Shadow OAM and reset current Shadow OAM sprite address. </p>
<pre><code class="language-rgbasm linenos start=78">	; from: https://github.com/eievui5/gb-sprobj-lib
	; hen put a call to ResetShadowOAM at the beginning of your main loop.
	call ResetShadowOAM
	call ResetOAMSpriteAddress
</code></pre>
<p>Because we are going to be dealing with a lot of sprites on the screen, we will not be directly manipulating the gameboy’s OAM sprites. We’ll define a set of “shadow” (copy“) OAM sprites, that all objects will use instaed. At the end of the gameplay looop, we’ll copy the shadow OAM sprite objects into the hardware.</p>
<p>Each object will use a random shadow OAM sprite. We need a way to keep track of what shadow OAM sprite is being used currently. For this, we’ve created a 16-bit pointer called “wLastOAMAddress”. Defined in “src/main/utils/sprites.asm”, this points to the data for the next inactive shadow OAM sprite. </p>
<p>When we reset our current Shadow OAM sprite address, we just set the “mLastOAMAddress” RAM variable to point to the first shadow OAM sprite. </p>
<blockquote>
<p><strong>NOTE:</strong> We also keep a counter on how many shadow OAM sprites are used. In our “ResetOAMSpriteAddress” function, we’ll reset that counter too.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=61">ResetOAMSpriteAddress::
    
    xor a
    ld [wSpritesUsed], a

	ld a, LOW(wShadowOAM)
	ld [wLastOAMAddress], a
	ld a, HIGH(wShadowOAM)
	ld [wLastOAMAddress+1], a

    ret
</code></pre>
<p>Next we’ll update our gameplay elements:</p>
<pre><code class="language-rgbasm linenos start=83">	call UpdatePlayer
	call UpdateEnemies
	call UpdateBullets
	call UpdateBackground
</code></pre>
<p>After all of that, at this point in time, the majority of gameplay is done for this iteration. We’ll clear any remaining spirtes. This is very necessary becaus the number of active sprites changes from frame to frame. If there are any visible OAM sprites left onscreen, they will look weird and/or mislead the player. </p>
<pre><code class="language-rgbasm linenos start=88">	; Clear remaining sprites to avoid lingering rogue sprites
	call ClearRemainingSprites
</code></pre>
<p>The clear remaining sprites function, for all remaining shadow OAM sprites, moves the sprite offscreen so they are no longer visible. This function starts at wherever the “wLastOAMAddress” variable last left-off.</p>
<h4 id="end-of-the-gameplay-loop"><a class="header" href="#end-of-the-gameplay-loop">End of The Gameplay loop</a></h4>
<p>At this point in time, we need to check if gameplay needs to continue. When the vertical blank phase starts, we check if the player has lost all of their lives. If so, we end gameplay. We end gameplay similar to how we started it, we’ll update our ‘wGameState’ variable and jump to “NextGameState”.</p>
<p>If the player hasn’t lost all of their lives, we’ll copy our shadow OAM sprites over to the actual hardware OAM sprites and loop background.</p>
<pre><code class="language-rgbasm linenos start=91">	ld a, [wLives]
	cp 250
	jp nc, EndGameplay

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Call our function that performs the code
    call WaitForOneVBlank
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; from: https://github.com/eievui5/gb-sprobj-lib
	; Finally, run the following code during VBlank:
	ld a, HIGH(wShadowOAM)
	call hOAMDMA

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Call our function that performs the code
    call WaitForOneVBlank
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	jp UpdateGameplayState

EndGameplay:
	
    ld a, 0
    ld [wGameState],a
    jp NextGameState
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scrolling-background"><a class="header" href="#scrolling-background">Scrolling Background</a></h1>
<p>Scrolling the background is an easy task. However, for a SMOOTH slow scrolling background: scaled integers<sup class="footnote-reference"><a href="#1">1</a></sup> will be used.</p>
<blockquote>
<p>⚠️ Scaled Integers<sup class="footnote-reference"><a href="#1">1</a></sup> are a way to provide smooth “sub-pixel” movement. They are slightly more difficult to understand &amp; implement than implementing a counter, but they provide smoother motion.</p>
</blockquote>
<h2 id="initializing-the-background"><a class="header" href="#initializing-the-background">Initializing the Background</a></h2>
<p>At the start of the gameplay game state we called the initialize background function. This function shows the star field background, and resets our background scroll variables:</p>
<blockquote>
<p>Just like with our title screen graphic, because our text font tiles are at the beginning of VRAM: we offset the tilemap values by 52</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;src/main/utils/hardware.inc&quot;
INCLUDE &quot;src/main/utils/macros/text-macros.inc&quot;

SECTION &quot;BackgroundVariables&quot;, WRAM0

mBackgroundScroll:: dw

SECTION &quot;GameplayBackgroundSection&quot;, ROM0

starFieldMap: INCBIN &quot;src/generated/backgrounds/star-field.tilemap&quot;
starFieldMapEnd:
 
starFieldTileData: INCBIN &quot;src/generated/backgrounds/star-field.2bpp&quot;
starFieldTileDataEnd:

InitializeBackground::

	; Copy the tile data
	ld de, starFieldTileData ; de contains the address where data will be copied from;
	ld hl, $9340 ; hl contains the address where data will be copied to;
	ld bc, starFieldTileDataEnd - starFieldTileData ; bc contains how many bytes we have to copy.
    call CopyDEintoMemoryAtHL

	; Copy the tilemap
	ld de, starFieldMap
	ld hl, $9800
	ld bc, starFieldMapEnd - starFieldMap
    call CopyDEintoMemoryAtHL_With52Offset

	xor a
	ld [mBackgroundScroll], a
	ld [mBackgroundScroll+1], a
	ret
</code></pre>
<p>To scroll the background in a gameboy game, we simply need to gradually change the <code>SCX</code> or <code>SCX</code> registers. Our code is a tiny bit more complicated because of scaled integer usage. Our background’s scroll position is stored in a 16-bit integer called <code>mBackgroundScroll</code>. We’l increase that 16-bit integer by a set amount.</p>
<pre><code class="language-rgbasm linenos start=35">; This is called during gameplay state on every frame
UpdateBackground::

	; Increase our scaled integer by 5
	; Get our true (non-scaled) value, and save it for later usage in bc
	ld a, [mBackgroundScroll]
	add a, 5
    ld b, a
	ld [mBackgroundScroll], a
	ld a, [mBackgroundScroll+1]
	adc 0
    ld c, a
	ld [mBackgroundScroll+1], a
</code></pre>
<p>We won’t directly draw the background using this value. De-scaling a scaled integer simulates having a (more precise and useful for smooth movement) floating-point number. The value we draw our background at will be the de-scaled version of that 16-bit integer. To get that non-scaled version, we’ll simply shift all of it’s bit rightward 4 places. The final result will saved for when we update our background’s y position.</p>
<pre><code class="language-rgbasm linenos start=49">    ; Descale our scaled integer 
    ; shift bits to the right 4 spaces
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b

    ; Use the de-scaled low byte as the backgrounds position
    ld a, b
	ld [rSCY], a
	ret
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/Scale_factor_(computer_science)">Scaled Factor on Wikipedia</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heads-up-interface"><a class="header" href="#heads-up-interface">Heads Up Interface</a></h1>
<p>The gameboy normally draws sprites over both the window and background, and the window over the background. In Galactic Armada, The background is vertically scrolling. This means the HUD (the score text and number) needs to be draw on the window, which is separate from the background. </p>
<p>On our HUD, we’ll draw both our score and our lives. We’ll also use STAT interrupts to make sure nothing covers the HUD.</p>
<h2 id="stat-interrupts--the-window"><a class="header" href="#stat-interrupts--the-window">STAT Interrupts &amp; the window</a></h2>
<p>The window is not enabled by default. We can enable the window using the <code>LCDC</code> register. RGBDS comes with constants that will help us. </p>
<blockquote>
<p>⚠️ NOTE: The window can essentially be a copy of the background. The <code>LCDCF_WIN9C00|LCDCF_BG9800</code> portion makes the background and window use different tilemaps when drawn.
There’s only one problem. Since the window is drawn between sprites and the background. Without any extra effort, our scrolling background tilemap will be covered by our window. In addition, our sprites will be drawn over our hud. For this, we’ll need STAT interrupts. Fore more information on STAT interrupts, check out the pandocs: <a href="https://gbdev.io/pandocs/Interrupt_Sources.html">https://gbdev.io/pandocs/Interrupt_Sources.html</a></p>
</blockquote>
<p><img src="part3/../assets/part3/img/StatInterruptsVisualized.png" alt="InterruptsDiagram.png" /></p>
<blockquote>
<h3 id="using-the-stat-interrupt"><a class="header" href="#using-the-stat-interrupt"><strong><a href="https://gbdev.io/pandocs/Interrupt_Sources.html#using-the-stat-interrupt">Using the STAT interrupt</a></strong></a></h3>
<p>One very popular use is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to <a href="https://github.com/gb-archive/DeadCScroll">perform special video effects</a>.</p>
<p>Example application: set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box.</p>
</blockquote>
<p>With STAT interrupts, we can implement raster effects. in our case, we’ll enable the window and stop drawing sprites on the first 8 scanlines. Afterwards, we’ll show sprites and disable the window layer for the remaining scanlines. This makes sure nothing overlaps our HUD, and that our background is fully shown also.</p>
<h3 id="initiating--disabling-stat-interrupts"><a class="header" href="#initiating--disabling-stat-interrupts">Initiating &amp; Disabling STAT interrupts</a></h3>
<p>In our gameplay game state, at different points in time, we initialized and disabled interrupts. Here’s the logic for those functions in our “src/main/states/gameplay/hud.asm” file:</p>
<pre><code class="language-rgbasm linenos start=2">INCLUDE &quot;src/main/utils/hardware.inc&quot;

 SECTION &quot;Interrupts&quot;, ROM0

 DisableInterrupts::
	xor a
	ldh [rSTAT], a
	di
	ret

InitStatInterrupts::

    ld a, IEF_STAT
	ldh [rIE], a
	xor a
	ldh [rIF], a
	ei

	; This makes our stat interrupts occur when the current scanline is equal to the rLYC register
	ld a, STATF_LYC
	ldh [rSTAT], a

	; We'll start with the first scanline
	; The first stat interrupt will call the next time rLY = 0
	xor a
	ldh [rLYC], a

    ret
</code></pre>
<h3 id="defining-stat-interrupts"><a class="header" href="#defining-stat-interrupts">Defining STAT interrupts</a></h3>
<p>Our actual STAT interrupts must be located at $0048. We’ll define different paths depending on what our LYC variable’s value is when executed.</p>
<pre><code class="language-rgbasm linenos start=31">; Define a new section and hard-code it to be at $0048.
SECTION &quot;Stat Interrupt&quot;, ROM0[$0048]
StatInterrupt:

	push af

	; Check if we are on the first scanline
	ldh a, [rLYC]
	and a
	jp z, LYCEqualsZero

LYCEquals8:

	; Don't call the next stat interrupt until scanline 8
	xor a
	ldh [rLYC], a

	; Turn the LCD on including sprites. But no window
	ld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJON | LCDCF_OBJ16 | LCDCF_WINOFF | LCDCF_WIN9C00
	ldh [rLCDC], a

	jp EndStatInterrupts

LYCEqualsZero:

	; Don't call the next stat interrupt until scanline 8
	ld a, 8
	ldh [rLYC], a

	; Turn the LCD on including the window. But no sprites
	ld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJOFF | LCDCF_OBJ16| LCDCF_WINON | LCDCF_WIN9C00
	ldh [rLCDC], a


EndStatInterrupts:

	pop af

	reti;
</code></pre>
<p>That should be all it takes to get a properly drawn HUD. For more details, check out the code in the repo or <a href="https://gbdev.io/gb-asm-tutorial/help-feedback.html">ask questions</a> on the gbdev discord server.</p>
<h2 id="keeping-score-and-drawing-score-on-the-hud"><a class="header" href="#keeping-score-and-drawing-score-on-the-hud">Keeping Score and Drawing Score on the HUD</a></h2>
<p>To keep things simple, back in our gameplay game state, we used 6 different bytes to hold our score.Each byte will hold a value between 0 and 9, and represents a specific digit in the score. So it’s easy to loop through and edit the score number on the HUD: The First byte represents the left-most digit, and the last byte represents the right-most digit. </p>
<p><img src="part3/../assets/part3/img/DrawingScoreVisualized.png" alt="DrawingScoreVisualized.png" /></p>
<p>When the score increases, we’ll increase digits on the right. As they go higher than 9, we’ll reset back to 0 and increase the previous byte .</p>
<pre><code class="language-rgbasm linenos start=6">IncreaseScore::

    ; We have 6 digits, start with the right-most digit (the last byte)
    ld c, 0
    ld hl, wScore+5

IncreaseScore_Loop:

    ; Increase the digit 
    ld a, [hl]
    inc a
    ld [hl], a

    ; Stop if it hasn't gone past 0
    cp 9
    ret c

; If it HAS gone past 9
IncreaseScore_Next:

    ; Increase a counter so we can not go out of our scores bounds
    inc c
    ld a, c

    ; Check if we've gone over our scores bounds
    cp 6
    ret z

    ; Reset the current digit to zero
    ; Then go to the previous byte (visually: to the left)
    ld a, 0
    ld [hl], a
    ld [hld], a

    jp IncreaseScore_Loop
</code></pre>
<p>We can call that score whenever a bullet hits an enemy. This function however does not draw our score on the background. We do that the same way we drew text previously:</p>
<pre><code class="language-rgbasm linenos start=54">DrawScore::

    ; Our score has max 6 digits
    ; We'll start with the left-most digit (visually) which is also the first byte
    ld c, 6
    ld hl, wScore
    ld de, $9C06 ; The window tilemap starts at $9C00

DrawScore_Loop:

    ld a, [hli]
    add 10 ; our numeric tiles start at tile 10, so add to 10 to each bytes value
    ld [de], a

    ; Decrease how many numbers we have drawn
    dec c
		
    ; Stop when we've drawn all the numbers
    ret z

    ; Increase which tile we are drawing to
    inc de

    jp DrawScore_Loop
</code></pre>
<p>Because we’ll only ever have 3 lives, drawing our lives is much easier. The numeric characters in our text font start at 10, so  we just need to put on the window, our lives plus 10.</p>
<pre><code class="language-rgbasm linenos start=43">DrawLives::

    ld hl, wLives
    ld de, $9C13 ; The window tilemap starts at $9C00

    ld a, [hl]
    add 10 ; our numeric tiles start at tile 10, so add 10 to each bytes value
    ld [de], a

    ret
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprites--metasprites"><a class="header" href="#sprites--metasprites">Sprites &amp; Metasprites</a></h1>
<p>Before we dive into the player, bullets, and enemies; how they are drawn using metasprites should be explained.</p>
<p>For sprites, the following library is used:  https://github.com/eievui5/gb-sprobj-lib</p>
<blockquote>
<p>This is a small, lightweight library meant to facilitate the rendering of sprite objects, including Shadow OAM and OAM DMA, single-entry “simple” sprite objects, and Q12.4 fixed-point position metasprite rendering.</p>
</blockquote>
<p>All objects are drawn using “metasprites”, or groups of sprites that define one single object. A custom “metasprite” implementation is used in addition. Metasprite definitions should a multiple of 4 plus one additional byte for the end.</p>
<ul>
<li>Relative Y offset ( relative to the previous sprite, or the actual metasprite’s draw position)</li>
<li>Relative X offset ( relative to the previous sprite, or the actual metasprite’s draw position)</li>
<li>Tile to draw</li>
<li>Tile Props (not used in this project)</li>
</ul>
<p>The logic stops drawing when it reads 128. </p>
<p>An example of metasprite is the enemy ship:</p>
<pre><code class="language-rgbasm linenos start=24">enemyShipMetasprite::
    .metasprite1    db 0,0,4,0
    .metasprite2    db 0,8,6,0
    .metaspriteEnd  db 128
</code></pre>
<p><img src="part3/../assets/part3/img/MetaspriteDIagram.png" alt="MetaspriteDIagram.png" /></p>
<p>The Previous snippet draws two sprites. One that the object’s actual position, which uses tile 4 and 5. The second sprite is 8 pixels to the right, and uses tile 6 and 7</p>
<blockquote>
<p>⚠️ <strong>NOTE</strong>: Sprites are in 8x16 mode for this project.</p>
</blockquote>
<p>I can later draw such metasprite by calling the “DrawMetasprite” function that</p>
<pre><code class="language-rgbasm linenos start=251">
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; call the 'DrawMetasprites function. setup variables and call
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Save the address of the metasprite into the 'wMetaspriteAddress' variable
    ; Our DrawMetasprites functoin uses that variable
    ld a, LOW(enemyShipMetasprite)
    ld [wMetaspriteAddress+0], a
    ld a, HIGH(enemyShipMetasprite)
    ld [wMetaspriteAddress+1], a

    ; Save the x position
    ld a, [wCurrentEnemyX]
    ld [wMetaspriteX], a

    ; Save the y position
    ld a, [wCurrentEnemyY]
    ld [wMetaspriteY], a

    ; Actually call the 'DrawMetasprites function
    call DrawMetasprites

</code></pre>
<p>We previously mentioned a variable called “wLastOAMAddress”. The “DrawMetasprites” function can be found in the “src/main/utils/metasprites.asm” file:</p>
<pre><code class="language-rgbasm linenos start=1">
include &quot;src/main/utils/constants.inc&quot;
SECTION &quot;MetaSpriteVariables&quot;, WRAM0

wMetaspriteAddress:: dw
wMetaspriteX:: db
wMetaspriteY::db

SECTION &quot;MetaSprites&quot;, ROM0

DrawMetasprites::


    ; get the metasprite address
    ld a, [wMetaspriteAddress+0]
    ld l, a
    ld a, [wMetaspriteAddress+1]
    ld h, a

    ; Get the y position
    ld a, [hli]
    ld b, a

    ; stop if the y position is 128 
    ld a, b
    cp 128
    ret z

    ld a, [wMetaspriteY]
    add b
    ld [wMetaspriteY], a

    ; Get the x position
    ld a, [hli]
    ld c, a

    ld a, [wMetaspriteX]
    add c
    ld [wMetaspriteX], a

    ; Get the tile position
    ld a, [hli]
    ld d, a

    ; Get the flag position
    ld a, [hli]
    ld e, a
    

    ; Get our offset address in hl
	ld a,[wLastOAMAddress+0]
    ld l, a
	ld a, HIGH(wShadowOAM)
    ld h, a

    ld a, [wMetaspriteY]
    ld [hli], a

    ld a, [wMetaspriteX]
    ld [hli], a

    ld a, d
    ld [hli], a

    ld a, e
    ld [hli], a

    call NextOAMSprite

     ; increase the wMetaspriteAddress
    ld a, [wMetaspriteAddress]
    add a, METASPRITE_BYTES_COUNT
    ld [wMetaspriteAddress], a
    ld a, [wMetaspriteAddress+1]
    adc 0
    ld [wMetaspriteAddress+1], a


    jp DrawMetasprites
</code></pre>
<p>When we call the “DrawMetasprites” function, the “wLastOAMAddress” variable will be advanced  to point at the next available shadow OAM sprite. This is done using the “NextOAMSprite” function in “src/main/utils/sprites-utils.asm”</p>
<pre><code class="language-rgbasm linenos start=73">NextOAMSprite::

    ld a, [wSpritesUsed]
    inc a
    ld [wSpritesUsed], a

	ld a,[wLastOAMAddress]
    add sizeof_OAM_ATTRS
	ld [wLastOAMAddress], a
	ld a, HIGH(wShadowOAM)
	ld [wLastOAMAddress+1], a


    ret
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-pools"><a class="header" href="#object-pools">Object Pools</a></h1>
<p>Galactic Armada will use “object pools” for bullets and enemies. A fixed amount of bytes representing a specific maximum amount of objects. Each pool is just a collection of bytes. The number of bytes per “pool” is the maximum number of objects in the pool, times the number of bytes needed for data for each object.</p>
<p>Constants are also created for the size of each object, and what each byte is. These constants are in the “src/main/utils/constants.inc” file and utilize RGBDS offset constants (a really cool feature)</p>
<pre><code class="language-rgbasm linenos start=28">; from https://rgbds.gbdev.io/docs/v0.6.1/rgbasm.5#EXPRESSIONS
; The RS group of commands is a handy way of defining structure offsets:
RSRESET
DEF bullet_activeByte            RB   1
DEF bullet_xByte                 RB   1
DEF bullet_yLowByte              RB   1
DEF bullet_yHighByte             RB   1
DEF PER_BULLET_BYTES_COUNT       RB   0
</code></pre>
<p>The two object types that we need to loop through are Enemies and Bullets.</p>
<p><strong>Bytes for an Enemy:</strong></p>
<ol>
<li>Active - Are they active</li>
<li>X - Position: horizontal coordinate</li>
<li>Y (low) - The lower byte of their 16-bit (scaled) y position</li>
<li>Y (high) - The higher byte of their 16-bit (scaled) y position</li>
<li>Speed - How fast they move</li>
<li>Health - How many bullets they can take</li>
</ol>
<pre><code class="language-rgbasm linenos start=15">; Bytes: active, x , y (low), y (high), speed, health
wEnemies:: ds MAX_ENEMY_COUNT*PER_ENEMY_BYTES_COUNT

</code></pre>
<p><img src="part3/../assets/part3/img/EnemyBytesVisualized.png" alt="EnemyBytesVisualized.png" /></p>
<p><strong>Bytes for a Bullet:</strong></p>
<ol>
<li>Active - Are they active</li>
<li>X - Position: horizontal coordinate</li>
<li>Y (low) - The lower byte of their 16-bit (scaled) y position</li>
<li>Y (high) - The higher byte of their 16-bit (scaled) y position</li>
</ol>
<pre><code class="language-rgbasm linenos start=15">
; Bytes: active, x , y (low), y (high)
wBullets:: ds MAX_BULLET_COUNT*PER_BULLET_BYTES_COUNT

</code></pre>
<p><img src="part3/../assets/part3/img/BulletBytesVisualized.png" alt="BulletBytesVisualized.png" /></p>
<blockquote>
<p>⚠️ <strong>NOTE:</strong> Scaled integers are used for only the y positions of bullets and enemies. Scaled Integers are a way to provide smooth “sub-pixel” movement. They only move vertically, so the x position can be 8-bit.</p>
</blockquote>
<p>When looping through an object pool, we’ll check if an object is active. If it’s active, we’ll run the logic for that object. Otherwise, we’ll skip to the start of the next object’s bytes. </p>
<p>Both bullets and enemies do similar things. They move vertically until they are off the screen. In addition, enemies will check against bullets when updating. If they are found to be colliding, the bullet is destroyed and so is the enemy.</p>
<h1 id="activating-a-pooled-object"><a class="header" href="#activating-a-pooled-object">“Activating” a pooled object</a></h1>
<p>To Activate a pooled object, we simply loop through each object. If the first byte, which tells us if it’s active or not, is 0: then we’ll add the new item at that location and set that byte to be 1. If we loop through all possible objects and nothing is inactive, nothing happens.</p>
<p><img src="part3/../assets/part3/img/Spawning_Enemies.png" alt="Spawning Enemies.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-player"><a class="header" href="#the-player">The Player</a></h1>
<p>The player’s logic is pretty simple. The player can move in 4 directions and fire bullets. We update the player by checking our input directions and the A button. We’ll move in the proper direction if its associated d-pad button is pressed. If the A button is pressed, we’ll spawn a new bullet at the player’s position.</p>
<p>Our player will have 3 variables:</p>
<ul>
<li>wePlayerPositionX - a 16-bit scaled integer</li>
<li>wePlayerPositionY - a 16-bit scaled integer</li>
<li>wPlayerFlash - a 16-bit integer used when the player gets damaged</li>
</ul>
<blockquote>
<p>⚠️ <strong>NOTE</strong>: The player can move vertically AND horizontally. So, unlike bullets and enemies, it’s x position is a 16-bit scaled integer.</p>
</blockquote>
<p>These are declared at the top of the “src/main/states/gameplay/objects/player.asm” file</p>
<pre><code class="language-rgbasm linenos start=1">include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/constants.inc&quot;

SECTION &quot;PlayerVariables&quot;, WRAM0

; first byte is low, second is high (little endian)
wPlayerPositionX:: dw
wPlayerPositionY:: dw

mPlayerFlash: dw
</code></pre>
<p>Well draw our player, a simple ship, using the previously discussed metasprites implementation. Here is what we have for the players metasprites and tile data:</p>
<pre><code class="language-rgbasm linenos start=12">SECTION &quot;Player&quot;, ROM0

playerShipTileData: INCBIN &quot;src/generated/sprites/player-ship.2bpp&quot;
playerShipTileDataEnd:

playerTestMetaSprite::
    .metasprite1    db 0,0,0,0
    .metasprite2    db 0,8,2,0
    .metaspriteEnd  db 128
</code></pre>
<h2 id="initializing-the-player"><a class="header" href="#initializing-the-player">Initializing the Player</a></h2>
<p>Initializing the player is pretty simple. Here’s a list of things we need to do:</p>
<ul>
<li>Reset oir wPlayerFlash variable</li>
<li>Reset our wPlayerPositionX variable</li>
<li>Reset our wPlayerPositionU variable</li>
<li>Copy the player’s ship into VRAM</li>
</ul>
<p>We’ll use a constant we declared in “src/main/utils/constants.inc” to copy the player ship’s tile data into VRAM. Our enemy ship and player ship both have 4 tiles (16 bytes for each tile). In the snippet below, we can define where we’ll place the tile data in VRAM relative to the _VRAM constant:</p>
<pre><code class="language-rgbasm linenos start=37">RSRESET
DEF spriteTilesStart            RB _VRAM
DEF PLAYER_TILES_START          RB 4*16
DEF ENEMY_TILES_START           RB 4*16
DEF BULLET_TILES_START          RB 0
</code></pre>
<p>Here’s what our “InitializePlayer” function looks like. Recall, this was called when initiating the gameplay game state:</p>
<pre><code class="language-rgbasm linenos start=22">InitializePlayer::

    xor a
    ld [mPlayerFlash], a
    ld [mPlayerFlash+1], a

    ; Place in the middle of the screen
    xor a
    ld [wPlayerPositionX], a
    ld [wPlayerPositionY], a

    ld a, 5
    ld [wPlayerPositionX+1], a
    ld [wPlayerPositionY+1], a

    
CopyPlayerTileDataIntoVRAM:
    ; Copy the player's tile data into VRAM
	ld de, playerShipTileData
	ld hl, PLAYER_TILES_START
	ld bc, playerShipTileDataEnd - playerShipTileData
    call CopyDEintoMemoryAtHL

    ret
</code></pre>
<h2 id="updating-the-player"><a class="header" href="#updating-the-player">Updating the Player</a></h2>
<p>We can break our player’s update logic into 2 parts:</p>
<ul>
<li>Check for joypad input,  move with the d-pad, shoot with A</li>
<li>Depending on our “wPlayerFlash” variable: Draw our metasprites at our location</li>
</ul>
<p>Checking the joypad is done like the previous tutorials, we’ll perform bitwise “and” operations with constants for each d-pad direction.</p>
<pre><code class="language-rgbasm linenos start=47">UpdatePlayer::

UpdatePlayer_HandleInput:

	ld a, [wCurKeys]
	and PADF_UP
	call nz, MoveUp

	ld a, [wCurKeys]
	and PADF_DOWN
	call nz, MoveDown

	ld a, [wCurKeys]
	and PADF_LEFT
	call nz, MoveLeft

	ld a, [wCurKeys]
	and PADF_RIGHT
	call nz, MoveRight

	ld a, [wCurKeys]
	and PADF_A
	call nz, TryShoot
</code></pre>
<p>For player movement, our X &amp; Y are 16-bit integers. These both require two bytes. There is a little endian ordering, the first byte will be the low byte. The second byte will be the high byte. To increase/decrease these values, we add/subtract our change amount to/from the low byte. Then afterwards, we add/subtract the remainder of that operation to/from the high byte.</p>
<pre><code class="language-rgbasm linenos start=211">MoveUp:

    ; decrease the player's y position
    ld a, [wPlayerPositionY]
    sub PLAYER_MOVE_SPEED
    ld [wPlayerPositionY], a

    ld a, [wPlayerPositionY]
    sbc 0
    ld [wPlayerPositionY], a

    ret

MoveDown:

    ; increase the player's y position
    ld a, [wPlayerPositionY]
    add PLAYER_MOVE_SPEED
    ld [wPlayerPositionY], a

    ld a, [wPlayerPositionY+1]
    adc 0
    ld [wPlayerPositionY+1], a

    ret

MoveLeft:

    ; decrease the player's x position
    ld a, [wPlayerPositionX]
    sub PLAYER_MOVE_SPEED
    ld [wPlayerPositionX], a

    ld a, [wPlayerPositionX+1]
    sbc 0
    ld [wPlayerPositionX+1], a
    ret

MoveRight:

    ; increase the player's x position
    ld a, [wPlayerPositionX]
    add PLAYER_MOVE_SPEED
    ld [wPlayerPositionX], a

    ld a, [wPlayerPositionX+1]
    adc 0
    ld [wPlayerPositionX+1], a

    ret
</code></pre>
<p>When the player wants to shoot, we first check if the A button previously was down. If it was, we won’t shoot a new bullet. This avoids bullet spamming a little. For spawning bullets, we have a function called “FireNextBullet”. This function will need the new bullet’s 8-bit X coordinate and 16-bit Y coordinate, both set in a variable it uses called “wNextBullet”</p>
<pre><code class="language-rgbasm linenos start=189">TryShoot:
	ld a, [wLastKeys]
	and PADF_A
    ret nz

    jp FireNextBullet
</code></pre>
<p>After we’ve potentially moved the player and/or shot a new bullet. We need to draw our player. However, to create the “flashing” effect when damaged, we’ll conditionally NOT draw our player sprite. We do this based on the “wPlayerFlash” variable.</p>
<ul>
<li>If the “wPlayerFlash” variable is 0, the player is not damaged, we’ll skip to drawing our player sprite.</li>
<li>Otherwise, decrease the “wPlayerFlash” variable by 5.
<ul>
<li>We’ll shift all the bits of the “wPlayerFlash” variable to the right 4 times</li>
<li>If the result is less than 5, we’ll stop flashing and draw our player metasprite.</li>
<li>Otherwise, if the first bit of the decscaled “wPlayerFLash” variable is 1, we’ll skip drawing the player.</li>
</ul>
</li>
</ul>
<blockquote>
<p>*<strong>NOTE:</strong> The following resumes from where the “UpdatePlayer_HandleInput” label ended above.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=72">    ld a, [mPlayerFlash+0]
    ld b, a

    ld a, [mPlayerFlash+1]
    ld c, a

UpdatePlayer_UpdateSprite_CheckFlashing:

    ld a, b
    or c
    jp z, UpdatePlayer_UpdateSprite

    ; decrease bc by 5
    ld a, b
    sub 5
    ld b, a
    ld a, c
    sbc 0
    ld c, a
    

UpdatePlayer_UpdateSprite_DecreaseFlashing:

    ld a, b
    ld [mPlayerFlash], a
    ld a, c
    ld [mPlayerFlash+1], a

    ; descale bc
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b

    ld a, b
    cp 5
    jp c, UpdatePlayer_UpdateSprite_StopFlashing


    bit 0, b
    jp z, UpdatePlayer_UpdateSprite

UpdatePlayer_UpdateSprite_Flashing:

    ret
UpdatePlayer_UpdateSprite_StopFlashing:

    xor a
    ld [mPlayerFlash],a
    ld [mPlayerFlash+1],a
</code></pre>
<p>If we get past all of the “wPlayerFlash” logic, we’ll draw our player using the “DrawMetasprite” function we previously discussed.</p>
<pre><code class="language-rgbasm linenos start=127">UpdatePlayer_UpdateSprite:

    ; Get the unscaled player x position in b
    ld a, [wPlayerPositionX+0]
    ld b, a
    ld a, [wPlayerPositionX+1]
    ld d, a
    
    srl d
    rr b
    srl d
    rr b
    srl d
    rr b
    srl d
    rr b

    ; Get the unscaled player y position in c
    ld a, [wPlayerPositionY+0]
    ld c, a
    ld a, [wPlayerPositionY+1]
    ld e, a

    srl e
    rr c
    srl e
    rr c
    srl e
    rr c
    srl e
    rr c
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Drawing the palyer metasprite
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    ; Save the address of the metasprite into the 'wMetaspriteAddress' variable
    ; Our DrawMetasprites functoin uses that variable
    ld a, LOW(playerTestMetaSprite)
    ld [wMetaspriteAddress+0], a
    ld a, HIGH(playerTestMetaSprite)
    ld [wMetaspriteAddress+1], a


    ; Save the x position
    ld a, b
    ld [wMetaspriteX], a

    ; Save the y position
    ld a, c
    ld [wMetaspriteY], a

    ; Actually call the 'DrawMetasprites function
    call DrawMetasprites;

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ret
</code></pre>
<p>That’s the end our our “UpdatePlayer” function. The final bit of code for our player handles when they are damaged. When an enemy damages the player, we want to decrease our lives by one. We’ll also start flashing  by giving our ‘mPlayerFlash’ variable a non-zero value. In the gameplay game state, if we’ve lost all lives, gameplay will end.</p>
<pre><code class="language-rgbasm linenos start=196">DamagePlayer::

    

    xor a
    ld [mPlayerFlash], a
    inc a
    ld [mPlayerFlash+1], a

    ld a, [wLives]
    dec a
    ld [wLives], a

    ret
</code></pre>
<p>That’s everything for our player. Next, we’ll go over bullets and then onto the enemies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bullets"><a class="header" href="#bullets">Bullets</a></h1>
<p>Bullets are relatively simple, logic-wise. They all travel straight-forward, and de-activate themselves when they leave the screen.</p>
<p>At the top of our “src/main/states/gameplay/objects/bullets.asm” file we’ll setup some variables for bullets and include our tile data.</p>
<pre><code class="language-rgbasm linenos start=2">include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/constants.inc&quot;

SECTION &quot;BulletVariables&quot;, WRAM0

wSpawnBullet: db

; how many bullets are currently active
wActiveBulletCounter:: db

; how many bullet's we've updated
wUpdateBulletsCounter: db 


; Bytes: active, x , y (low), y (high)
wBullets:: ds MAX_BULLET_COUNT*PER_BULLET_BYTES_COUNT


SECTION &quot;Bullets&quot;, ROM0

bulletMetasprite::
    .metasprite1    db 0,0,8,0
    .metaspriteEnd  db 128

bulletTileData:: INCBIN &quot;src/generated/sprites/bullet.2bpp&quot;
bulletTileDataEnd::


</code></pre>
<p>We’ll need to loop through the bullet object pool in the following sections. </p>
<h2 id="initiating-bullets"><a class="header" href="#initiating-bullets">Initiating Bullets</a></h2>
<p>In our “InitializeBullets” function, we’ll copy the tile data for the bullet sprites into VRAM, and set every bullet as inactive. Each bullet is 4 bytes, the first byte signaling if the bullet is active or not. </p>
<p><img src="part3/../assets/part3/img/BulletBytesVisualized.png" alt="BulletBytesVisualized.png" /></p>
<p>We’ll iterate through bullet object pool, named “wBullets”, and activate the first of the the four bytes. Then skipping the next 3 bytes, to go onto the next bullet. We’ll do this until we’ve looped for each bullet in our pool.</p>
<pre><code class="language-rgbasm linenos start=31">InitializeBullets::

    xor a
    ld [wSpawnBullet], a

    ; Copy the bullet tile data intto vram
	ld de, bulletTileData
	ld hl, BULLET_TILES_START
	ld bc, bulletTileDataEnd - bulletTileData
    call CopyDEintoMemoryAtHL

    ; Reset how many bullets are active to 0
    xor a
    ld [wActiveBulletCounter],a

    ld b, a
    ld hl, wBullets
    ld [hl], a

InitializeBullets_Loop:

    ; Increase the address
    ld a, l
    add PER_BULLET_BYTES_COUNT
    ld l, a
    ld a, h
    adc 0
    ld h, a

    ; Increase how many bullets we have initailized
    ld a, b
    inc a
    ld b, a

    cp MAX_BULLET_COUNT
    ret z

    jp InitializeBullets_Loop
</code></pre>
<h2 id="updating-bullets"><a class="header" href="#updating-bullets">Updating Bullets</a></h2>
<p>When we want to update each of bullets, first we should check if any bullets are active. If no bullets are active we can stop early.</p>
<pre><code class="language-rgbasm linenos start=70">UpdateBullets::

    ; Make sure we have SOME active enemies
    ld a, [wSpawnBullet]
    ld b, a
    ld a, [wActiveBulletCounter]
    or b
    cp 0
    ret z
    
    ; Reset our counter for how many bullets we have checked
    xor a
    ld [wUpdateBulletsCounter], a

    ; Get the address of the first bullet in hl
    ld a, LOW(wBullets)
    ld l, a
    ld a, HIGH(wBullets)
    ld h, a

    jp UpdateBullets_PerBullet
</code></pre>
<p>If we have active bullets, we’ll reset how many bullets we’ve checked and set our “hl” registers to point to the first bullets address. </p>
<p>When were updating each bullet, we’ll check each byte, changing hl (the byte we want to read) as we go. At the start, “hl” should point to the first byte. “hl” should point to the first byte at the end too:</p>
<blockquote>
<p>HL should point to the first byte at the end so we can easily do one of two things:</p>
<ul>
<li>deactivate the bullet</li>
<li>jump to the next bullet (by simply adding 4 to hl)</li>
</ul>
</blockquote>
<p>For we each bullet, we’ll do the following:</p>
<ul>
<li>Check if active</li>
<li>Get our x position, save into b</li>
<li>Get our y scaled positon, save into c (low byte), and d (high byte)</li>
<li>Decrease our y position to move the bullet upwards</li>
<li>Reset HL to the first byte of our bullet</li>
<li>Descale the y position we have in c &amp; d, and jump to our deactivation code if c (the low byte) is high enough</li>
<li>Draw our bullet metasprit, if it wasn’t previously deactivated</li>
</ul>
<pre><code class="language-rgbasm linenos start=113">UpdateBullets_PerBullet:

    ; The first byte is if the bullet is active
    ; If it's NOT  zero, it's active, go to the normal update section
    ld a, [hl]
    and a
    jp nz, UpdateBullets_PerBullet_Normal

    ; Do we need to spawn a bullet?
    ; If we dont, loop to the next enemy
    ld a, [wSpawnBullet]
    and a
    jp z, UpdateBullets_Loop
    
UpdateBullets_PerBullet_SpawnDeactivatedBullet:

    ; reset this variable so we don't spawn anymore
    xor a
    ld [wSpawnBullet], a
    
    ; Increase how many bullets are active
    ld a, [wActiveBulletCounter]
    inc a
    ld [wActiveBulletCounter], a

    push hl

    ; Set the current bullet as  active
    ld a, 1
    ld [hli], a

    ; Get the unscaled player x position in b
    ld a, [wPlayerPositionX]
    ld b, a
    ld a, [wPlayerPositionX+1]
    ld d, a
    
    ; Descale the player's x position
    ; the result will only be in the low byt
    srl d
    rr b
    srl d
    rr b
    srl d
    rr b
    srl d
    rr b
    
    ; Set the x position to equal the player's x position
    ld a, b
    ld [hli], a

    ; Set the y position (low)
    ld a, [wPlayerPositionY]
    ld [hli], a

    ; Set the y position (high)
    ld a, [wPlayerPositionY+1]
    ld [hli], a

    pop hl

UpdateBullets_PerBullet_Normal:

    ; Save our active byte
    push hl

    inc hl

    ; Get our x position
    ld a, [hli]
    ld b, a

    ; get our 16-bit y position
    ld a, [hl]
    sub BULLET_MOVE_SPEED
    ld [hli], a
    ld c, a
    ld a, [hl] 
    sbc 0
    ld [hl], a
    ld d, a

    pop hl; go to the active byte

    ; Descale our y position
    srl d
    rr c
    srl d
    rr c
    srl d
    rr c
    srl d
    rr c

    ; See if our non scaled low byte is above 160
    ld a, c
    cp 178
    ; If it's below 160, deactivate
    jp nc, UpdateBullets_DeActivateIfOutOfBounds
    
</code></pre>
<h3 id="drawing-the-bullets"><a class="header" href="#drawing-the-bullets">Drawing the Bullets</a></h3>
<p>We’ll draw our bullet metasprite like we drew the player, using our “DrawMetasprites” function. This function may alter the ‘h’ or ‘l’ registers, so we’ll push the hl register onto the stack before hand. After drawing, we’ll pop the hl register off of the stack to restore it’s value.</p>
<pre><code class="language-rgbasm linenos start=214">
    push hl

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Drawing a metasprite
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     ; Save the address of the metasprite into the 'wMetaspriteAddress' variable
    ; Our DrawMetasprites functoin uses that variable
    ld a, LOW(bulletMetasprite)
    ld [wMetaspriteAddress], a
    ld a, HIGH(bulletMetasprite)
    ld [wMetaspriteAddress+1], a

    ; Save the x position
    ld a, b
    ld [wMetaspriteX], a

    ; Save the y position
    ld a, c
    ld [wMetaspriteY], a

    ; Actually call the 'DrawMetasprites function
    call DrawMetasprites
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    

    pop hl
    
    jp UpdateBullets_Loop
</code></pre>
<h3 id="deactivating-the-bullets"><a class="header" href="#deactivating-the-bullets">Deactivating the Bullets</a></h3>
<p>If a bullet needs to be deactivated, we simply set it’s first byte to 0. At this point in time, the “hl” registers should point at our bullets first byte. This makes deactivation a really simple task. In addition to changing the first byte, we’ll decrease how many bullets we have that are active.</p>
<pre><code class="language-rgbasm linenos start=246">UpdateBullets_DeActivateIfOutOfBounds:

    ; if it's y value is grater than 160
    ; Set as inactive
    xor a
    ld [hl], a

    ; Decrease counter
    ld a,[wActiveBulletCounter]
    dec a
    ld [wActiveBulletCounter], a

    jp UpdateBullets_Loop
</code></pre>
<h3 id="updating-the-next-bullet"><a class="header" href="#updating-the-next-bullet">Updating the next bullet</a></h3>
<p>After we’ve updated a single bullet, we’ll increase how many bullet’s we’ve updated. If we’ve updated all the bullets, we can stop our “UpdateBullets” function. Otherwise, we’ll add 4 bytes to the addressed stored in “hl”, and update the next bullet.</p>
<pre><code class="language-rgbasm linenos start=92">UpdateBullets_Loop:

    ; Check our counter, if it's zero
    ; Stop the function
    ld a, [wUpdateBulletsCounter]
    inc a
    ld [wUpdateBulletsCounter], a

    ; Check if we've already
    ld a, [wUpdateBulletsCounter]
    cp MAX_BULLET_COUNT
    ret nc

    ; Increase the bullet data our address is pointingtwo
    ld a, l
    add PER_BULLET_BYTES_COUNT
    ld l, a
    ld a, h
    adc 0
    ld h, a
</code></pre>
<h2 id="firing-new-bullets"><a class="header" href="#firing-new-bullets">Firing New Bullets</a></h2>
<p>During the “UpdatePlayer” function previously, when use pressed A we called the “FireNextBullet” function.</p>
<p>This function will loop through each bullet in the bullet object pool. When it finds an inactive bullet, it will activate it and set it’s position equal to the players.</p>
<blockquote>
<p>Our bullets only use one 8-bit integer for their x position, so need to de-scale the player’s 16-bit scaled x position</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=260">FireNextBullet::

    ; Make sure we don't have the max amount of enmies
    ld a, [wActiveBulletCounter]
    cp MAX_BULLET_COUNT
    ret nc

    ; Set our spawn bullet variable to true
    ld a, 1
    ld [wSpawnBullet], a

    ret
</code></pre>
<p>That’s it for bullets logic. Next we’ll cover enemies, and after that we’ll step back into the world of bullets with “Bullet vs Enemy” Collision.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enemies"><a class="header" href="#enemies">Enemies</a></h1>
<p>Enemies in SHMUPS often come in a variety of types, and travel also in a variety of patterns. To keep things simple for this tutorial, we’ll have one enemy that flys straight downward. Because of this decision, the logic for enemies is going to be similar to bullets in a way. They both travel vertically and disappear when off screeen. Some differences to point out are:</p>
<ul>
<li>Enemies are not spawned by the player, so we need logic that spawns them at random times and locations.</li>
<li>Enemies must check for collision against the player</li>
<li>We’ll check for collision against bullets in the enemy update function.</li>
</ul>
<p>Here are the RAM variables we’ll use for our enemies:</p>
<ul>
<li>wCurrentEnemyX &amp; wCurrentEnemyY - When we check for collisions, we’ll save the current enemy’s position in these two variables.</li>
<li>wNextEnemyXPosition - When this variable has a non-zero value, we’ll spawn a new enemy at that position</li>
<li>wSpawnCounter - We’ll decrease this, when it reaches zero we’ll spawn a new enemy (by setting ‘wNextEnemyXPosition’ to a non-zero value).</li>
<li>wActiveEnemyCounter - This tracks how many enemies we have on screen</li>
<li>wUpdateEnemiesCounter - This is used when updating enemies so we know how many we have updated.</li>
<li>wUpdateEnemiesCurrentEnemyAddress - When we check for enemy v. bullet collision, we’ll save the address of our current enemy here.</li>
</ul>
<pre><code class="language-rgbasm linenos start=1">include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/constants.inc&quot;

SECTION &quot;EnemyVariables&quot;, WRAM0

wCurrentEnemyX:: db  
wCurrentEnemyY:: db  

wSpawnCounter: db  
wNextEnemyXPosition: db
wActiveEnemyCounter::db
wUpdateEnemiesCounter:db
wUpdateEnemiesCurrentEnemyAddress::dw

; Bytes: active, x , y (low), y (high), speed, health
wEnemies:: ds MAX_ENEMY_COUNT*PER_ENEMY_BYTES_COUNT


</code></pre>
<p>Just like with bullets, we’ll setup ROM data for our enemies tile data and metasprites.</p>
<pre><code class="language-rgbasm linenos start=19">SECTION &quot;Enemies&quot;, ROM0

enemyShipTileData:: INCBIN &quot;src/generated/sprites/enemy-ship.2bpp&quot;
enemyShipTileDataEnd::

enemyShipMetasprite::
    .metasprite1    db 0,0,4,0
    .metasprite2    db 0,8,6,0
    .metaspriteEnd  db 128
</code></pre>
<h2 id="initializing-enemies"><a class="header" href="#initializing-enemies">Initializing Enemies</a></h2>
<p>When initializing the enemies (at the start of gameplay), we’ll copy the enemy tile data into VRAM. Also, like with bullets, we’ll loop through and make sure each enemy is set to inactive.</p>
<pre><code class="language-rgbasm linenos start=29">InitializeEnemies::

	ld de, enemyShipTileData
	ld hl, ENEMY_TILES_START
	ld bc, enemyShipTileDataEnd - enemyShipTileData
    call CopyDEintoMemoryAtHL

    xor a
    ld [wSpawnCounter], a
    ld [wActiveEnemyCounter], a
    ld [wNextEnemyXPosition], a

    ld b, a

    ld hl, wEnemies

InitializeEnemies_Loop:

    ; Set as inactive
    ld [hl], 0
    
    ; Increase the address
    ld a, l
    add PER_ENEMY_BYTES_COUNT
    ld l, a
    ld a, h
    adc 0
    ld h, a

    inc b
    ld a, b

    cp MAX_ENEMY_COUNT
    ret z

    jp InitializeEnemies_Loop
</code></pre>
<h2 id="updating-enemies"><a class="header" href="#updating-enemies">Updating Enemies</a></h2>
<p>When “UpdateEnemies” is called from gameplay, the first thing we try to do is spawn new enemies. After that, if we have no active enemies (and are not trying to spawn a new enemy), we stop the “UpdateEnemies” function. From here, like with bullets, we’ll save the address of our first enemy in hl and start looping through.</p>
<pre><code class="language-rgbasm linenos start=66">UpdateEnemies::

	call TryToSpawnEnemies

    ; Make sure we have active enemies
    ; or we want to spawn a new enemy
    ld a, [wNextEnemyXPosition]
    ld b, a
    ld a, [wActiveEnemyCounter]
    or b
    and a
    ret z
    
    xor a
    ld [wUpdateEnemiesCounter], a

    ld a, LOW(wEnemies)
    ld l, a
    ld a, HIGH(wEnemies)
    ld h, a

    jp UpdateEnemies_PerEnemy
</code></pre>
<p>When we are  looping through our enemy object pool, let’s check if the current enemy is active. If it’s active, we’ll update it like normal. If it isn’t active, the game checks if we want to spawn a new enemy. We specify we want to spawn a new enemy by setting ‘wNextEnemyXPosition’ to a non-zero value. If we don’t want to spawn a new enemy, we’ll move on to the next enemy.</p>
<p>If we want to spawn a new enemy, we’ll set the current inactive enemy to active. Afterwards, we’ll set it’s y position to zero, and it’s x position to whatever was in the ‘wNextEnemyXPosition’ variable. After that, we’ll increase our active enemy counter, and go on to update the enemy like normal.</p>
<pre><code class="language-rgbasm linenos start=109">UpdateEnemies_PerEnemy:

    ; The first byte is if the current object is active
    ; If it's not zero, it's active, go to the normal update section
    ld a, [hl]
    and a
    jp nz, UpdateEnemies_PerEnemy_Update

UpdateEnemies_SpawnNewEnemy:

    ; If this enemy is NOT active
    ; Check If we want to spawn a new enemy
    ld a, [wNextEnemyXPosition]
    and a

    ; If we don't want to spawn a new enemy, we'll skip this (deactivated) enemy
    jp z, UpdateEnemies_Loop

    push hl

    ; If they are deactivated, and we want to spawn an enemy
    ; activate the enemy
    ld a, 1
    ld [hli], a

    ; Put the value for our enemies x position
    ld a, [wNextEnemyXPosition]
    ld [hli], a

    ; Put the value for our enemies y position to equal 0
    xor a
    ld [hli], a
    ld [hld], a
    ld [wNextEnemyXPosition], a

    pop hl
    
    ; Increase counter
    ld a, [wActiveEnemyCounter]
    inc a
    ld [wActiveEnemyCounter], a

</code></pre>
<p>When We are done updating a single enemy, we’ll jump to the “UpdateEnemies_Loop” label. Here we’ll increase how many enemies we’ve updated, and end if we’ve done them all. If we still have more enemies left, we’ll increase the address stored in hl by 6 and update the next enemy.</p>
<blockquote>
<p>The “hl” registers should always point to the current enemies first byte when this label is reached.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=88">UpdateEnemies_Loop:

    ; Check our coutner, if it's zero
    ; Stop the function
    ld a, [wUpdateEnemiesCounter]
    inc a
    ld [wUpdateEnemiesCounter], a

    ; Compare against the active count
    cp MAX_ENEMY_COUNT
    ret nc

    ; Increase the enemy data our address is pointingtwo
    ld a, l
    add PER_ENEMY_BYTES_COUNT
    ld l, a
    ld a, h
    adc 0
    ld h, a
</code></pre>
<p>For updating enemies, we’ll first get the enemies speed. Afterwards we’ll increase the enemies 16-bit y position. Once we’ve done that, we’ll descale the y position so we can check for collisions and draw the ennemy.</p>
<pre><code class="language-rgbasm linenos start=152">UpdateEnemies_PerEnemy_Update:

    ; Save our first bytye
    push hl

    ; Get our move speed in e
    ld bc, enemy_speedByte
    add hl, bc
    ld a, [hl]
    ld e, a

    ; Go back to the first byte
    ; put the address toe the first byte back on the stack for later
    pop hl
    push hl

    inc hl

    ; Get our x position
    ld a, [hli]
    ld b, a
    ld [wCurrentEnemyX], a

    ; get our 16-bit y position
    ; increase it (by e), but also save it 
    ld a, [hl]
    add 10
    ld [hli], a
    ld c, a
    ld a, [hl]
    adc 0
    ld [hl], a
    ld d, a

    pop hl

    ; Descale the y psoition
    srl d
    rr c
    srl d
    rr c
    srl d
    rr c
    srl d
    rr c

    ld a, c
    ld [wCurrentEnemyY], a

</code></pre>
<h2 id="player--bullet-collision"><a class="header" href="#player--bullet-collision">Player &amp; Bullet Collision</a></h2>
<p>One of the differences between enemies and bullets is that enemies must check for collision against the player and also against bullets. For both of these cases, we’ll use a simple Axis-Aligned Bounding Box test. We’ll cover the specific logic in a later section.</p>
<p>If we have a collison against the player we need to damage the player, and redraw how many lives they have. In addition, it’s optional, but we’ll deactivate the enemy too when they collide with the player.</p>
<blockquote>
<p>Our “hl” registers should point to the active byte of the current enemy. We push and pop our “hl” registers to make sure we get back to that same address for later logic.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=203">UpdateEnemies_PerEnemy_CheckPlayerCollision:

    push hl

    call CheckCurrentEnemyAgainstBullets
    call CheckEnemyPlayerCollision

    pop hl

    ld a, [wResult]
    and a
    jp z, UpdateEnemies_NoCollisionWithPlayer 
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    push hl

    call DamagePlayer
    call DrawLives

    pop hl
    
    jp UpdateEnemies_DeActivateEnemy
</code></pre>
<p>If there is no collision with the player, we’ll draw the enemies. This is done just as we did the player and bullets, with the “DrawMetasprites” function.</p>
<pre><code class="language-rgbasm linenos start=241">UpdateEnemies_NoCollisionWithPlayer::

    ; See if our non scaled low byte is above 160
    ld a, [wCurrentEnemyY]
    cp 160
    jp nc, UpdateEnemies_DeActivateEnemy

    push hl



    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; call the 'DrawMetasprites function. setup variables and call
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Save the address of the metasprite into the 'wMetaspriteAddress' variable
    ; Our DrawMetasprites functoin uses that variable
    ld a, LOW(enemyShipMetasprite)
    ld [wMetaspriteAddress+0], a
    ld a, HIGH(enemyShipMetasprite)
    ld [wMetaspriteAddress+1], a

    ; Save the x position
    ld a, [wCurrentEnemyX]
    ld [wMetaspriteX], a

    ; Save the y position
    ld a, [wCurrentEnemyY]
    ld [wMetaspriteY], a

    ; Actually call the 'DrawMetasprites function
    call DrawMetasprites


    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    pop hl
    
    jp UpdateEnemies_Loop
</code></pre>
<h2 id="deactivating-enemies"><a class="header" href="#deactivating-enemies">Deactivating Enemies</a></h2>
<p>Deactivating an enemy is just like with bullets. We’ll set it’s first byte to 0, and decrease our counter variable.</p>
<blockquote>
<p>Here, we can just use the current address in HL. This is the second reason we wanted to keep the address of our first byte on the stack.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=227">UpdateEnemies_DeActivateEnemy:

    ; Set as inactive
    xor a
    ld [hl], a

    ; Decrease counter
    ld a, [wActiveEnemyCounter]
    dec a
    ld [wActiveEnemyCounter], a

    jp UpdateEnemies_Loop

</code></pre>
<h2 id="spawning-enemies"><a class="header" href="#spawning-enemies">Spawning Enemies</a></h2>
<p>Randomly, we want to spawn enemies. We’ll increase a counter called “wEnemyCounter”. When it reaches a preset maximum value, we’ll <strong>maybe</strong> try to spawn a new enemy. </p>
<p>Firstly, We need to make sure we aren’t at maximum enemy capacity, if so, we will not spawn enemy more enemies. If we are not at maximum capacity, we’ll try to get a x position to spawn the enemy at. If our x position is below 24 or above 150, we’ll also NOT spawn a new enemy. </p>
<blockquote>
<p>All enemies are spawned with y position of 0, so we only need to get the x position.</p>
</blockquote>
<p>If we have a valid x position, we’ll reset our spawn counter, and save that x position in the “wNextEnemyXPosition” variable. With this variable set, We’ll later activate and update a enemy that we find in the inactive state.</p>
<pre><code class="language-rgbasm linenos start=285">TryToSpawnEnemies::

    ; Increase our spwncounter
    ld a, [wSpawnCounter]
    inc a
    ld [wSpawnCounter], a

    ; Check our spawn acounter
    ; Stop if it's below a given value
    ld a, [wSpawnCounter]
    cp ENEMY_SPAWN_DELAY_MAX
    ret c

    ; Check our next enemy x position variable
    ; Stop if it's non zero
    ld a, [wNextEnemyXPosition]
    cp 0
    ret nz

    ; Make sure we don't have the max amount of enmies
    ld a, [wActiveEnemyCounter]
    cp MAX_ENEMY_COUNT
    ret nc

GetSpawnPosition:

    ; Generate a semi random value
    call rand
    
    ; make sure it's not above 150
    ld a, b
    cp 150
    ret nc

    ; make sure it's not below 24
    ld a, b
    cp 24
    ret c

    ; reset our spawn counter
    xor a
    ld [wSpawnCounter], a
    
    ld a, b
    ld [wNextEnemyXPosition], a


    ret
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collision-detection"><a class="header" href="#collision-detection">Collision Detection</a></h1>
<p>Collision Detection is cruical to games. It can be a very complicated topic. In Galactic Armada, things will be kept super simple. We’re going to perform a basic implementation of “Axis-Aligned Bounding Box Collision Detection”:</p>
<blockquote>
<p>One of the simpler forms of collision detection is between two rectangles that are axis aligned — meaning no rotation. The algorithm works by ensuring there is no gap between any of the 4 sides of the rectangles. Any gap means a collision does not exist.<sup class="footnote-reference"><a href="#mdn_source">1</a></sup></p>
</blockquote>
<p>The easiest way to check for overlap, is to check the difference bewteen their centers. If the absolute value of their x &amp; y differences (I’ll refer to as “the absolute difference”) are BOTH smaller than the sum of their half widths, we have a collision. This collision detection is run for bullets against enemies, and enemies against the player. Here’s a visualization with bullets and enemies.</p>
<p><img src="part3/../assets/part3/img/CollisionDetectionVisualized.png" alt="CollisionDetectionVisualized.png" /></p>
<p>For this, we’ve created a basic function called “CheckObjectPositionDifference”. This function will help us check for overlap on the x or y axis. When the (absolute) difference between the first two values passed is greater than the third value passed, it jump’s to the label passed in the fourth parameter.</p>
<p>Here’s an example of how to call this function:</p>
<blockquote>
<p>We have the player’s Y position in the <code>d</code> register. We’ll check it’s value against the y value of the current enemy, which we have in a variable named <code>wCurrentEnemyY</code>.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=67">
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Check the y distances. Jump to 'NoCollisionWithPlayer' on failure
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    ld a, [wCurrentEnemyY]
    ld [wObject1Value], a

    ld a, d
    ld [wObject2Value], a

    ; Save if the minimum distance
    ld a, 16
    ld [wSize], a

    call CheckObjectPositionDifference

    ld a, [wResult]
    and a
    jp z, NoCollisionWithPlayer
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

</code></pre>
<p>When checking for collision, we’ll use that function twice. Once for the x-axis, and again for the y-axis.</p>
<blockquote>
<p>NOTE: We don’t need to test the y-axis if the x-axis fails. </p>
</blockquote>
<p>The source code for that function looks like this:</p>
<pre><code class="language-rgbasm linenos start=1">include &quot;src/main/utils/constants.inc&quot;
include &quot;src/main/utils/hardware.inc&quot;

SECTION &quot;CollisionUtilsVariables&quot;, WRAM0

wResult::       db
wSize::         db
wObject1Value:: db
wObject2Value:: db

SECTION &quot;CollisionUtils&quot;, ROM0

CheckObjectPositionDifference::

    ; at this point in time; e = enemy.y, b =bullet.y

    ld a, [wObject1Value]
    ld e, a
    ld a, [wObject2Value]
    ld b, a

    ld a, [wSize]
    ld d, a

    ; subtract  bullet.y, (aka b) - (enemy.y+8, aka e)
    ; carry means e&lt;b, means enemy.bottom is visually above bullet.y (no collision)

    ld a, e
    add d
    cp b

    ;  carry means  no collision
    jp c, CheckObjectPositionDifference_Failure

    ; subtract  enemy.y-8 (aka e) - bullet.y (aka b)
    ; no carry means e&gt;b, means enemy.top is visually below bullet.y (no collision)
    ld a, e
    sub d
    cp b

    ; no carry means no collision
    jp nc, CheckObjectPositionDifference_Failure

    ld a, 1
    ld [wResult], a
    ret

    
CheckObjectPositionDifference_Failure:

    ld a,0
    ld [wResult], a
    ret;

</code></pre>
<div class="footnote-definition" id="mdn_source"><sup class="footnote-definition-label">1</sup>
<p>From <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection">mdn web docs - 2D collision detection</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enemy-player-collision"><a class="header" href="#enemy-player-collision">Enemy-Player Collision</a></h1>
<p>Our enemy versus player collision detection starts with us getting our player’s unscaled x position. We’ll store that value in d.</p>
<pre><code class="language-rgbasm linenos start=6">CheckEnemyPlayerCollision::

    ; Get our player's unscaled x position in d
    ld a, [wPlayerPositionX]
    ld d, a

    ld a, [wPlayerPositionX+1]
    ld e, a

    srl e
    rr d
    srl e
    rr d
    srl e
    rr d
    srl e
    rr d
    
</code></pre>
<p>With our player’s x position in d, we’ll compare it against a previously saved enemy x position variable. If they are more than 16 pixels apart, we’ll jump to the “NoCollisionWithPlayer” label.</p>
<pre><code class="language-rgbasm linenos start=25">
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Check the x distances. Jump to 'NoCollisionWithPlayer' on failure
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ld a, [wCurrentEnemyX]
    ld [wObject1Value], a

    ld a, d
    ld [wObject2Value], a

    ; Save if the minimum distance
    ld a, 16
    ld [wSize], a

    call CheckObjectPositionDifference

    ld a, [wResult]
    and a
    jp z, NoCollisionWithPlayer
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    
</code></pre>
<p>After checking the x axis, if the code gets this far there was an overlap. We’ll do the same for the y axis next.</p>
<p>We’ll get the player’s unscaled y position. We’ll store that value in d for consistency.</p>
<pre><code class="language-rgbasm linenos start=49">    ; Get our player's unscaled y position in d
    ld a, [wPlayerPositionY+0]
    ld d, a

    ld a, [wPlayerPositionY+1]
    ld e, a

    srl e
    rr d
    srl e
    rr d
    srl e
    rr d
    srl e
    rr d

</code></pre>
<p>Just like before, we’ll compare our player’s unscaled y position (stored in d) against a previously saved enemy y position variable. If they are more than 16 pixels apart, we’ll jump to the “NoCollisionWithPlayer” label. </p>
<pre><code class="language-rgbasm linenos start=67">
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Check the y distances. Jump to 'NoCollisionWithPlayer' on failure
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    ld a, [wCurrentEnemyY]
    ld [wObject1Value], a

    ld a, d
    ld [wObject2Value], a

    ; Save if the minimum distance
    ld a, 16
    ld [wSize], a

    call CheckObjectPositionDifference

    ld a, [wResult]
    and a
    jp z, NoCollisionWithPlayer
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

</code></pre>
<p>The “NoCollisionWithPlayer”, just set’s the “wResult” to 0 for failure. If overlap occurs on both axis, we’ll isntead set 1 for success.</p>
<pre><code class="language-rgbasm linenos start=91">
    ld a, 1
    ld [wResult], a

    ret
    
NoCollisionWithPlayer::

    xor a
    ld [wResult], a

    ret

</code></pre>
<p>That’s the enemy-player collision logic. Callers of the function can simply check the “wResult” variable to determine if there was collision.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enemy-bullet-collision"><a class="header" href="#enemy-bullet-collision">Enemy-Bullet Collision</a></h1>
<p>When we are udating enemies, we’ll call a function called “CheckCurrentEnemyAgainstBullets”. This will check the current enemy against all active bullets.</p>
<p>This fuction needs to loop through the bullet object pool, and check if our current enemy overlaps any bullet on both the x and y axis. If so, we’ll deactivate the enemy and bullet.</p>
<p>Our “CheckCurrentEnemyAgainstBullets” function starts off in a manner similar to how we updated enemies &amp; bullets.</p>
<blockquote>
<p>This function expects “hl” points to the curent enemy. We’ll save that in a variable for later usage.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=2">include &quot;src/main/utils/hardware.inc&quot;
include &quot;src/main/utils/constants.inc&quot;
include &quot;src/main/utils/hardware.inc&quot;

SECTION &quot;EnemyBulletCollisionVariables&quot;, WRAM0

wEnemyBulletCollisionCounter: db
wBulletAddresses: dw

SECTION &quot;EnemyBulletCollision&quot;, ROM0

; called from enemies.asm
CheckCurrentEnemyAgainstBullets::


    ld a, l
    ld [wUpdateEnemiesCurrentEnemyAddress], a
    ld a, h
    ld [wUpdateEnemiesCurrentEnemyAddress+1], a

    xor a
    ld [wEnemyBulletCollisionCounter], a
    
    ; Copy our bullets address into wBulletAddress
    ld a, LOW(wBullets)
    ld l, a
    ld a, HIGH(wBullets)
    ld h, a

    jp CheckCurrentEnemyAgainstBullets_PerBullet
</code></pre>
<p>As we loop through the bullets, we need to make sure we only check active bullets. Inactive bullets will be skipped.</p>
<pre><code class="language-rgbasm linenos start=53">CheckCurrentEnemyAgainstBullets_PerBullet:

    ld a, [hl]
    cp 1
    jp nz, CheckCurrentEnemyAgainstBullets_Loop
</code></pre>
<p>First, we need to check if the current enemy and current bullet are overlapping on the x axis. We’ll get the enemy’s x position in e, and the bullet’s x position in b. From there, we’ll again call our “CheckObjectPositionDifference” function. If it returns a failure (wResult=0), we’ll start with the next bullet.</p>
<blockquote>
<p>We add an offset to the x coordinates so they measure from their centers. That offset is half it’s respective object’s width.</p>
</blockquote>
<pre><code class="language-rgbasm linenos start=59">CheckCurrentEnemyAgainstBullets_Check_X_Overlap:

    ; Save our first byte address
    push hl

    inc hl

    ; Get our x position
    ld a, [hli]
    add 4
    ld b, a

    push hl

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Start: Checking the absolute difference
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; The first value
    ld a, b
    ld [wObject1Value], a

    ; The second value
    ld a, [wCurrentEnemyX]
    add 8
    ld [wObject2Value], a

    ; Save if the minimum distance
    ld a, 12
    ld [wSize], a

    call CheckObjectPositionDifference

    
    ld a, [wResult]
    and a
    jp z, CheckCurrentEnemyAgainstBullets_Check_X_Overlap_Fail

    
    pop hl

    jp CheckCurrentEnemyAgainstBullets_PerBullet_Y_Overlap

CheckCurrentEnemyAgainstBullets_Check_X_Overlap_Fail:

    pop hl
    pop hl

    jp CheckCurrentEnemyAgainstBullets_Loop
</code></pre>
<p>Next we restore our hl variable so we can get the y position of our current bullet. Once we have that y position, we’ll get the current enemy’s y position and check for an overlap on the y axis. If no overlap is found, we’ll loop to the next bullet. Otherwise, we have a collision.</p>
<pre><code class="language-rgbasm linenos start=113">    
CheckCurrentEnemyAgainstBullets_PerBullet_Y_Overlap:

    ; get our bullet 16-bit y position
    ld a, [hli]
    ld b, a

    ld a, [hli]
    ld c, a

    ; Descale our 16 bit y position
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b
    srl c
    rr b

    ; preserve our first byte addresss
    pop hl
    push hl

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Start: Checking the absolute difference
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; The first value
    ld a, b
    ld [wObject1Value], a

    ; The second value
    ld a, [wCurrentEnemyY]
    ld [wObject2Value], a

    ; Save if the minimum distance
    ld a, 16
    ld [wSize], a

    call CheckObjectPositionDifference

    pop hl
    
    ld a, [wResult]
    and a
    jp z, CheckCurrentEnemyAgainstBullets_Loop
    jp CheckCurrentEnemyAgainstBullets_PerBullet_Collision

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; End: Checking the absolute difference
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
</code></pre>
<p>If a collision was detected (overlap on x and y axis), we’ll set the current active byte for that bullet to 0. Also , we’ll set the active byte for the current enemy to zero. Before we end the function, we’ll increase and redraw the score, and decrease how many bullets &amp; enemies we have by one.</p>
<pre><code class="language-rgbasm linenos start=168">CheckCurrentEnemyAgainstBullets_PerBullet_Collision:

    ; set the active byte  and x value to 0 for bullets
    xor a
    ld [hli], a
    ld [hl], a

    ld a, [wUpdateEnemiesCurrentEnemyAddress+0]
    ld l, a
    ld a, [wUpdateEnemiesCurrentEnemyAddress+1]
    ld h, a

    ; set the active byte  and x value to 0 for enemies
    xor a
    ld [hli], a
    ld [hl], a
    
    call IncreaseScore
    call DrawScore

    ; Decrease how many active enemies their are
    ld a, [wActiveEnemyCounter]
    dec a
    ld [wActiveEnemyCounter], a

    ; Decrease how many active bullets their are
    ld a, [wActiveBulletCounter]
    dec a
    ld [wActiveBulletCounter], a

    ret
</code></pre>
<p>If no collision happened, we’ll continue our loop through the enemy bullets. When we’ve checked all the bullets, we’ll end the function.</p>
<pre><code class="language-rgbasm linenos start=33">CheckCurrentEnemyAgainstBullets_Loop:

    ; increase our counter
    ld a, [wEnemyBulletCollisionCounter]
    inc a
    ld [wEnemyBulletCollisionCounter], a

    ; Stop if we've checked all bullets
    cp MAX_BULLET_COUNT
    ret nc

    ; Increase the  data our address is pointing to
    ld a, l
    add PER_BULLET_BYTES_COUNT
    ld l, a
    ld a, h
    adc 0
    ld h, a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusione"><a class="header" href="#conclusione">Conclusione</a></h1>
<p>If you liked this tutorial, and you want to take things to the next level, here are some ideas:</p>
<ul>
<li>Add an options menu (for typewriter speed, difficulty, disable audio)</li>
<li>Add Ship Select and different player ships</li>
<li>Add the ability to upgrade your bullet type</li>
<li>Add dialogue and “waves” of enemies</li>
<li>Add different types of enemies</li>
<li>Add a boss</li>
<li>Add a level select</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prossimi-passi"><a class="header" href="#prossimi-passi">Prossimi passi</a></h1>
<p>Oh.</p>
<p>Well, you’ve reached the end of the tutorial…
And yes, as you can see, it’s not finished <em>yet</em>.</p>
<p>We’re actively working on new content (and improvement of the existing one).</p>
<p>In the meantime, the best course of action is to peruse the <a href="resources.html">resources</a> in the next section, and experiment by yourself.
Well, given that, it may be a good idea to <a href="help-feedback.html">ask around</a> for advice.
A lot of the problems and questions you will be encountering have already been solved, so others can—and will!—help you getting started faster.</p>
<p>If you enjoyed the tutorial, please consider <a href="index.html#contributing">contributing</a>, donating to our <a href="https://opencollective.com/gbdev">OpenCollective</a> or simply share the link to this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rgbds-cheatsheet"><a class="header" href="#rgbds-cheatsheet">RGBDS Cheatsheet</a></h1>
<p>The purpose of this page is to provide concise explanations and code snippets for common tasks.
For extra depth, clarity, and understanding, it’s recommended you read through the <a href="part1/setup.html">Hello World</a>, <a href="part2/getting-started.html">Part II - Our first game</a>, and <a href="part3/getting-started.html">Part III - Our second game</a> tutorials.</p>
<p>Assembly syntax &amp; CPU Instructions will not be explained, for more information see the <a href="https://rgbds.gbdev.io/docs/rgbasm.5">RGBDS Language Reference</a></p>
<p>Is there something common you think is missing? Check the <a href="https://github.com/gbdev/gb-asm-tutorial">github repository</a> to open an Issue or contribute to this page. Alternatively, you can reach out on one of the @gbdev <a href="https://gbdev.io/chat.html">community channels</a>.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="cheatsheet.html#rgbds-cheatsheet">RGBDS Cheatsheet</a>
<ul>
<li><a href="cheatsheet.html#table-of-contents">Table of Contents</a></li>
<li><a href="cheatsheet.html#display">Display</a>
<ul>
<li><a href="cheatsheet.html#wait-for-the-vertical-blank-phase">Wait for the vertical blank phase</a></li>
<li><a href="cheatsheet.html#turn-onoff-the-lcd">Turn on/off the LCD</a></li>
<li><a href="cheatsheet.html#turn-onoff-the-background">Turn on/off the background</a></li>
<li><a href="cheatsheet.html#turn-onoff-the-window">Turn on/off the window</a></li>
<li><a href="cheatsheet.html#switch-which-tilemaps-are-used-by-the-window-andor-background">Switch which tilemaps are used by the window and/or background</a></li>
<li><a href="cheatsheet.html#turn-onoff-sprites">Turn on/off sprites</a></li>
<li><a href="cheatsheet.html#turn-onoff-tall-8x16-sprites">Turn on/off tall (8x16) sprites</a></li>
</ul>
</li>
<li><a href="cheatsheet.html#backgrounds">Backgrounds</a>
<ul>
<li><a href="cheatsheet.html#put-backgroundwindow-tile-data-into-vram">Put background/window tile data into VRAM</a></li>
<li><a href="cheatsheet.html#draw-on-the-backgroundwindow">Draw on the Background/Window</a></li>
<li><a href="cheatsheet.html#move-the-background">Move the background</a></li>
<li><a href="cheatsheet.html#move-the-window">Move the window</a></li>
</ul>
</li>
<li><a href="cheatsheet.html#joypad-input">Joypad Input</a>
<ul>
<li><a href="cheatsheet.html#check-if-a-button-is-down">Check if a button is down</a></li>
<li><a href="cheatsheet.html#check-if-a-button-was-just-pressed">Check if a button was JUST pressed</a></li>
<li><a href="cheatsheet.html#wait-for-a-button-press">Wait for a button press</a></li>
</ul>
</li>
<li><a href="cheatsheet.html#hud">HUD</a>
<ul>
<li><a href="cheatsheet.html#draw-text">Draw text</a></li>
<li><a href="cheatsheet.html#draw-a-bottom-hud">Draw a bottom HUD</a></li>
</ul>
</li>
<li><a href="cheatsheet.html#sprites">Sprites</a>
<ul>
<li><a href="cheatsheet.html#put-sprite-tile-data-in-vram">Put sprite tile data in VRAM</a></li>
<li><a href="cheatsheet.html#manipulate-hardware-oam-sprites">Manipulate hardware OAM sprites</a></li>
<li><a href="cheatsheet.html#implement-a-shadow-oam-using-eievui5s-sprite-object-library">Implement a Shadow OAM using @eievui5’s Sprite Object Library</a></li>
<li><a href="cheatsheet.html#manipulate-shadow-oam-oam-sprites">Manipulate Shadow OAM OAM sprites</a></li>
</ul>
</li>
<li><a href="cheatsheet.html#miscellaneous">Miscellaneous</a>
<ul>
<li><a href="cheatsheet.html#save-data">Save Data</a></li>
<li><a href="cheatsheet.html#generate-random-numbers">Generate random numbers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="display"><a class="header" href="#display">Display</a></h2>
<p>The <code>rLCDC</code> register controls all of the following:</p>
<ul>
<li>The screen</li>
<li>The background</li>
<li>The window</li>
<li>Sprite objects</li>
</ul>
<p>For more information on LCD control, refer to the <a href="https://gbdev.io/pandocs/LCDC.html">Pan Docs</a></p>
<h3 id="wait-for-the-vertical-blank-phase"><a class="header" href="#wait-for-the-vertical-blank-phase">Wait for the vertical blank phase</a></h3>
<p>To check for the vertical blank phase, use the <code>rLY</code> register. Compare that register’s value against the height of the Game Boy screen in pixels: 144.</p>
<pre><code class="language-rgbasm linenos">WaitUntilVerticalBlankStart:
    ldh a, [rLY]
    cp 144
    jp c, WaitUntilVerticalBlankStart
</code></pre>
<h3 id="turn-onoff-the-lcd"><a class="header" href="#turn-onoff-the-lcd">Turn on/off the LCD</a></h3>
<p>You can turn the LCD on and off by altering the most significant bit of the <code>rLCDC</code> register. hardware.inc a constant for this: <code>LCDCF_ON</code> .</p>
<p><strong>To turn the LCD on:</strong></p>
<pre><code class="language-rgbasm linenos">ld a, LCDCF_ON
ldh [rLCDC], a
</code></pre>
<p><strong>To turn the LCD off:</strong></p>
<div class="box warning decorated"><p></p><p class="box-title">⚠️</p>
<p>Do not turn the LCD off outside of the Vertical Blank Phase. See “<a href="cheatsheet.html#wait-for-the-vertical-blank-phase">Wait for the vertical blank phase</a>”.</p>
</div>
<pre><code class="language-rgbasm linenos">; Turn the LCD off
ld a, LCDCF_OFF
ldh [rLCDC], a
</code></pre>
<h3 id="turn-onoff-the-background"><a class="header" href="#turn-onoff-the-background">Turn on/off the background</a></h3>
<p>To turn the background layer on and off, alter the least significant bit of the <code>rLCDC</code> register. You can use the <code>LCDCF_BGON</code> constant for this.</p>
<p><strong>To turn the background on:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the background on
ldh a, [rLCDC]
or a, LCDCF_BGON
ldh [rLCDC], a
</code></pre>
<p><strong>To turn the background off:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the background off
ldh a, [rLCDC]
and a, ~LCDCF_BGON
ldh [rLCDC], a
</code></pre>
<h3 id="turn-onoff-the-window"><a class="header" href="#turn-onoff-the-window">Turn on/off the window</a></h3>
<p>To turn the window layer on and off, alter the least significant bit of the <code>rLCDC</code> register. You can use the <code>LCDCF_WINON</code> and <code>LCDCF_WINOFF</code> constants for this.</p>
<p><strong>To turn the window on:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the window on
ldh a, [rLCDC]
or a, LCDCF_WINON
ldh [rLCDC], a
</code></pre>
<p><strong>To turn the window off:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the window off
ldh a, [rLCDC]
and a, LCDCF_WINOFF
ldh [rLCDC], a
</code></pre>
<h3 id="switch-which-tilemaps-are-used-by-the-window-andor-background"><a class="header" href="#switch-which-tilemaps-are-used-by-the-window-andor-background">Switch which tilemaps are used by the window and/or background</a></h3>
<p>By default, the window and background layer will use the same tilemap.</p>
<p>For the window and background, there are 2 memory regions they can use: <code>$9800</code> and <code>$9C00</code>. For more information, refer to the <a href="https://gbdev.io/pandocs/Tile_Maps.html">Pan Docs</a></p>
<p>Which region the background uses is controlled by the 4th bit of the <code>rLCDC</code> register. Which region the window uses is controlled by the 7th bit.</p>
<p>You can use one of the 4 constants to specify which layer uses which region:</p>
<ul>
<li>LCDCF_WIN9800</li>
<li>LCDCF_WIN9C00</li>
<li>LCDCF_BG9800</li>
<li>LCDCF_BG9C00</li>
</ul>
<div class="box tip"><p class="box-title">Note</p>
<p>You still need to make sure the window and background are turned on when using these constants.</p>
</div>
<h3 id="turn-onoff-sprites"><a class="header" href="#turn-onoff-sprites">Turn on/off sprites</a></h3>
<p>Sprites (or objects) can be toggled on and off using the 2nd bit of the <code>rLCDC</code> register. You can use the <code>LCDCF_OBJON</code> and <code>LCDCF_OBJOFF</code> constants for this.</p>
<p><strong>To turn sprite objects on:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the sprites on
ldh a, [rLCDC]
or a, LCDCF_OBJON
ldh [rLCDC], a
</code></pre>
<p><strong>To turn sprite objects off:</strong></p>
<pre><code class="language-rgbasm linenos">; Turn the sprites off
ldh a, [rLCDC]
and a, LCDCF_OBJOFF
ldh [rLCDC], a
</code></pre>
<div class="box tip">
<p>Sprites are in 8x8 mode by default.</p>
</div>
<h3 id="turn-onoff-tall-8x16-sprites"><a class="header" href="#turn-onoff-tall-8x16-sprites">Turn on/off tall (8x16) sprites</a></h3>
<p>Once sprites are enabled, you can enable tall sprites using the 3rd bit of the <code>rLCDC</code> register: <code>LCDCF_OBJ16</code></p>
<div class="box tip">
<p>You can not have some 8x8 sprites and some 8x16 sprites. All sprites must be of the same size.</p>
</div>
<pre><code class="language-rgbasm linenos">; Turn tall sprites on
ldh a, [rLCDC]
or a, LCDCF_OBJ16
ldh [rLCDC], a
</code></pre>
<h2 id="backgrounds"><a class="header" href="#backgrounds">Backgrounds</a></h2>
<h3 id="put-backgroundwindow-tile-data-into-vram"><a class="header" href="#put-backgroundwindow-tile-data-into-vram">Put background/window tile data into VRAM</a></h3>
<p>The region in VRAM dedicated for the background/window tilemaps is from $9000 to $97FF. hardware.inc defines a <code>_VRAM9000</code> constant you can use for that.</p>
<pre><code class="language-rgbasm  lineno">MyBackground:
    INCBIN &quot;src/path/to/my-background.2bpp&quot;
.end

CopyBackgroundWindowTileDataIntoVram:
    ; Copy the tile data
    ld de, myBackground
    ld hl, \_VRAM
    ld bc, MyBackground.end - MyBackground
.loop:
    ld a, [de]
    ld [hli], a
    inc de
    dec bc
    ld a, b
    or a, c
    jr nz, .Loop
</code></pre>
<h3 id="draw-on-the-backgroundwindow"><a class="header" href="#draw-on-the-backgroundwindow">Draw on the Background/Window</a></h3>
<p>The Game Boy has 2 32x32 tilemaps, one at <code>$9800</code> and another at <code>$9C00</code>. Either can be used for the background or window. By default, they both use the tilemap at <code>$9800</code>.</p>
<p>Drawing on the background or window is as simple as copying bytes starting at one of those addresses:</p>
<pre><code class="language-rgbasm  lineno">CopyTilemapTo
   ; Copy the tilemap
    ld de, Tilemap
    ld hl, $9800
    ld bc, TilemapEnd - Tilemap
CopyTilemap:
    ld a, [de]
    ld [hli], a
    inc de
    dec bc
    ld a, b
    or a, c
    jp nz, CopyTilemap
</code></pre>
<div class="box tip">
<p>Make sure the layer you’re targetting has been turned on. See <a href="cheatsheet.html#turn-onoff-the-window">“Turn on/off the window”</a> and <a href="cheatsheet.html#turn-onoff-the-background">“Turn on/off the background”</a></p>
</div>
<div class="box tip">
<p>In terms of tiles, The background/window tilemaps are 32x32. The Game Boy’s screen is 20x18. When copying tiles, understand that RGBDS or the Game Boy won’t automatically jump to the next visible row after you’ve reached the 20th column.</p>
</div>
<h3 id="move-the-background"><a class="header" href="#move-the-background">Move the background</a></h3>
<p>You can move the background horizontally &amp; vertically using the <code>$FF43</code> and <code>$FF42</code> registers, respectively. Hardware.inc defines two constants for that: <code>rSCX</code> and <code>rSCY</code>.</p>
<p><strong>How to change the background’s X Position:</strong></p>
<pre><code class="language-rgbasm linenos">ld a,64
ld [rSCX], a
</code></pre>
<p><strong>How to change the background’s Y Position:</strong></p>
<pre><code class="language-rgbasm linenos">ld a,64
ld [rSCY], a
</code></pre>
<p>Check out the Pan Docs for more info on the <a href="https://gbdev.io/pandocs/Scrolling.html#ff42ff43--scy-scx-background-viewport-y-position-x-position">Background viewport Y position, X position</a></p>
<h3 id="move-the-window"><a class="header" href="#move-the-window">Move the window</a></h3>
<p>Moving the window is the same as moving the background, except using the <code>$FF4B</code> and <code>$FF4A</code> registers. Hardware.inc defines two constants for that: <code>rWX</code> and <code>rWY</code>.</p>
<div class="box tip">
<p>The window layer has a -7 pixel horizontal offset. This means setting <code>rWX</code> to 7 places the window at the left side of the screen, and setting <code>rWX</code> to 87 places the window with its left side halfway across the screen.</p>
</div>
<p><strong>How to change the window’s X Position:</strong></p>
<pre><code class="language-rgbasm linenos">ld a,64
ld [rWX], a
</code></pre>
<p><strong>How to change the window’s Y Position:</strong></p>
<pre><code class="language-rgbasm linenos">ld a,64
ld [rWY], a
</code></pre>
<p>Check out the Pan Docs for more info on the <a href="https://gbdev.io/pandocs/Scrolling.html#ff4aff4b--wy-wx-window-y-position-x-position-plus-7">WY, WX: Window Y position, X position plus 7</a></p>
<h2 id="joypad-input"><a class="header" href="#joypad-input">Joypad Input</a></h2>
<p>Reading joypad input is not a trivial task. For more info see <a href="https://gbdev.io/gb-asm-tutorial/part2/input.html">Tutorial #2</a>, or the <a href="https://gbdev.io/pandocs/Joypad_Input.html">Joypad Input Page</a> in the Pan Docs. Paste this code somewhere in your project:</p>
<pre><code class="language-rgbasm linenos start=113">UpdateKeys:
  ; Poll half the controller
  ld a, P1F_GET_BTN
  call .onenibble
  ld b, a ; B7-4 = 1; B3-0 = unpressed buttons

  ; Poll the other half
  ld a, P1F_GET_DPAD
  call .onenibble
  swap a ; A7-4 = unpressed directions; A3-0 = 1
  xor a, b ; A = pressed buttons + directions
  ld b, a ; B = pressed buttons + directions

  ; And release the controller
  ld a, P1F_GET_NONE
  ldh [rP1], a

  ; Combine with previous wCurKeys to make wNewKeys
  ld a, [wCurKeys]
  xor a, b ; A = keys that changed state
  and a, b ; A = keys that changed to pressed
  ld [wNewKeys], a
  ld a, b
  ld [wCurKeys], a
  ret

.onenibble
  ldh [rP1], a ; switch the key matrix
  call .knownret ; burn 10 cycles calling a known ret
  ldh a, [rP1] ; ignore value while waiting for the key matrix to settle
  ldh a, [rP1]
  ldh a, [rP1] ; this read counts
  or a, $F0 ; A7-4 = 1; A3-0 = unpressed keys
.knownret
  ret
</code></pre>
<p>Next setup 2 variables in working ram:</p>
<pre><code class="language-rgbasm linenos start=410">SECTION &quot;Input Variables&quot;, WRAM0
wCurKeys: db
wNewKeys: db
</code></pre>
<p>Finally, during your game loop, be sure to call the <code>UpdateKeys</code> function during the Vertical Blank phase.</p>
<pre><code class="language-rgbasm linenos">; Check the current keys every frame and move left or right.
call UpdateKeys
</code></pre>
<h3 id="check-if-a-button-is-down"><a class="header" href="#check-if-a-button-is-down">Check if a button is down</a></h3>
<p>You can check if a button is down using any of the following constants from hardware.inc:</p>
<ul>
<li>PADF_DOWN</li>
<li>PADF_UP</li>
<li>PADF_LEFT</li>
<li>PADF_RIGHT</li>
<li>PADF_START</li>
<li>PADF_SELECT</li>
<li>PADF_B</li>
<li>PADF_A</li>
</ul>
<p>You can check if the associataed button is down using the <code>wCurKeys</code> variable:</p>
<pre><code class="language-rgbasm linenos">ld a, [wCurKeys]
and a, PADF_LEFT
jp nz, LeftIsPressedDown
</code></pre>
<h3 id="check-if-a-button-was-just-pressed"><a class="header" href="#check-if-a-button-was-just-pressed">Check if a button was JUST pressed</a></h3>
<p>You can tell if a button was JUST pressed using the <code>wNewKeys</code> variable</p>
<pre><code class="language-rgbasm linenos">ld a, [wNewKeys]
and a, PADF_A
jp nz, AWasJustPressed
</code></pre>
<h3 id="wait-for-a-button-press"><a class="header" href="#wait-for-a-button-press">Wait for a button press</a></h3>
<p>To wait <strong>indefinitely</strong> for a button press, create a loop where you:</p>
<ul>
<li>check if the button has JUST been pressed</li>
<li>If not:
<ul>
<li>Wait until the next vertical blank phase completes</li>
<li>call the <code>UpdateKeys</code> function again</li>
<li>Loop background to the beginning</li>
</ul>
</li>
</ul>
<div class="box tip">
<p>This will halt all other logic (outside of interrupts), be careful if you need any logic running simultaneously.</p>
</div>
<pre><code class="language-rgbasm  linenos">WaitForAButtonToBePressed:
    ld a, [wNewKeys]
    and a, PADF_A
    ret nz
WaitUntilVerticalBlankStart:
    ld a, [rLY]
    cp 144
    jp nc, WaitUntilVerticalBlankStart
WaitUntilVerticalBlankEnd:
    ld a, [rLY]
    cp 144
    jp c, WaitUntilVerticalBlankEnd
    call UpdateKeys
    jp WaitForAButtonToBePressed
</code></pre>
<h2 id="hud"><a class="header" href="#hud">HUD</a></h2>
<p>Heads Up Displays, or HUDs; are commonly used to present extra information to the player. Good examples are: Score, Health, and the current level. The window layer is drawn on top of the background, and cannot move like the background. For this reason, commonly the window layer is used for HUDs. See <a href="cheatsheet.html#how-to-draw-on-the-backgroundwindow">“How to Draw on the Background/Window”</a>.</p>
<h3 id="draw-text"><a class="header" href="#draw-text">Draw text</a></h3>
<p>Drawing text on the window is essentially drawing tiles (with letters/numbers/punctuation on them) on the window and/or background layer.</p>
<p>To simplify the process you can define constant strings.</p>
<div class="box tip">
<p>These constants end with a literal 255, which our code will read as the end of the string.</p>
</div>
<pre><code class="language-rgbasm  lineno">
SECTION &quot;Text ASM&quot;, ROM0

wScoreText::  db &quot;score&quot;, 255

</code></pre>
<p>RGBDS has a character map functionality. You can read more in the <a href="https://rgbds.gbdev.io/docs/rgbasm.5#DEFINING_DATA">RGBDS Assembly Syntax Documentation</a>. This functionality, tells the compiler how to map each letter:</p>
<div class="box tip">
<p>You need to have your text font tiles in VRAM at the locations specified in the map. See <a href="cheatsheet.html#how-to-put-backgroundwindow-tile-data-into-vram">How to put background/window tile data in VRAM</a></p>
</div>
<pre><code class="language-rgbasm  lineno">
CHARMAP &quot; &quot;, 0
CHARMAP &quot;.&quot;, 24
CHARMAP &quot;-&quot;, 25
CHARMAP &quot;a&quot;, 26
CHARMAP &quot;b&quot;, 27
CHARMAP &quot;c&quot;, 28
CHARMAP &quot;d&quot;, 29
CHARMAP &quot;e&quot;, 30
CHARMAP &quot;f&quot;, 31
CHARMAP &quot;g&quot;, 32
CHARMAP &quot;h&quot;, 33
CHARMAP &quot;i&quot;, 34
CHARMAP &quot;j&quot;, 35
CHARMAP &quot;k&quot;, 36
CHARMAP &quot;l&quot;, 37
CHARMAP &quot;m&quot;, 38
CHARMAP &quot;n&quot;, 39
CHARMAP &quot;o&quot;, 40
CHARMAP &quot;p&quot;, 41
CHARMAP &quot;q&quot;, 42
CHARMAP &quot;r&quot;, 43
CHARMAP &quot;s&quot;, 44
CHARMAP &quot;t&quot;, 45
CHARMAP &quot;u&quot;, 46
CHARMAP &quot;v&quot;, 47
CHARMAP &quot;w&quot;, 48
CHARMAP &quot;x&quot;, 49
CHARMAP &quot;y&quot;, 50
CHARMAP &quot;z&quot;, 51

</code></pre>
<p>The above character mapping would convert (by the compiler) our <code>wScoreText</code> text to:</p>
<ul>
<li>s =&gt; 44</li>
<li>c =&gt; 28</li>
<li>o =&gt; 40</li>
<li>r =&gt; 43</li>
<li>e =&gt; 30</li>
<li>255</li>
</ul>
<p>With that setup, we would loop though the bytes of <code>wScoreText</code> and copy each byte to the background/window layer. After we copy each byte, we’ll increment where we will copy to, and which byte in <code>wScoreText</code> we are reading. When we read 255, our code will end.</p>
<div class="box tip">
<p>This example implies that your font tiles are located in VRAM at the locations specified in the character mapping.</p>
</div>
<p><strong>Drawing ‘score’ on the window</strong></p>
<pre><code class="language-rgbasm  lineno">
DrawTextTiles::

    ld hl, wScoreText
    ld de, $9C00 ; The window tilemap starts at $9C00

DrawTextTilesLoop::

    ; Check for the end of string character 255
    ld a, [hl]
    cp 255
    ret z

    ; Write the current character (in hl) to the address
    ; on the tilemap (in de)
    ld a, [hl]
    ld [de], a

    inc hl
    inc de

    ; move to the next character and next background tile
    jp DrawTextTilesLoop
</code></pre>
<h3 id="draw-a-bottom-hud"><a class="header" href="#draw-a-bottom-hud">Draw a bottom HUD</a></h3>
<ul>
<li>Enable the window (with a different tilemap than the background)</li>
<li>Move the window downwards, so only 1 or 2 rows show at the bottom of the screen</li>
<li>Draw your text, score, and icons on the top of the window layer.</li>
</ul>
<div class="box tip">
<p>Sprites will still show over the window. To fully prevent that, you can use STAT interrupts to hide sprites where the bottom HUD will be shown.</p>
</div>
<h2 id="sprites"><a class="header" href="#sprites">Sprites</a></h2>
<h3 id="put-sprite-tile-data-in-vram"><a class="header" href="#put-sprite-tile-data-in-vram">Put sprite tile data in VRAM</a></h3>
<p>The region in VRAM dedicated for sprites is from <code>$8000</code> to <code>$87F0</code>. Hardware.inc defines a <code>_VRAM</code> constant you can use for that. To copy sprite tile data into VRAM, you can use a loop to copy the bytes.</p>
<pre><code class="language-rgbasm linenos">mySprite: INCBIN &quot;src/path/to/my/sprite.2bpp&quot;
mySpriteEnd:

CopySpriteTileDataIntoVram:
    ; Copy the tile data
    ld de, Paddle
    ld hl, _VRAM
    ld bc, mySpriteEnd - mySprite
CopySpriteTileDataIntoVram_Loop:
    ld a, [de]
    ld [hli], a
    inc de
    dec bc
    ld a, b
    or a, c
    jp nz, CopySpriteTileDataIntoVram_Loop
</code></pre>
<h3 id="manipulate-hardware-oam-sprites"><a class="header" href="#manipulate-hardware-oam-sprites">Manipulate hardware OAM sprites</a></h3>
<p>Each hardware sprite has 4 bytes: (in this order)</p>
<ul>
<li>Y position</li>
<li>X Position</li>
<li>Tile ID</li>
<li>Flags/Props (priority, y flip, x flip, palette 0 [DMG], palette 1 [DMG], bank 0 [GBC], bank 1 [GBC])</li>
</ul>
<p>Check out the Pan Docs page on <a href="https://gbdev.io/pandocs/OAM.html">Object Attribute Memory (OAM)</a> for more info.</p>
<p>The bytes controlling hardware OAM sprites start at <code>$FE00</code>, for which hardware.inc has defined a constant as <code>_OAMRAM</code>.</p>
<p><strong>Moving (the first) OAM sprite, one pixel downwards:</strong></p>
<pre><code class="language-rgbasm  linenos">ld a, [_OAMRAM]
inc a
ld [_OAMRAM], a
</code></pre>
<p><strong>Moving (the first) OAM sprite, one pixel to the right:</strong></p>
<pre><code class="language-rgbasm  linenos">ld a, [_OAMRAM + 1]
inc a
ld [_OAMRAM + 1], a
</code></pre>
<p><strong>Setting the tile for the first OAM sprite:</strong></p>
<pre><code class="language-rgbasm  linenos">ld a, 3
ld [_OAMRAM+2], a
</code></pre>
<p><strong>Moving (the fifth) OAM sprite, one pixel downwards:</strong></p>
<pre><code class="language-rgbasm  linenos">ld a, [_OAMRAM + 20]
inc a
ld [_OAMRAM + 20], a
</code></pre>
<p>TODO - Explanation on limitations of direct OAM manipulation.</p>
<div class="box tip">
<p>It’s recommended that developers implement a shadow OAM, like @eievui5’s <a href="https://github.com/eievui5/gb-sprobj-lib">Sprite Object Library</a></p>
</div>
<h3 id="implement-a-shadow-oam-using-eievui5s-sprite-object-library"><a class="header" href="#implement-a-shadow-oam-using-eievui5s-sprite-object-library">Implement a Shadow OAM using @eievui5’s Sprite Object Library</a></h3>
<p>GitHub URL: <a href="https://github.com/eievui5/gb-sprobj-lib">https://github.com/eievui5/gb-sprobj-lib</a></p>
<blockquote>
<p>This is a small, lightweight library meant to facilitate the rendering of sprite objects, including Shadow OAM and OAM DMA, single-entry “simple” sprite objects, and Q12.4 fixed-point position metasprite rendering.</p>
</blockquote>
<p><strong>Usage</strong></p>
<p>The library is relatively simple to get set up. First, put the following in your initialization code:</p>
<pre><code class="language-rgbasm  linenos">    ; Initilize Sprite Object Library.
    call InitSprObjLib

    ; Reset hardware OAM
    xor a, a
    ld b, 160
    ld hl, _OAMRAM
.resetOAM
    ld [hli], a
    dec b
    jr nz, .resetOAM
</code></pre>
<p>Then put a call to <code>ResetShadowOAM</code> at the beginning of your main loop.</p>
<p>Finally, run the following code during VBlank:</p>
<pre><code class="language-rgbasm  linenos">ld a, HIGH(wShadowOAM)
call hOAMDMA
</code></pre>
<h3 id="manipulate-shadow-oam-oam-sprites"><a class="header" href="#manipulate-shadow-oam-oam-sprites">Manipulate Shadow OAM OAM sprites</a></h3>
<p>Once you’ve set up @eievui5’s Sprite Object Library, you can manipulate shadow OAM sprites the exact same way you would manipulate normal hardware OAM sprites. Except, this time you would use the library’s <code>wShadowOAM</code> constant instead of the <code>_OAMRAM</code> register.</p>
<p><strong>Moving (the first) OAM sprite, one pixel downwards:</strong></p>
<pre><code class="language-rgbasm  linenos">ld a,LOW(wShadowOAM)
ld l, a
ld a, HIGH(wShadowOAM)
ld h, a

ld a, [hl]
inc a
ld [wShadowOAM], a
</code></pre>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<h3 id="save-data"><a class="header" href="#save-data">Save Data</a></h3>
<p>If you want to save data in your game, your game’s header needs to specify the correct MBC/cartridge type, and it needs to have a non-zero SRAM size. This should be done in your makefile by passing special parameters to <a href="https://rgbds.gbdev.io/docs/rgbfix.1">rgbfix</a>.</p>
<ul>
<li>Use the <code>-m</code> or <code>--mbc-type</code> parameters to set the mbc/cartidge type, 0x147, to a given value from 0 to 0xFF. <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0147--cartridge-type">More Info</a></li>
<li>Use the <code>-r</code> or <code>--ram-size</code> parameters to set the RAM size, 0x149, to a given value from 0 to 0xFF. <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0149--ram-size">More Info</a>.</li>
</ul>
<p>To save data you need to store variables in Static RAM. This is done by creating a new SRAM “SECTION”. <a href="https://rgbds.gbdev.io/docs/rgbasm.5#SECTIONS">More Info</a></p>
<pre><code class="language-rgbasm  linenos">SECTION &quot;SaveVariables&quot;, SRAM

wCurrentLevel:: db

</code></pre>
<p>To access SRAM, you need to write <code>CART_SRAM_ENABLE</code> to the <code>rRAMG</code> register. When done, you can disable SRAM using the <code>CART_SRAM_DISABLE</code> constant.</p>
<p><strong>To enable read/write access to SRAM:</strong></p>
<pre><code class="language-rgbasm  linenos">
ld a, CART_SRAM_ENABLE
ld [rRAMG], a

</code></pre>
<p><strong>To disable read/write access to SRAM:</strong></p>
<pre><code class="language-rgbasm  linenos">
ld a, CART_SRAM_DISABLE
ld [rRAMG], a

</code></pre>
<p><strong>Initiating Save Data</strong></p>
<p>By default, save data for your game may or may not exist. When the save data does not exist, the value of the bytes dedicated for saving will be random.</p>
<p>You can dedicate a couple bytes towards creating a pseudo-checksum. When these bytes have a <strong>very specific</strong> value, you can be somewhat sure the save data has been initialized.</p>
<pre><code class="language-rgbasm  linenos">SECTION &quot;SaveVariables&quot;, SRAM

wCurrentLevel:: db
wCheckSum1:: db
wCheckSum2:: db
wCheckSum3:: db
</code></pre>
<p>When initializing your save data, you’ll need to</p>
<ul>
<li>enable SRAM access</li>
<li>set your checksum bytes</li>
<li>give your other variables default values</li>
<li>disable SRAM access</li>
</ul>
<pre><code class="language-rgbasm  linenos">
;; Setup our save data
InitSaveData::

    ld a, CART_SRAM_ENABLE
    ld [rRAMG], a

    ld a, 123
    ld [wCheckSum1], a

    ld a, 111
    ld [wCheckSum2], a

    ld a, 222
    ld [wCheckSum3], a

    ld a, 0
    ld [wCurrentLevel], a

    ld a, CART_SRAM_DISABLE
    ld [rRAMG], a

    ret
</code></pre>
<p>Once your save file has been initialized, you can access any variable normally once SRAM is enabled.</p>
<pre><code class="language-rgbasm  linenos">
;; Setup our save data
StartNextLevel::

    ld a, CART_SRAM_ENABLE
    ld [rRAMG], a

    ld a, [wCurrentLevel]
    cp a, 3
    call z, StartLevel3

    ld a, CART_SRAM_DISABLE
    ld [rRAMG], a

    ret
</code></pre>
<h3 id="generate-random-numbers"><a class="header" href="#generate-random-numbers">Generate random numbers</a></h3>
<p>Random number generation is a <a href="https://en.wikipedia.org/wiki/Random_number_generation">complex task in software</a>. What you can implement is a “pseudorandom” generator, giving you a very unpredictable sequence of values. Here’s a <code>rand</code> function (from <a href="https://github.com/pinobatch">Damian Yerrick</a>) you can use.</p>
<pre><code class="language-rgbasm  lineno">
SECTION &quot;MathVariables&quot;, WRAM0
randstate:: ds 4

SECTION &quot;Math&quot;, ROM0

;; From: https://github.com/pinobatch/libbet/blob/master/src/rand.z80#L34-L54
; Generates a pseudorandom 16-bit integer in BC
; using the LCG formula from cc65 rand():
; x[i + 1] = x[i] * 0x01010101 + 0xB3B3B3B3
; @return A=B=state bits 31-24 (which have the best entropy),
; C=state bits 23-16, HL trashed
rand::
  ; Add 0xB3 then multiply by 0x01010101
  ld hl, randstate+0
  ld a, [hl]
  add a, $B3
  ld [hl+], a
  adc a, [hl]
  ld [hl+], a
  adc a, [hl]
  ld [hl+], a
  ld c, a
  adc a, [hl]
  ld [hl], a
  ld b, a
  ret
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="risorse"><a class="header" href="#risorse">Risorse</a></h1>
<h2 id="canali-di-aiuto"><a class="header" href="#canali-di-aiuto">Canali di aiuto</a></h2>
<ul>
<li><a href="https://gbdev.io">GBDev community home page</a> and <a href="https://gbdev.io/chat">chat channels</a>.</li>
</ul>
<h2 id="altri-tutorial"><a class="header" href="#altri-tutorial">Altri tutorial</a></h2>
<ul>
<li><a href="https://evie.gbdev.io/blog/interrupts.html">evie’s interrupts tutorial</a> should help you understand how to use interrupts, and what they are useful for.</li>
<li><a href="https://github.com/tbsp/simple-gb-asm-examples">tbsp’s “Simple GB ASM examples”</a> is a collection of ROMs, each built from a single, fairly short source file.
If you found this tutorial too abstract and/or want to get your feet wet, this is a good place to go to!</li>
<li><a href="https://github.com/daid/gameboy-assembly-by-example">GB assembly by example</a>, Daid’s collection of code snippets.
Consider this a continuation of the tutorial, but without explanations; it’s still useful to peruse them and ask about it, they are overall good quality.</li>
</ul>
<h2 id="ringraziamenti"><a class="header" href="#ringraziamenti">Ringraziamenti</a></h2>
<p>Vi è piaciuto il tutorial o uno dei precedenti?
Quanto segue dovrebbe esservi utile per il resto del vostro viaggio!</p>
<ul>
<li><a href="https://rgbds.gbdev.io/docs/">RGBDS’ online documentation</a> is always useful!
Notably, you’ll find <a href="https://rgbds.gbdev.io/docs/gbz80.7">an instruction reference</a> and <a href="https://rgbds.gbdev.io/docs/rgbasm.5">the reference on RGBASM’s syntax and features</a>.</li>
<li><a href="https://gbdev.io/pandocs">Pan Docs</a> are <em>the</em> reference for all Game Boy hardware.
It’s a good idea to consult it if you aare unsure how a register works, or if you’re wondering how to do something.</li>
<li><a href="https://gbdev.io/gb-opcodes/optables">gb-optables</a> is a more compact instruction table, it becomes more useful when you stop needing the instructions’ descriptions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ringraziamenti-speciali"><a class="header" href="#ringraziamenti-speciali">Ringraziamenti speciali</a></h1>
<p>Un grande ringraziamento a <a href="https://www.pouet.net/user.php?who=21982">Twoflower/Triad</a> per aver realizzato la grafica di Hello World.</p>
<p>Non ringrazierò mai abbastanza Chloé e molti altri per il loro continuo sostegno.</p>
<p>Grazie alla comunità GBDev per essere stata così gentile nel corso degli anni.</p>
<p><strong>Siete tutti fantastici. Grazie mille.</strong></p>
<hr />
<p>Si ringrazia il team di <a href="https://www.rust-lang.org">Rust language</a> per aver realizzato <a href="https://github.com/rust-lang/mdBook">mdBook</a>, che alimenta questo libro (questo design, onestamente elegante, è quello di serie!!!).</p>
<p>Un saluto a AYCE, Phantasy, TPPDevs/RainbowDevs, Plutiedev, lft/kryo :)</p>
<p>Un saluto a <a href="https://eievui.ml">Eievui</a>, <a href="https://github.com/Rangi42">Rangi</a>, <a href="https://github.com/MarkSixtyFour">MarkSixtyFour</a>, <a href="https://github.com/aaaaaa123456789">ax6</a>, <a href="https://github.com/basxto">Baŝto</a>, <a href="https://github.com/bbbbbr">bbbbbr</a> e <a href="https://github.com/bitnenfer">bitnenfer</a>!</p>
<p>The Italian translation is curated by <a href="https://github.com/Street-Philosopher">Antonio Guido Leoni</a>, <a href="https://github.com/avivace">Antonio Vivace</a>, <a href="https://github.com/MattiaFortunati">Mattia Fortunati</a>, Matilde Della Morte and <a href="https://github.com/mte90">Daniele Scasciafratte</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="js/linenos.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
